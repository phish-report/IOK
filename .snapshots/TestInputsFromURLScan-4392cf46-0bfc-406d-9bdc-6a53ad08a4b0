([]*iok.URLScanInput) (len=2) {
  (*iok.URLScanInput)({
    LoaderID: (string) (len=32) "98C82464577CC601ABB13BBC9D73AF5B",
    DocumentURL: (string) (len=30) "https://takedown.phish.report/",
    Input: (iok.Input) {
      Title: ([]string) <nil>,
      Hostname: (string) (len=21) "takedown.phish.report",
      DOM: (string) "",
      HTML: (string) (len=359) "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <meta http-equiv=\"refresh\" content=\"0;URL='//phish.report/user/login?redirect=//takedown.phish.report/'\" />\n</head>\n<body>\n<p>This page has moved to <a href=\"//phish.report/user/login?redirect=//takedown.phish.report/\">//phish.report/user/login?redirect=//takedown.phish.report/</a>.</p>\n</body>\n</html>\n",
      JS: ([]string) <nil>,
      CSS: ([]string) <nil>,
      Cookies: ([]string) <nil>,
      Headers: ([]string) (len=15) {
        (string) (len=28) "Alt-Svc: h3=\":443\"; ma=86400",
        (string) (len=24) "Cf-Cache-Status: DYNAMIC",
        (string) (len=28) "Cf-Ray: 8a8cd3b928b57306-LHR",
        (string) (len=38) "Content-Type: text/html; charset=utf-8",
        (string) (len=35) "Date: Thu, 25 Jul 2024 14:26:48 GMT",
        (string) (len=65) "Nel: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}",
        (string) (len=43) "Referrer-Policy: no-referrer-when-downgrade",
        (string) (len=270) "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v4?s=DV45LCxN7ajYKttdMGRXQmzzkac4cM%2B6V%2BGHw7jOQS2wp4FBT01AleRrG6%2BniVd%2F%2FFPr5nV%2FZm00FkoenE01uyx7A3t6WVSRpUqMulAC6ur1l50WsVu4gRooYnrbfKS9m77Rx6tSmro%3D\"}],\"group\":\"cf-nel\",\"max_age\":604800}",
        (string) (len=18) "Server: cloudflare",
        (string) (len=44) "Strict-Transport-Security: max-age=31536000;",
        (string) (len=12) "Vary: Origin",
        (string) (len=31) "X-Content-Type-Options: nosniff",
        (string) (len=22) "X-Ratelimit-Limit: 256",
        (string) (len=26) "X-Ratelimit-Remaining: 256",
        (string) (len=29) "X-Ratelimit-Reset: 1721917620"
      },
      Requests: ([]string) (len=2) {
        (string) (len=30) "https://takedown.phish.report/",
        (string) (len=41) "https://takedown.phish.report/favicon.ico"
      }
    },
    primary: (bool) false
  }),
  (*iok.URLScanInput)({
    LoaderID: (string) (len=32) "63170A4FE651AB1092E1EE6D5CEA8084",
    DocumentURL: (string) (len=65) "https://phish.report/user/login?redirect=//takedown.phish.report/",
    Input: (iok.Input) {
      Title: ([]string) (len=2) {
        (string) (len=36) "Login to Phish Report - phish.report",
        (string) (len=36) "Login to Phish Report - phish.report"
      },
      Hostname: (string) (len=12) "phish.report",
      DOM: (string) (len=13302) "<head>\n    <title>Login to Phish Report - phish.report</title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, shrink-to-fit=no\">\n    <link rel=\"stylesheet\" href=\"/static/css/style-JN2LX6DM.css\">\n    \n    \n    <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/static/apple-touch-icon-2OXCJTJQ.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/static/favicon-32x32-N6PPRUTU.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/static/favicon-16x16-B7JBZPJL.png\">\n    <link rel=\"manifest\" crossorigin=\"use-credentials\" href=\"/site.webmanifest\">\n    <meta name=\"description\" content=\"Detect, disrupt, and deter consumer phishing attacks. Phish Report gives your team the same capabilities as leading brand protection services.\">\n    \n        <meta name=\"keywords\" content=\"phish, phishing, report, scam, email, guide, step by step\">\n    <script defer=\"\" src=\"/static/js/base-ONWR52KH.js\"></script>\n    <script defer=\"\" src=\"/static/js/htmx-ext-PXBLON3M.js\"></script>\n    <link href=\"/opensearch.xml\" rel=\"search\" title=\"Phish Report\" type=\"application/opensearchdescription+xml\">\n    \n        <link rel=\"canonical\" href=\"https://phish.report/user/login?redirect=%2F%2Ftakedown.phish.report%2F\">\n    <meta name=\"sentry-trace\" content=\"04980c969887390fe4c5eeeaa6072e99\">\n    <meta name=\"htmx-config\" content=\"{&quot;requestClass&quot;:&quot;is-loading&quot;,&quot;includeIndicatorStyles&quot;:false,&quot;defaultSwapStyle&quot;:&quot;outerHTML&quot;,&quot;defaultSwapDelay&quot;:150}\">\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    <meta name=\"slack-app-id\" content=\"A03SCSA15FA\"> \n\n    \n        <meta property=\"og:title\" content=\"Login to Phish Report - phish.report\">\n        <meta name=\"og:description\" content=\"Detect, disrupt, and deter consumer phishing attacks. Phish Report gives your team the same capabilities as leading brand protection services.\">\n        <meta name=\"image\" property=\"og:image\" content=\"https://phish.report/static/profile-VOZEG4JU.png\">\n        <meta name=\"twitter:card\" content=\"summary\">\n        <meta name=\"twitter:site\" content=\"@phish_report\">\n    \n    \n</head><body class=\"is-light  \">\n\n\n    <nav class=\"navbar is-fixed-top has-shadow\">\n    <div class=\"container\">\n        <div class=\"navbar-brand\">\n            <a class=\"navbar-item\" href=\"/\">\n                <img src=\"/static/logo-CVCRUOYQ.svg\" alt=\"Phish Report Logo\">\n            </a>\n            <a role=\"button\" class=\"navbar-burger burger\" aria-label=\"menu\" aria-expanded=\"false\" data-target=\"navbarMenuHeroA\">\n                <span aria-hidden=\"true\"></span>\n                <span aria-hidden=\"true\"></span>\n                <span aria-hidden=\"true\"></span>\n            </a>\n        </div>\n        <div id=\"navbarMenuHeroA\" class=\"navbar-menu\">\n            <div class=\"navbar-start\">\n                <div class=\"navbar-item has-dropdown is-hoverable\">\n                    <div class=\"navbar-link\">\n                        How it works\n                    </div>\n                    <div class=\"navbar-dropdown has-text-centered-mobile\">\n                        <a class=\"navbar-item\" href=\"/features/phishing-site-analysis\">\n                            Phishing site analysis\n                        </a>\n                        <a class=\"navbar-item\" href=\"/features/phishing-site-detection\">\n                            Rapid attack detection\n                        </a>\n                    </div>\n                </div>\n\n                <div class=\"navbar-item has-dropdown is-hoverable\">\n                    <div class=\"navbar-link\">\n                        Resources\n                    </div>\n\n                    <div class=\"navbar-dropdown has-text-centered-mobile\">\n                        <a class=\"navbar-item\" href=\"/docs\">\n                            Documentation\n                        </a>\n                        <a class=\"navbar-item\" href=\"/blog\">\n                            Blog\n                        </a>\n                        <a class=\"navbar-item\" href=\"https://community.phish.report\">\n                            Community\n                        </a>\n                    </div>\n                </div>\n                <a href=\"/pricing\" class=\"navbar-item\">\n                    Pricing\n                </a>\n            </div>\n            <div class=\"navbar-end\">\n                \n                    <div class=\"navbar-item\">\n                        <a class=\"button is-light\" href=\"/user/login\">\n                    <span class=\"icon-text\">\n                      <span>Log in</span>\n                      <span class=\"icon\">\n                        <i class=\"far fa-right-to-bracket\"></i>\n                      </span>\n                    </span>\n                        </a>\n                    </div>\n                \n            </div>\n        </div>\n    </div>\n</nav>\n\n\n\n<section class=\"hero is-fullheight-with-navbar has-background-info-light has-content-centered\">\n    <div class=\"hero-body\">\n        <div class=\"container\">\n            <div class=\"box tw-max-w-xl tw-mx-auto\">\n                <h1 class=\"title is-2 has-text-centered\">\n                    Log in to Phish Report\n                </h1>\n                <div class=\"block content is-medium\">\n                    Log into or sign up for a Phish Report account with just your email address.\n                </div>\n                <div class=\"block\">\n    <p class=\"subtitle\">Log in using:</p>\n    <div class=\"buttons is-centered\">\n        <a class=\"button is-medium\" href=\"/user/login-google\" hx-get=\"/user/login-google\">\n            <span class=\"icon\">\n              <i class=\"fa-brands fa-google\"></i>\n            </span>\n            <span>Google</span>\n        </a>\n        <a class=\"button is-medium\" href=\"/user/login-microsoft\" hx-get=\"/user/login-microsoft\">\n            <span class=\"icon\">\n              <i class=\"fa-brands fa-microsoft\"></i>\n            </span>\n            <span>Microsoft</span>\n        </a>\n    </div>\n</div>\n<form class=\"block\" hx-post=\"/user/magic-link\" hx-indicator=\"button\" action=\"/user/magic-link\" method=\"post\">\n    <p class=\"subtitle\">Or, log in by receiving an email:</p>\n    <div class=\"field\">\n        <label class=\"label\" for=\"email\">Your email address</label>\n        <div class=\"control has-icons-left\">\n            <input type=\"email\" name=\"email\" id=\"email\" class=\"input is-large\" required=\"\">\n            <span class=\"icon is-small is-left\">\n                <i class=\"fas fa-at\"></i>\n            </span>\n        </div>\n    </div>\n    <button type=\"submit\" class=\"button is-block is-fullwidth\">Log in/Sign up</button>\n</form>\n\n            </div>\n        </div>\n    </div>\n</section>\n\n\n    \n        <div class=\"section\">\n            <div class=\"container\">\n                \n            </div>\n            <div class=\"container is-max-widescreen\">\n                \n            </div>\n            <div class=\"container is-max-desktop\">\n                \n            </div>\n        </div>\n    \n\n\n\n    <footer class=\"footer p-0 is-light\" aria-labelledby=\"footer-heading\">\n    <h2 id=\"footer-heading\" class=\"tw-sr-only\">Footer</h2>\n    <div class=\"tw-mx-auto tw-max-w-7xl tw-px-6 tw-pb-8 tw-pt-16 sm:tw-pt-18 lg:tw-px-8 lg:tw-pt-20\">\n        <div class=\"xl:tw-grid xl:tw-grid-cols-3 xl:tw-gap-8\">\n            <div class=\"tw-space-y-8\">\n                <img class=\"tw-h-7 tw-mx-auto\" src=\"/static/android-chrome-512x512-ZT3ULTOQ.png\" alt=\"Phish Report\">\n                <p class=\"tw-text-sm tw-leading-6 tw-text-gray-600\">The tools your team need to combat brand impersonation</p>\n                <div class=\"tw-flex tw-space-x-6\">\n                    <a href=\"https://www.linkedin.com/company/phish-report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">LinkedIn</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#linkedin\"></use>\n                        </svg>\n                    </a>\n                    <a href=\"https://twitter.com/phish_report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">Twitter</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#twitter\"></use>\n                        </svg>\n                    </a>\n                    <a href=\"https://github.com/phish-report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">GitHub</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#github\"></use>\n                        </svg>\n                    </a>\n                </div>\n            </div>\n            <div class=\"tw-mt-16 tw-grid tw-grid-cols-2 tw-gap-8 xl:tw-col-span-2 xl:tw-mt-0\">\n                <div class=\"md:tw-grid md:tw-grid-cols-2 md:tw-gap-8\">\n                    <div>\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Solutions</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/docs/case-overview\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Takedowns</a>\n                            </li>\n                            <li>\n                                <a href=\"/IOK\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Campaign tracking</a>\n                            </li>\n                        </ul>\n                    </div>\n                    <div class=\"tw-mt-10 md:tw-mt-0\">\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Support</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/docs\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Documentation</a>\n                            </li>\n                            <li>\n                                <a href=\"/blog\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Blog</a>\n                            </li>\n                            <li>\n                                <a href=\"https://community.phish.report\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Community</a>\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n                <div class=\"md:tw-grid md:tw-grid-cols-2 md:tw-gap-8\">\n                    <div>\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Tools</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/tools/phishing-name-generator\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Name generator</a>\n                            </li>\n                            <li>\n                                <a href=\"/tools/hosting-lookup\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Hosting provider lookup</a>\n                            </li>\n                            <li>\n                                <a href=\"/analysis\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Phishing analyser</a>\n                            </li>\n                        </ul>\n                    </div>\n                    <div class=\"tw-mt-10 md:tw-mt-0\">\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Legal</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/about\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">About us</a>\n                            </li>\n                            <li>\n                                <a href=\"/privacy-policy\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Privacy</a>\n                            </li>\n                            <li>\n                                <a href=\"/terms-of-service\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Terms</a>\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"tw-mt-16 tw-border-t tw-border-gray-900/10 tw-pt-8 sm:tw-mt-20 lg:tw-mt-24\">\n            <p class=\"tw-text-xs tw-leading-5 tw-text-gray-500\">Phish Report Ltd is a company registered in England and Wales (Company No. 15004763) 71-75 Shelton Street, London, WC2H 9JQ</p>\n        </div>\n    </div>\n</footer>\n\n\n<div class=\"modal\"></div>\n<div data-user-or-session-id=\"\"></div>\n\n    \n\n\n\n</body>",
      HTML: (string) (len=13430) "<!DOCTYPE html>\n<html lang=\"en\" class=\"has-navbar-fixed-top\">\n<head>\n    <title>Login to Phish Report - phish.report</title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, shrink-to-fit=no\">\n    <link rel=\"stylesheet\" href=\"/static/css/style-JN2LX6DM.css\">\n    \n    \n    <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/static/apple-touch-icon-2OXCJTJQ.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/static/favicon-32x32-N6PPRUTU.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/static/favicon-16x16-B7JBZPJL.png\">\n    <link rel=\"manifest\" crossorigin=\"use-credentials\" href=\"/site.webmanifest\">\n    <meta name=\"description\"\n          content=\"Detect, disrupt, and deter consumer phishing attacks. Phish Report gives your team the same capabilities as leading brand protection services.\">\n    \n        <meta name=\"keywords\" content=\"phish, phishing, report, scam, email, guide, step by step\">\n    <script defer src=\"/static/js/base-ONWR52KH.js\"></script>\n    <script defer src=\"/static/js/htmx-ext-PXBLON3M.js\"></script>\n    <link href=\"/opensearch.xml\" rel=\"search\" title=\"Phish Report\" type=\"application/opensearchdescription+xml\">\n    \n        <link rel=\"canonical\" href=\"https://phish.report/user/login?redirect=%2F%2Ftakedown.phish.report%2F\"/>\n    <meta name=\"sentry-trace\" content=\"04980c969887390fe4c5eeeaa6072e99\"/>\n    <meta name=\"htmx-config\" content='{\"requestClass\":\"is-loading\",\"includeIndicatorStyles\":false,\"defaultSwapStyle\":\"outerHTML\",\"defaultSwapDelay\":150}'>\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    <meta name=\"slack-app-id\"\n          content=\"A03SCSA15FA\"> \n\n    \n        <meta property=\"og:title\" content=\"Login to Phish Report - phish.report\">\n        <meta name=\"og:description\"\n              content=\"Detect, disrupt, and deter consumer phishing attacks. Phish Report gives your team the same capabilities as leading brand protection services.\">\n        <meta name=\"image\" property=\"og:image\" content=\"https://phish.report/static/profile-VOZEG4JU.png\">\n        <meta name=\"twitter:card\" content=\"summary\">\n        <meta name=\"twitter:site\" content=\"@phish_report\">\n    \n    \n</head>\n<body class=\"is-light  \">\n\n\n    <nav class=\"navbar is-fixed-top has-shadow\">\n    <div class=\"container\">\n        <div class=\"navbar-brand\">\n            <a class=\"navbar-item\" href=\"/\">\n                <img src=\"/static/logo-CVCRUOYQ.svg\" alt=\"Phish Report Logo\">\n            </a>\n            <a role=\"button\" class=\"navbar-burger burger\" aria-label=\"menu\" aria-expanded=\"false\"\n               data-target=\"navbarMenuHeroA\">\n                <span aria-hidden=\"true\"></span>\n                <span aria-hidden=\"true\"></span>\n                <span aria-hidden=\"true\"></span>\n            </a>\n        </div>\n        <div id=\"navbarMenuHeroA\" class=\"navbar-menu\">\n            <div class=\"navbar-start\">\n                <div class=\"navbar-item has-dropdown is-hoverable\">\n                    <div class=\"navbar-link\">\n                        How it works\n                    </div>\n                    <div class=\"navbar-dropdown has-text-centered-mobile\">\n                        <a class=\"navbar-item\" href=\"/features/phishing-site-analysis\">\n                            Phishing site analysis\n                        </a>\n                        <a class=\"navbar-item\" href=\"/features/phishing-site-detection\">\n                            Rapid attack detection\n                        </a>\n                    </div>\n                </div>\n\n                <div class=\"navbar-item has-dropdown is-hoverable\">\n                    <div class=\"navbar-link\">\n                        Resources\n                    </div>\n\n                    <div class=\"navbar-dropdown has-text-centered-mobile\">\n                        <a class=\"navbar-item\" href=\"/docs\">\n                            Documentation\n                        </a>\n                        <a class=\"navbar-item\" href=\"/blog\">\n                            Blog\n                        </a>\n                        <a class=\"navbar-item\" href=\"https://community.phish.report\">\n                            Community\n                        </a>\n                    </div>\n                </div>\n                <a href=\"/pricing\" class=\"navbar-item\">\n                    Pricing\n                </a>\n            </div>\n            <div class=\"navbar-end\">\n                \n                    <div class=\"navbar-item\">\n                        <a class=\"button is-light\" href=\"/user/login\">\n                    <span class=\"icon-text\">\n                      <span>Log in</span>\n                      <span class=\"icon\">\n                        <i class=\"far fa-right-to-bracket\"></i>\n                      </span>\n                    </span>\n                        </a>\n                    </div>\n                \n            </div>\n        </div>\n    </div>\n</nav>\n\n\n\n<section class=\"hero is-fullheight-with-navbar has-background-info-light has-content-centered\">\n    <div class=\"hero-body\">\n        <div class=\"container\">\n            <div class=\"box tw-max-w-xl tw-mx-auto\">\n                <h1 class=\"title is-2 has-text-centered\">\n                    Log in to Phish Report\n                </h1>\n                <div class=\"block content is-medium\">\n                    Log into or sign up for a Phish Report account with just your email address.\n                </div>\n                <div class=\"block\">\n    <p class=\"subtitle\">Log in using:</p>\n    <div class=\"buttons is-centered\">\n        <a class=\"button is-medium\" href=\"/user/login-google\" hx-get=\"/user/login-google\">\n            <span class=\"icon\">\n              <i class=\"fa-brands fa-google\"></i>\n            </span>\n            <span>Google</span>\n        </a>\n        <a class=\"button is-medium\" href=\"/user/login-microsoft\" hx-get=\"/user/login-microsoft\">\n            <span class=\"icon\">\n              <i class=\"fa-brands fa-microsoft\"></i>\n            </span>\n            <span>Microsoft</span>\n        </a>\n    </div>\n</div>\n<form class=\"block\" hx-post=\"/user/magic-link\" hx-indicator=\"button\" action=\"/user/magic-link\" method=\"post\">\n    <p class=\"subtitle\">Or, log in by receiving an email:</p>\n    <div class=\"field\">\n        <label class=\"label\" for=\"email\">Your email address</label>\n        <div class=\"control has-icons-left\">\n            <input type=\"email\" name=\"email\" id=\"email\" class=\"input is-large\" required>\n            <span class=\"icon is-small is-left\">\n                <i class=\"fas fa-at\"></i>\n            </span>\n        </div>\n    </div>\n    <button type=\"submit\" class=\"button is-block is-fullwidth\">Log in/Sign up</button>\n</form>\n\n            </div>\n        </div>\n    </div>\n</section>\n\n\n    \n        <div class=\"section\">\n            <div class=\"container\">\n                \n            </div>\n            <div class=\"container is-max-widescreen\">\n                \n            </div>\n            <div class=\"container is-max-desktop\">\n                \n            </div>\n        </div>\n    \n\n\n\n    <footer class=\"footer p-0 is-light\" aria-labelledby=\"footer-heading\">\n    <h2 id=\"footer-heading\" class=\"tw-sr-only\">Footer</h2>\n    <div class=\"tw-mx-auto tw-max-w-7xl tw-px-6 tw-pb-8 tw-pt-16 sm:tw-pt-18 lg:tw-px-8 lg:tw-pt-20\">\n        <div class=\"xl:tw-grid xl:tw-grid-cols-3 xl:tw-gap-8\">\n            <div class=\"tw-space-y-8\">\n                <img class=\"tw-h-7 tw-mx-auto\" src=\"/static/android-chrome-512x512-ZT3ULTOQ.png\" alt=\"Phish Report\">\n                <p class=\"tw-text-sm tw-leading-6 tw-text-gray-600\">The tools your team need to combat brand impersonation</p>\n                <div class=\"tw-flex tw-space-x-6\">\n                    <a href=\"https://www.linkedin.com/company/phish-report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">LinkedIn</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#linkedin\"></use>\n                        </svg>\n                    </a>\n                    <a href=\"https://twitter.com/phish_report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">Twitter</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#twitter\"></use>\n                        </svg>\n                    </a>\n                    <a href=\"https://github.com/phish-report\" class=\"tw-text-gray-400 hover:tw-text-gray-500\">\n                        <span class=\"tw-sr-only\">GitHub</span>\n                        <svg class=\"tw-h-6 tw-w-6\" fill=\"currentColor\" viewBox=\"0 0 24 24\" aria-hidden=\"true\">\n                            <use xlink:href=\"/static/brands-UAUXROGY.svg#github\"></use>\n                        </svg>\n                    </a>\n                </div>\n            </div>\n            <div class=\"tw-mt-16 tw-grid tw-grid-cols-2 tw-gap-8 xl:tw-col-span-2 xl:tw-mt-0\">\n                <div class=\"md:tw-grid md:tw-grid-cols-2 md:tw-gap-8\">\n                    <div>\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Solutions</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/docs/case-overview\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Takedowns</a>\n                            </li>\n                            <li>\n                                <a href=\"/IOK\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Campaign tracking</a>\n                            </li>\n                        </ul>\n                    </div>\n                    <div class=\"tw-mt-10 md:tw-mt-0\">\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Support</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/docs\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Documentation</a>\n                            </li>\n                            <li>\n                                <a href=\"/blog\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Blog</a>\n                            </li>\n                            <li>\n                                <a href=\"https://community.phish.report\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Community</a>\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n                <div class=\"md:tw-grid md:tw-grid-cols-2 md:tw-gap-8\">\n                    <div>\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Tools</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/tools/phishing-name-generator\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Name generator</a>\n                            </li>\n                            <li>\n                                <a href=\"/tools/hosting-lookup\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Hosting provider lookup</a>\n                            </li>\n                            <li>\n                                <a href=\"/analysis\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Phishing analyser</a>\n                            </li>\n                        </ul>\n                    </div>\n                    <div class=\"tw-mt-10 md:tw-mt-0\">\n                        <h3 class=\"tw-text-sm tw-font-semibold tw-leading-6 tw-text-gray-900\">Legal</h3>\n                        <ul role=\"list\" class=\"tw-mt-6 tw-space-y-4\">\n                            <li>\n                                <a href=\"/about\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">About us</a>\n                            </li>\n                            <li>\n                                <a href=\"/privacy-policy\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Privacy</a>\n                            </li>\n                            <li>\n                                <a href=\"/terms-of-service\" class=\"tw-text-sm tw-leading-6 tw-text-gray-600 hover:tw-text-gray-900\">Terms</a>\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <div class=\"tw-mt-16 tw-border-t tw-border-gray-900/10 tw-pt-8 sm:tw-mt-20 lg:tw-mt-24\">\n            <p class=\"tw-text-xs tw-leading-5 tw-text-gray-500\">Phish Report Ltd is a company registered in England and Wales (Company No. 15004763) 71-75 Shelton Street, London, WC2H 9JQ</p>\n        </div>\n    </div>\n</footer>\n\n\n<div class=\"modal\"></div>\n<div data-user-or-session-id=\"\"></div>\n\n    <div hx-post=\"/user/js-enabled\" hx-trigger=\"load\" hx-swap=\"outerHTML\"></div>\n\n</body>\n</html>\n",
      JS: ([]string) (len=2) {
        (string) (len=7279) "(() => {\n  // node_modules/htmx-ext-sse/sse.js\n  (function() {\n    var api;\n    htmx.defineExtension(\"sse\", {\n      /**\n       * Init saves the provided reference to the internal HTMX API.\n       *\n       * @param {import(\"../htmx\").HtmxInternalApi} api\n       * @returns void\n       */\n      init: function(apiRef) {\n        api = apiRef;\n        if (htmx.createEventSource == void 0) {\n          htmx.createEventSource = createEventSource;\n        }\n      },\n      /**\n       * onEvent handles all events passed to this extension.\n       *\n       * @param {string} name\n       * @param {Event} evt\n       * @returns void\n       */\n      onEvent: function(name, evt) {\n        var parent = evt.target || evt.detail.elt;\n        switch (name) {\n          case \"htmx:beforeCleanupElement\":\n            var internalData = api.getInternalData(parent);\n            if (internalData.sseEventSource) {\n              internalData.sseEventSource.close();\n            }\n            return;\n          case \"htmx:afterProcessNode\":\n            ensureEventSourceOnElement(parent);\n        }\n      }\n    });\n    function createEventSource(url) {\n      return new EventSource(url, { withCredentials: true });\n    }\n    function registerSSE(elt) {\n      queryAttributeOnThisOrChildren(elt, \"sse-swap\").forEach(function(child) {\n        var sourceElement = api.getClosestMatch(child, hasEventSource);\n        if (sourceElement == null) {\n          return null;\n        }\n        var internalData = api.getInternalData(sourceElement);\n        var source = internalData.sseEventSource;\n        var sseSwapAttr = api.getAttributeValue(child, \"sse-swap\");\n        var sseEventNames = sseSwapAttr.split(\",\");\n        for (var i = 0; i < sseEventNames.length; i++) {\n          var sseEventName = sseEventNames[i].trim();\n          var listener = function(event) {\n            if (maybeCloseSSESource(sourceElement)) {\n              return;\n            }\n            if (!api.bodyContains(child)) {\n              source.removeEventListener(sseEventName, listener);\n              return;\n            }\n            if (!api.triggerEvent(elt, \"htmx:sseBeforeMessage\", event)) {\n              return;\n            }\n            swap(child, event.data);\n            api.triggerEvent(elt, \"htmx:sseMessage\", event);\n          };\n          api.getInternalData(child).sseEventListener = listener;\n          source.addEventListener(sseEventName, listener);\n        }\n      });\n      queryAttributeOnThisOrChildren(elt, \"hx-trigger\").forEach(function(child) {\n        var sourceElement = api.getClosestMatch(child, hasEventSource);\n        if (sourceElement == null) {\n          return null;\n        }\n        var internalData = api.getInternalData(sourceElement);\n        var source = internalData.sseEventSource;\n        var sseEventName = api.getAttributeValue(child, \"hx-trigger\");\n        if (sseEventName == null) {\n          return;\n        }\n        if (sseEventName.slice(0, 4) != \"sse:\") {\n          return;\n        }\n        var listener = function(event) {\n          if (maybeCloseSSESource(sourceElement)) {\n            return;\n          }\n          if (!api.bodyContains(child)) {\n            source.removeEventListener(sseEventName, listener);\n          }\n          htmx.trigger(child, sseEventName, event);\n          htmx.trigger(child, \"htmx:sseMessage\", event);\n        };\n        api.getInternalData(elt).sseEventListener = listener;\n        source.addEventListener(sseEventName.slice(4), listener);\n      });\n    }\n    function ensureEventSourceOnElement(elt, retryCount) {\n      if (elt == null) {\n        return null;\n      }\n      queryAttributeOnThisOrChildren(elt, \"sse-connect\").forEach(function(child) {\n        var sseURL = api.getAttributeValue(child, \"sse-connect\");\n        if (sseURL == null) {\n          return;\n        }\n        ensureEventSource(child, sseURL, retryCount);\n      });\n      registerSSE(elt);\n    }\n    function ensureEventSource(elt, url, retryCount) {\n      var source = htmx.createEventSource(url);\n      source.onerror = function(err) {\n        api.triggerErrorEvent(elt, \"htmx:sseError\", { error: err, source });\n        if (maybeCloseSSESource(elt)) {\n          return;\n        }\n        if (source.readyState === EventSource.CLOSED) {\n          retryCount = retryCount || 0;\n          var timeout = Math.random() * (2 ^ retryCount) * 500;\n          window.setTimeout(function() {\n            ensureEventSourceOnElement(elt, Math.min(7, retryCount + 1));\n          }, timeout);\n        }\n      };\n      source.onopen = function(evt) {\n        api.triggerEvent(elt, \"htmx:sseOpen\", { source });\n      };\n      api.getInternalData(elt).sseEventSource = source;\n      var closeAttribute = api.getAttributeValue(elt, \"sse-close\");\n      if (closeAttribute) {\n        source.addEventListener(closeAttribute, function() {\n          source.close();\n        });\n      }\n    }\n    function maybeCloseSSESource(elt) {\n      if (!api.bodyContains(elt)) {\n        var source = api.getInternalData(elt).sseEventSource;\n        if (source != void 0) {\n          source.close();\n          return true;\n        }\n      }\n      return false;\n    }\n    function queryAttributeOnThisOrChildren(elt, attributeName) {\n      var result = [];\n      if (api.hasAttribute(elt, attributeName)) {\n        result.push(elt);\n      }\n      elt.querySelectorAll(\"[\" + attributeName + \"], [data-\" + attributeName + \"]\").forEach(function(node) {\n        result.push(node);\n      });\n      return result;\n    }\n    function swap(elt, content) {\n      api.withExtensions(elt, function(extension) {\n        content = extension.transformResponse(content, null, elt);\n      });\n      var swapSpec = api.getSwapSpecification(elt);\n      var target = api.getTarget(elt);\n      api.swap(target, content, swapSpec);\n    }\n    function doSettle(settleInfo) {\n      return function() {\n        settleInfo.tasks.forEach(function(task) {\n          task.call();\n        });\n        settleInfo.elts.forEach(function(elt) {\n          if (elt.classList) {\n            elt.classList.remove(htmx.config.settlingClass);\n          }\n          api.triggerEvent(elt, \"htmx:afterSettle\");\n        });\n      };\n    }\n    function hasEventSource(node) {\n      return api.getInternalData(node).sseEventSource != null;\n    }\n  })();\n\n  // node_modules/htmx-ext-debug/debug.js\n  htmx.defineExtension(\"debug\", {\n    onEvent: function(name, evt) {\n      if (console.debug) {\n        console.debug(name, evt);\n      } else if (console) {\n        console.log(\"DEBUG:\", name, evt);\n      } else {\n        throw new Error(\"NO CONSOLE SUPPORTED\");\n      }\n    }\n  });\n\n  // js/htmx-ext.ts\n  htmx.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[data-sse-onclick]\").forEach((el) => {\n      el.addEventListener(\"click\", () => {\n        el.setAttribute(\"hx-ext\", \"sse\");\n        htmx.process(el);\n      });\n    });\n  });\n  htmx.on(\"htmx:sseOpen\", (evt) => {\n    document.querySelector(evt.target.getAttribute(\"hx-indicator\"))?.classList.add(\"is-loading\");\n    let i;\n    i = setInterval(() => {\n      if (evt.detail.source.readyState == EventSource.CLOSED) {\n        document.querySelector(evt.target.getAttribute(\"hx-indicator\"))?.classList.remove(\"is-loading\");\n        clearInterval(i);\n      }\n    }, 1e3);\n  });\n})();\n",
        (string) (len=968585) "(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/bulma-toast/dist/bulma-toast.min.js\n  var require_bulma_toast_min = __commonJS({\n    \"node_modules/bulma-toast/dist/bulma-toast.min.js\"(exports, module2) {\n      (function(a, b) {\n        \"object\" == typeof exports && \"undefined\" != typeof module2 ? b(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], b) : (a = \"undefined\" == typeof globalThis ? a || self : globalThis, b(a.bulmaToast = {}));\n      })(exports, function(a) {\n        \"use strict\";\n        function b(a2, b2) {\n          var c2 = Object.keys(a2);\n          if (Object.getOwnPropertySymbols) {\n            var d2 = Object.getOwnPropertySymbols(a2);\n            b2 && (d2 = d2.filter(function(b3) {\n              return Object.getOwnPropertyDescriptor(a2, b3).enumerable;\n            })), c2.push.apply(c2, d2);\n          }\n          return c2;\n        }\n        function c(a2) {\n          for (var c2, d2 = 1; d2 < arguments.length; d2++)\n            c2 = null == arguments[d2] ? {} : arguments[d2], d2 % 2 ? b(Object(c2), true).forEach(function(b2) {\n              g(a2, b2, c2[b2]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a2, Object.getOwnPropertyDescriptors(c2)) : b(Object(c2)).forEach(function(b2) {\n              Object.defineProperty(a2, b2, Object.getOwnPropertyDescriptor(c2, b2));\n            });\n          return a2;\n        }\n        function d(a2, b2) {\n          if (!(a2 instanceof b2))\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n        function e2(a2, b2) {\n          for (var c2, d2 = 0; d2 < b2.length; d2++)\n            c2 = b2[d2], c2.enumerable = c2.enumerable || false, c2.configurable = true, \"value\" in c2 && (c2.writable = true), Object.defineProperty(a2, c2.key, c2);\n        }\n        function f(a2, b2, c2) {\n          return b2 && e2(a2.prototype, b2), c2 && e2(a2, c2), a2;\n        }\n        function g(a2, b2, c2) {\n          return b2 in a2 ? Object.defineProperty(a2, b2, { value: c2, enumerable: true, configurable: true, writable: true }) : a2[b2] = c2, a2;\n        }\n        function h() {\n          var a2;\n          return null !== (a2 = o) && void 0 !== a2 ? a2 : document;\n        }\n        function i(a2, b2, c2, d2, e3, f2) {\n          if (n.position)\n            return n.position;\n          var g2 = h().createElement(\"div\");\n          return g2.setAttribute(\"style\", \"width:100%;z-index:99999;position:fixed;pointer-events:none;display:flex;flex-direction:column;padding:15px;\" + p(b2, c2, d2, e3, f2)), a2.appendChild(g2), n.position = g2, g2;\n        }\n        function j(a2) {\n          for (var b2 in n)\n            n[b2].remove();\n          n = {}, o = a2;\n        }\n        function k(a2) {\n          if (!a2.message)\n            throw new Error(\"message is required\");\n          var b2 = c(c({}, m), a2), d2 = new q(b2), e3 = i(b2.appendTo || h().body, b2.position || m.position, b2.offsetTop || m.offsetTop, b2.offsetBottom || m.offsetBottom, b2.offsetLeft || m.offsetLeft, b2.offsetRight || m.offsetRight);\n          if (b2.single)\n            for (var f2 = e3.lastElementChild; f2; )\n              e3.removeChild(f2), f2 = e3.lastElementChild;\n          e3.appendChild(d2.element);\n        }\n        var l = { duration: 2e3, position: \"top-right\", closeOnClick: true, opacity: 1, single: false, offsetTop: 0, offsetBottom: 0, offsetLeft: 0, offsetRight: 0, extraClasses: \"\" }, m = c({}, l), n = {}, o = null, p = function(a2, b2, c2, d2, e3) {\n          return \"top-left\" === a2 ? \"left:\".concat(d2, \";top:\").concat(b2, \";text-align:left;align-items:flex-start;\") : \"top-right\" === a2 ? \"right:\".concat(e3, \";top:\").concat(b2, \";text-align:right;align-items:flex-end;\") : \"top-center\" === a2 ? \"top:\".concat(b2, \";left:0;right:0;text-align:center;align-items:center;\") : \"bottom-left\" === a2 ? \"left:\".concat(d2, \";bottom:\").concat(c2, \";text-align:left;align-items:flex-start;\") : \"bottom-right\" === a2 ? \"right:\".concat(e3, \";bottom:\").concat(c2, \";text-align:right;align-items:flex-end;\") : \"bottom-center\" === a2 ? \"bottom:\".concat(c2, \";left:0;right:0;text-align:center;align-items:center;\") : \"center\" === a2 ? \"top:0;left:0;right:0;bottom:0;flex-flow:column;justify-content:center;align-items:center;\" : void 0;\n        }, q = /* @__PURE__ */ function() {\n          function a2(b2) {\n            var c2 = this;\n            d(this, a2), this.element = h().createElement(\"div\"), this.opacity = b2.opacity, this.type = b2.type, this.animate = b2.animate, this.dismissible = b2.dismissible, this.closeOnClick = b2.closeOnClick, this.message = b2.message, this.duration = b2.duration, this.pauseOnHover = b2.pauseOnHover, this.offsetTop = b2.offsetTop, this.offsetBottom = b2.offsetBottom, this.offsetLeft = b2.offsetLeft, this.offsetRight = b2.offsetRight, this.extraClasses = b2.extraClasses;\n            var e3 = \"width:auto;pointer-events:auto;display:inline-flex;white-space:pre-wrap;opacity:\".concat(this.opacity, \";\"), f2 = [\"notification\", this.extraClasses];\n            if (this.type && f2.push(this.type), this.animate && this.animate[\"in\"]) {\n              var g2 = \"animate__\".concat(this.animate[\"in\"]), i2 = this.animate.speed ? \"animate__\".concat(this.animate.speed) : \"animate__faster\";\n              f2.push(\"animate__animated \".concat(g2, \" \").concat(i2)), this.onAnimationEnd(function() {\n                return c2.element.classList.remove(g2);\n              });\n            }\n            if (this.element.className = f2.join(\" \"), this.dismissible) {\n              var j2 = h().createElement(\"button\");\n              j2.className = \"delete\", j2.addEventListener(\"click\", function() {\n                c2.destroy();\n              }), this.element.insertAdjacentElement(\"afterbegin\", j2);\n            } else\n              e3 += \"padding: 1.25rem 1.5rem\";\n            this.closeOnClick && this.element.addEventListener(\"click\", function() {\n              c2.destroy();\n            }), this.element.setAttribute(\"style\", e3), \"string\" == typeof this.message ? this.element.insertAdjacentHTML(\"beforeend\", this.message) : this.element.appendChild(this.message);\n            var k2 = new r2(function() {\n              c2.destroy();\n            }, this.duration);\n            this.pauseOnHover && (this.element.addEventListener(\"mouseover\", function() {\n              k2.pause();\n            }), this.element.addEventListener(\"mouseout\", function() {\n              k2.resume();\n            }));\n          }\n          return f(a2, [{ key: \"destroy\", value: function() {\n            var a3 = this;\n            this.animate && this.animate.out ? (this.element.classList.add(\"animate__\".concat(this.animate.out)), this.onAnimationEnd(function() {\n              a3.removeParent(a3.element.parentNode), a3.element.remove(), delete n.position;\n            })) : (this.removeParent(this.element.parentNode), this.element.remove(), delete n.position);\n          } }, { key: \"removeParent\", value: function(a3) {\n            a3 && 1 >= a3.children.length && a3.remove();\n          } }, { key: \"onAnimationEnd\", value: function() {\n            var a3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : function() {\n            }, b2 = { animation: \"animationend\", OAnimation: \"oAnimationEnd\", MozAnimation: \"mozAnimationEnd\", WebkitAnimation: \"webkitAnimationEnd\" };\n            for (var c2 in b2)\n              if (void 0 !== this.element.style[c2]) {\n                this.element.addEventListener(b2[c2], function() {\n                  return a3();\n                });\n                break;\n              }\n          } }]), a2;\n        }(), r2 = /* @__PURE__ */ function() {\n          function a2(b2, c2) {\n            d(this, a2), this.timer, this.start, this.remaining = c2, this.callback = b2, this.resume();\n          }\n          return f(a2, [{ key: \"pause\", value: function() {\n            \"undefined\" == typeof document || (window.clearTimeout(this.timer), this.remaining -= /* @__PURE__ */ new Date() - this.start);\n          } }, { key: \"resume\", value: function() {\n            \"undefined\" == typeof document || (this.start = /* @__PURE__ */ new Date(), window.clearTimeout(this.timer), this.timer = window.setTimeout(this.callback, this.remaining));\n          } }]), a2;\n        }();\n        a.resetDefaults = function() {\n          m = c({}, l);\n        }, a.setDefaults = function(a2) {\n          m = c(c({}, l), a2);\n        }, a.setDoc = j, a.toast = k, Object.defineProperty(a, \"__esModule\", { value: true });\n      });\n    }\n  });\n\n  // node_modules/store2/dist/store2.js\n  var require_store2 = __commonJS({\n    \"node_modules/store2/dist/store2.js\"(exports, module2) {\n      (function(window2, define2) {\n        var _ = {\n          version: \"2.12.0\",\n          areas: {},\n          apis: {},\n          // utilities\n          inherit: function(api, o) {\n            for (var p in api) {\n              if (!o.hasOwnProperty(p)) {\n                Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(api, p));\n              }\n            }\n            return o;\n          },\n          stringify: function(d) {\n            return d === void 0 || typeof d === \"function\" ? d + \"\" : JSON.stringify(d);\n          },\n          parse: function(s, fn2) {\n            try {\n              return JSON.parse(s, fn2 || _.revive);\n            } catch (e2) {\n              return s;\n            }\n          },\n          // extension hooks\n          fn: function(name2, fn2) {\n            _.storeAPI[name2] = fn2;\n            for (var api in _.apis) {\n              _.apis[api][name2] = fn2;\n            }\n          },\n          get: function(area, key) {\n            return area.getItem(key);\n          },\n          set: function(area, key, string) {\n            area.setItem(key, string);\n          },\n          remove: function(area, key) {\n            area.removeItem(key);\n          },\n          key: function(area, i) {\n            return area.key(i);\n          },\n          length: function(area) {\n            return area.length;\n          },\n          clear: function(area) {\n            area.clear();\n          },\n          // core functions\n          Store: function(id, area, namespace2) {\n            var store3 = _.inherit(_.storeAPI, function(key, data, overwrite) {\n              if (arguments.length === 0) {\n                return store3.getAll();\n              }\n              if (typeof data === \"function\") {\n                return store3.transact(key, data, overwrite);\n              }\n              if (data !== void 0) {\n                return store3.set(key, data, overwrite);\n              }\n              if (typeof key === \"string\" || typeof key === \"number\") {\n                return store3.get(key);\n              }\n              if (typeof key === \"function\") {\n                return store3.each(key);\n              }\n              if (!key) {\n                return store3.clear();\n              }\n              return store3.setAll(key, data);\n            });\n            store3._id = id;\n            try {\n              var testKey = \"__store2_test\";\n              area.setItem(testKey, \"ok\");\n              store3._area = area;\n              area.removeItem(testKey);\n            } catch (e2) {\n              store3._area = _.storage(\"fake\");\n            }\n            store3._ns = namespace2 || \"\";\n            if (!_.areas[id]) {\n              _.areas[id] = store3._area;\n            }\n            if (!_.apis[store3._ns + store3._id]) {\n              _.apis[store3._ns + store3._id] = store3;\n            }\n            return store3;\n          },\n          storeAPI: {\n            // admin functions\n            area: function(id, area) {\n              var store3 = this[id];\n              if (!store3 || !store3.area) {\n                store3 = _.Store(id, area, this._ns);\n                if (!this[id]) {\n                  this[id] = store3;\n                }\n              }\n              return store3;\n            },\n            namespace: function(namespace2, singleArea) {\n              if (!namespace2) {\n                return this._ns ? this._ns.substring(0, this._ns.length - 1) : \"\";\n              }\n              var ns = namespace2, store3 = this[ns];\n              if (!store3 || !store3.namespace) {\n                store3 = _.Store(this._id, this._area, this._ns + ns + \".\");\n                if (!this[ns]) {\n                  this[ns] = store3;\n                }\n                if (!singleArea) {\n                  for (var name2 in _.areas) {\n                    store3.area(name2, _.areas[name2]);\n                  }\n                }\n              }\n              return store3;\n            },\n            isFake: function() {\n              return this._area.name === \"fake\";\n            },\n            toString: function() {\n              return \"store\" + (this._ns ? \".\" + this.namespace() : \"\") + \"[\" + this._id + \"]\";\n            },\n            // storage functions\n            has: function(key) {\n              if (this._area.has) {\n                return this._area.has(this._in(key));\n              }\n              return !!(this._in(key) in this._area);\n            },\n            size: function() {\n              return this.keys().length;\n            },\n            each: function(fn2, fill2) {\n              for (var i = 0, m = _.length(this._area); i < m; i++) {\n                var key = this._out(_.key(this._area, i));\n                if (key !== void 0) {\n                  if (fn2.call(this, key, this.get(key), fill2) === false) {\n                    break;\n                  }\n                }\n                if (m > _.length(this._area)) {\n                  m--;\n                  i--;\n                }\n              }\n              return fill2 || this;\n            },\n            keys: function(fillList) {\n              return this.each(function(k, v, list) {\n                list.push(k);\n              }, fillList || []);\n            },\n            get: function(key, alt) {\n              var s = _.get(this._area, this._in(key)), fn2;\n              if (typeof alt === \"function\") {\n                fn2 = alt;\n                alt = null;\n              }\n              return s !== null ? _.parse(s, fn2) : alt != null ? alt : s;\n            },\n            getAll: function(fillObj) {\n              return this.each(function(k, v, all) {\n                all[k] = v;\n              }, fillObj || {});\n            },\n            transact: function(key, fn2, alt) {\n              var val = this.get(key, alt), ret = fn2(val);\n              this.set(key, ret === void 0 ? val : ret);\n              return this;\n            },\n            set: function(key, data, overwrite) {\n              var d = this.get(key);\n              if (d != null && overwrite === false) {\n                return data;\n              }\n              return _.set(this._area, this._in(key), _.stringify(data), overwrite) || d;\n            },\n            setAll: function(data, overwrite) {\n              var changed, val;\n              for (var key in data) {\n                val = data[key];\n                if (this.set(key, val, overwrite) !== val) {\n                  changed = true;\n                }\n              }\n              return changed;\n            },\n            add: function(key, data) {\n              var d = this.get(key);\n              if (d instanceof Array) {\n                data = d.concat(data);\n              } else if (d !== null) {\n                var type = typeof d;\n                if (type === typeof data && type === \"object\") {\n                  for (var k in data) {\n                    d[k] = data[k];\n                  }\n                  data = d;\n                } else {\n                  data = d + data;\n                }\n              }\n              _.set(this._area, this._in(key), _.stringify(data));\n              return data;\n            },\n            remove: function(key, alt) {\n              var d = this.get(key, alt);\n              _.remove(this._area, this._in(key));\n              return d;\n            },\n            clear: function() {\n              if (!this._ns) {\n                _.clear(this._area);\n              } else {\n                this.each(function(k) {\n                  _.remove(this._area, this._in(k));\n                }, 1);\n              }\n              return this;\n            },\n            clearAll: function() {\n              var area = this._area;\n              for (var id in _.areas) {\n                if (_.areas.hasOwnProperty(id)) {\n                  this._area = _.areas[id];\n                  this.clear();\n                }\n              }\n              this._area = area;\n              return this;\n            },\n            // internal use functions\n            _in: function(k) {\n              if (typeof k !== \"string\") {\n                k = _.stringify(k);\n              }\n              return this._ns ? this._ns + k : k;\n            },\n            _out: function(k) {\n              return this._ns ? k && k.indexOf(this._ns) === 0 ? k.substring(this._ns.length) : void 0 : (\n                // so each() knows to skip it\n                k\n              );\n            }\n          },\n          // end _.storeAPI\n          storage: function(name2) {\n            return _.inherit(_.storageAPI, { items: {}, name: name2 });\n          },\n          storageAPI: {\n            length: 0,\n            has: function(k) {\n              return this.items.hasOwnProperty(k);\n            },\n            key: function(i) {\n              var c = 0;\n              for (var k in this.items) {\n                if (this.has(k) && i === c++) {\n                  return k;\n                }\n              }\n            },\n            setItem: function(k, v) {\n              if (!this.has(k)) {\n                this.length++;\n              }\n              this.items[k] = v;\n            },\n            removeItem: function(k) {\n              if (this.has(k)) {\n                delete this.items[k];\n                this.length--;\n              }\n            },\n            getItem: function(k) {\n              return this.has(k) ? this.items[k] : null;\n            },\n            clear: function() {\n              for (var k in this.items) {\n                this.removeItem(k);\n              }\n            }\n          }\n          // end _.storageAPI\n        };\n        var store2 = (\n          // safely set this up (throws error in IE10/32bit mode for local files)\n          _.Store(\"local\", function() {\n            try {\n              return localStorage;\n            } catch (e2) {\n            }\n          }())\n        );\n        store2.local = store2;\n        store2._ = _;\n        store2.area(\"session\", function() {\n          try {\n            return sessionStorage;\n          } catch (e2) {\n          }\n        }());\n        store2.area(\"page\", _.storage(\"page\"));\n        if (typeof define2 === \"function\" && define2.amd !== void 0) {\n          define2(\"store2\", [], function() {\n            return store2;\n          });\n        } else if (typeof module2 !== \"undefined\" && module2.exports) {\n          module2.exports = store2;\n        } else {\n          if (window2.store) {\n            _.conflict = window2.store;\n          }\n          window2.store = store2;\n        }\n      })(exports, exports && exports.define);\n    }\n  });\n\n  // node_modules/highlight.js/lib/core.js\n  var require_core = __commonJS({\n    \"node_modules/highlight.js/lib/core.js\"(exports, module2) {\n      var deepFreezeEs6 = { exports: {} };\n      function deepFreeze(obj) {\n        if (obj instanceof Map) {\n          obj.clear = obj.delete = obj.set = function() {\n            throw new Error(\"map is read-only\");\n          };\n        } else if (obj instanceof Set) {\n          obj.add = obj.clear = obj.delete = function() {\n            throw new Error(\"set is read-only\");\n          };\n        }\n        Object.freeze(obj);\n        Object.getOwnPropertyNames(obj).forEach(function(name2) {\n          var prop = obj[name2];\n          if (typeof prop == \"object\" && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n          }\n        });\n        return obj;\n      }\n      deepFreezeEs6.exports = deepFreeze;\n      deepFreezeEs6.exports.default = deepFreeze;\n      var Response2 = class {\n        /**\n         * @param {CompiledMode} mode\n         */\n        constructor(mode) {\n          if (mode.data === void 0)\n            mode.data = {};\n          this.data = mode.data;\n          this.isMatchIgnored = false;\n        }\n        ignoreMatch() {\n          this.isMatchIgnored = true;\n        }\n      };\n      function escapeHTML(value) {\n        return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n      }\n      function inherit$1(original, ...objects) {\n        const result = /* @__PURE__ */ Object.create(null);\n        for (const key in original) {\n          result[key] = original[key];\n        }\n        objects.forEach(function(obj) {\n          for (const key in obj) {\n            result[key] = obj[key];\n          }\n        });\n        return (\n          /** @type {T} */\n          result\n        );\n      }\n      var SPAN_CLOSE = \"</span>\";\n      var emitsWrappingTags = (node) => {\n        return !!node.scope || node.sublanguage && node.language;\n      };\n      var scopeToCSSClass = (name2, { prefix }) => {\n        if (name2.includes(\".\")) {\n          const pieces = name2.split(\".\");\n          return [\n            `${prefix}${pieces.shift()}`,\n            ...pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`)\n          ].join(\" \");\n        }\n        return `${prefix}${name2}`;\n      };\n      var HTMLRenderer = class {\n        /**\n         * Creates a new HTMLRenderer\n         *\n         * @param {Tree} parseTree - the parse tree (must support `walk` API)\n         * @param {{classPrefix: string}} options\n         */\n        constructor(parseTree, options) {\n          this.buffer = \"\";\n          this.classPrefix = options.classPrefix;\n          parseTree.walk(this);\n        }\n        /**\n         * Adds texts to the output stream\n         *\n         * @param {string} text */\n        addText(text) {\n          this.buffer += escapeHTML(text);\n        }\n        /**\n         * Adds a node open to the output stream (if needed)\n         *\n         * @param {Node} node */\n        openNode(node) {\n          if (!emitsWrappingTags(node))\n            return;\n          let className = \"\";\n          if (node.sublanguage) {\n            className = `language-${node.language}`;\n          } else {\n            className = scopeToCSSClass(node.scope, { prefix: this.classPrefix });\n          }\n          this.span(className);\n        }\n        /**\n         * Adds a node close to the output stream (if needed)\n         *\n         * @param {Node} node */\n        closeNode(node) {\n          if (!emitsWrappingTags(node))\n            return;\n          this.buffer += SPAN_CLOSE;\n        }\n        /**\n         * returns the accumulated buffer\n        */\n        value() {\n          return this.buffer;\n        }\n        // helpers\n        /**\n         * Builds a span element\n         *\n         * @param {string} className */\n        span(className) {\n          this.buffer += `<span class=\"${className}\">`;\n        }\n      };\n      var newNode = (opts = {}) => {\n        const result = { children: [] };\n        Object.assign(result, opts);\n        return result;\n      };\n      var TokenTree = class {\n        constructor() {\n          this.rootNode = newNode();\n          this.stack = [this.rootNode];\n        }\n        get top() {\n          return this.stack[this.stack.length - 1];\n        }\n        get root() {\n          return this.rootNode;\n        }\n        /** @param {Node} node */\n        add(node) {\n          this.top.children.push(node);\n        }\n        /** @param {string} scope */\n        openNode(scope) {\n          const node = newNode({ scope });\n          this.add(node);\n          this.stack.push(node);\n        }\n        closeNode() {\n          if (this.stack.length > 1) {\n            return this.stack.pop();\n          }\n          return void 0;\n        }\n        closeAllNodes() {\n          while (this.closeNode())\n            ;\n        }\n        toJSON() {\n          return JSON.stringify(this.rootNode, null, 4);\n        }\n        /**\n         * @typedef { import(\"./html_renderer\").Renderer } Renderer\n         * @param {Renderer} builder\n         */\n        walk(builder) {\n          return this.constructor._walk(builder, this.rootNode);\n        }\n        /**\n         * @param {Renderer} builder\n         * @param {Node} node\n         */\n        static _walk(builder, node) {\n          if (typeof node === \"string\") {\n            builder.addText(node);\n          } else if (node.children) {\n            builder.openNode(node);\n            node.children.forEach((child) => this._walk(builder, child));\n            builder.closeNode(node);\n          }\n          return builder;\n        }\n        /**\n         * @param {Node} node\n         */\n        static _collapse(node) {\n          if (typeof node === \"string\")\n            return;\n          if (!node.children)\n            return;\n          if (node.children.every((el) => typeof el === \"string\")) {\n            node.children = [node.children.join(\"\")];\n          } else {\n            node.children.forEach((child) => {\n              TokenTree._collapse(child);\n            });\n          }\n        }\n      };\n      var TokenTreeEmitter = class extends TokenTree {\n        /**\n         * @param {*} options\n         */\n        constructor(options) {\n          super();\n          this.options = options;\n        }\n        /**\n         * @param {string} text\n         * @param {string} scope\n         */\n        addKeyword(text, scope) {\n          if (text === \"\") {\n            return;\n          }\n          this.openNode(scope);\n          this.addText(text);\n          this.closeNode();\n        }\n        /**\n         * @param {string} text\n         */\n        addText(text) {\n          if (text === \"\") {\n            return;\n          }\n          this.add(text);\n        }\n        /**\n         * @param {Emitter & {root: DataNode}} emitter\n         * @param {string} name\n         */\n        addSublanguage(emitter, name2) {\n          const node = emitter.root;\n          node.sublanguage = true;\n          node.language = name2;\n          this.add(node);\n        }\n        toHTML() {\n          const renderer = new HTMLRenderer(this, this.options);\n          return renderer.value();\n        }\n        finalize() {\n          return true;\n        }\n      };\n      function source(re) {\n        if (!re)\n          return null;\n        if (typeof re === \"string\")\n          return re;\n        return re.source;\n      }\n      function lookahead(re) {\n        return concat(\"(?=\", re, \")\");\n      }\n      function anyNumberOfTimes(re) {\n        return concat(\"(?:\", re, \")*\");\n      }\n      function optional(re) {\n        return concat(\"(?:\", re, \")?\");\n      }\n      function concat(...args) {\n        const joined = args.map((x) => source(x)).join(\"\");\n        return joined;\n      }\n      function stripOptionsFromArgs(args) {\n        const opts = args[args.length - 1];\n        if (typeof opts === \"object\" && opts.constructor === Object) {\n          args.splice(args.length - 1, 1);\n          return opts;\n        } else {\n          return {};\n        }\n      }\n      function either(...args) {\n        const opts = stripOptionsFromArgs(args);\n        const joined = \"(\" + (opts.capture ? \"\" : \"?:\") + args.map((x) => source(x)).join(\"|\") + \")\";\n        return joined;\n      }\n      function countMatchGroups(re) {\n        return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n      }\n      function startsWith2(re, lexeme) {\n        const match = re && re.exec(lexeme);\n        return match && match.index === 0;\n      }\n      var BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n      function _rewriteBackreferences(regexps, { joinWith }) {\n        let numCaptures = 0;\n        return regexps.map((regex) => {\n          numCaptures += 1;\n          const offset2 = numCaptures;\n          let re = source(regex);\n          let out = \"\";\n          while (re.length > 0) {\n            const match = BACKREF_RE.exec(re);\n            if (!match) {\n              out += re;\n              break;\n            }\n            out += re.substring(0, match.index);\n            re = re.substring(match.index + match[0].length);\n            if (match[0][0] === \"\\\\\" && match[1]) {\n              out += \"\\\\\" + String(Number(match[1]) + offset2);\n            } else {\n              out += match[0];\n              if (match[0] === \"(\") {\n                numCaptures++;\n              }\n            }\n          }\n          return out;\n        }).map((re) => `(${re})`).join(joinWith);\n      }\n      var MATCH_NOTHING_RE = /\\b\\B/;\n      var IDENT_RE2 = \"[a-zA-Z]\\\\w*\";\n      var UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\n      var NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\n      var C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\";\n      var BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\";\n      var RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n      var SHEBANG = (opts = {}) => {\n        const beginShebang = /^#![ ]*\\//;\n        if (opts.binary) {\n          opts.begin = concat(\n            beginShebang,\n            /.*\\b/,\n            opts.binary,\n            /\\b.*/\n          );\n        }\n        return inherit$1({\n          scope: \"meta\",\n          begin: beginShebang,\n          end: /$/,\n          relevance: 0,\n          /** @type {ModeCallback} */\n          \"on:begin\": (m, resp) => {\n            if (m.index !== 0)\n              resp.ignoreMatch();\n          }\n        }, opts);\n      };\n      var BACKSLASH_ESCAPE = {\n        begin: \"\\\\\\\\[\\\\s\\\\S]\",\n        relevance: 0\n      };\n      var APOS_STRING_MODE = {\n        scope: \"string\",\n        begin: \"'\",\n        end: \"'\",\n        illegal: \"\\\\n\",\n        contains: [BACKSLASH_ESCAPE]\n      };\n      var QUOTE_STRING_MODE = {\n        scope: \"string\",\n        begin: '\"',\n        end: '\"',\n        illegal: \"\\\\n\",\n        contains: [BACKSLASH_ESCAPE]\n      };\n      var PHRASAL_WORDS_MODE = {\n        begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n      };\n      var COMMENT = function(begin, end2, modeOptions = {}) {\n        const mode = inherit$1(\n          {\n            scope: \"comment\",\n            begin,\n            end: end2,\n            contains: []\n          },\n          modeOptions\n        );\n        mode.contains.push({\n          scope: \"doctag\",\n          // hack to avoid the space from being included. the space is necessary to\n          // match here to prevent the plain text rule below from gobbling up doctags\n          begin: \"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)\",\n          end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,\n          excludeBegin: true,\n          relevance: 0\n        });\n        const ENGLISH_WORD = either(\n          // list of common 1 and 2 letter words in English\n          \"I\",\n          \"a\",\n          \"is\",\n          \"so\",\n          \"us\",\n          \"to\",\n          \"at\",\n          \"if\",\n          \"in\",\n          \"it\",\n          \"on\",\n          // note: this is not an exhaustive list of contractions, just popular ones\n          /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,\n          // contractions - can't we'd they're let's, etc\n          /[A-Za-z]+[-][a-z]+/,\n          // `no-way`, etc.\n          /[A-Za-z][a-z]{2,}/\n          // allow capitalized words at beginning of sentences\n        );\n        mode.contains.push(\n          {\n            // TODO: how to include \", (, ) without breaking grammars that use these for\n            // comment delimiters?\n            // begin: /[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}/\n            // ---\n            // this tries to find sequences of 3 english words in a row (without any\n            // \"programming\" type syntax) this gives us a strong signal that we've\n            // TRULY found a comment - vs perhaps scanning with the wrong language.\n            // It's possible to find something that LOOKS like the start of the\n            // comment - but then if there is no readable text - good chance it is a\n            // false match and not a comment.\n            //\n            // for a visual example please see:\n            // https://github.com/highlightjs/highlight.js/issues/2827\n            begin: concat(\n              /[ ]+/,\n              // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */\n              \"(\",\n              ENGLISH_WORD,\n              /[.]?[:]?([.][ ]|[ ])/,\n              \"){3}\"\n            )\n            // look for 3 words in a row\n          }\n        );\n        return mode;\n      };\n      var C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\n      var C_BLOCK_COMMENT_MODE = COMMENT(\"/\\\\*\", \"\\\\*/\");\n      var HASH_COMMENT_MODE = COMMENT(\"#\", \"$\");\n      var NUMBER_MODE = {\n        scope: \"number\",\n        begin: NUMBER_RE,\n        relevance: 0\n      };\n      var C_NUMBER_MODE = {\n        scope: \"number\",\n        begin: C_NUMBER_RE,\n        relevance: 0\n      };\n      var BINARY_NUMBER_MODE = {\n        scope: \"number\",\n        begin: BINARY_NUMBER_RE,\n        relevance: 0\n      };\n      var REGEXP_MODE = {\n        // this outer rule makes sure we actually have a WHOLE regex and not simply\n        // an expression such as:\n        //\n        //     3 / something\n        //\n        // (which will then blow up when regex's `illegal` sees the newline)\n        begin: /(?=\\/[^/\\n]*\\/)/,\n        contains: [{\n          scope: \"regexp\",\n          begin: /\\//,\n          end: /\\/[gimuy]*/,\n          illegal: /\\n/,\n          contains: [\n            BACKSLASH_ESCAPE,\n            {\n              begin: /\\[/,\n              end: /\\]/,\n              relevance: 0,\n              contains: [BACKSLASH_ESCAPE]\n            }\n          ]\n        }]\n      };\n      var TITLE_MODE = {\n        scope: \"title\",\n        begin: IDENT_RE2,\n        relevance: 0\n      };\n      var UNDERSCORE_TITLE_MODE = {\n        scope: \"title\",\n        begin: UNDERSCORE_IDENT_RE,\n        relevance: 0\n      };\n      var METHOD_GUARD = {\n        // excludes method names from keyword processing\n        begin: \"\\\\.\\\\s*\" + UNDERSCORE_IDENT_RE,\n        relevance: 0\n      };\n      var END_SAME_AS_BEGIN = function(mode) {\n        return Object.assign(\n          mode,\n          {\n            /** @type {ModeCallback} */\n            \"on:begin\": (m, resp) => {\n              resp.data._beginMatch = m[1];\n            },\n            /** @type {ModeCallback} */\n            \"on:end\": (m, resp) => {\n              if (resp.data._beginMatch !== m[1])\n                resp.ignoreMatch();\n            }\n          }\n        );\n      };\n      var MODES = /* @__PURE__ */ Object.freeze({\n        __proto__: null,\n        MATCH_NOTHING_RE,\n        IDENT_RE: IDENT_RE2,\n        UNDERSCORE_IDENT_RE,\n        NUMBER_RE,\n        C_NUMBER_RE,\n        BINARY_NUMBER_RE,\n        RE_STARTERS_RE,\n        SHEBANG,\n        BACKSLASH_ESCAPE,\n        APOS_STRING_MODE,\n        QUOTE_STRING_MODE,\n        PHRASAL_WORDS_MODE,\n        COMMENT,\n        C_LINE_COMMENT_MODE,\n        C_BLOCK_COMMENT_MODE,\n        HASH_COMMENT_MODE,\n        NUMBER_MODE,\n        C_NUMBER_MODE,\n        BINARY_NUMBER_MODE,\n        REGEXP_MODE,\n        TITLE_MODE,\n        UNDERSCORE_TITLE_MODE,\n        METHOD_GUARD,\n        END_SAME_AS_BEGIN\n      });\n      function skipIfHasPrecedingDot(match, response) {\n        const before = match.input[match.index - 1];\n        if (before === \".\") {\n          response.ignoreMatch();\n        }\n      }\n      function scopeClassName(mode, _parent) {\n        if (mode.className !== void 0) {\n          mode.scope = mode.className;\n          delete mode.className;\n        }\n      }\n      function beginKeywords(mode, parent) {\n        if (!parent)\n          return;\n        if (!mode.beginKeywords)\n          return;\n        mode.begin = \"\\\\b(\" + mode.beginKeywords.split(\" \").join(\"|\") + \")(?!\\\\.)(?=\\\\b|\\\\s)\";\n        mode.__beforeBegin = skipIfHasPrecedingDot;\n        mode.keywords = mode.keywords || mode.beginKeywords;\n        delete mode.beginKeywords;\n        if (mode.relevance === void 0)\n          mode.relevance = 0;\n      }\n      function compileIllegal(mode, _parent) {\n        if (!Array.isArray(mode.illegal))\n          return;\n        mode.illegal = either(...mode.illegal);\n      }\n      function compileMatch(mode, _parent) {\n        if (!mode.match)\n          return;\n        if (mode.begin || mode.end)\n          throw new Error(\"begin & end are not supported with match\");\n        mode.begin = mode.match;\n        delete mode.match;\n      }\n      function compileRelevance(mode, _parent) {\n        if (mode.relevance === void 0)\n          mode.relevance = 1;\n      }\n      var beforeMatchExt = (mode, parent) => {\n        if (!mode.beforeMatch)\n          return;\n        if (mode.starts)\n          throw new Error(\"beforeMatch cannot be used with starts\");\n        const originalMode = Object.assign({}, mode);\n        Object.keys(mode).forEach((key) => {\n          delete mode[key];\n        });\n        mode.keywords = originalMode.keywords;\n        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n        mode.starts = {\n          relevance: 0,\n          contains: [\n            Object.assign(originalMode, { endsParent: true })\n          ]\n        };\n        mode.relevance = 0;\n        delete originalMode.beforeMatch;\n      };\n      var COMMON_KEYWORDS = [\n        \"of\",\n        \"and\",\n        \"for\",\n        \"in\",\n        \"not\",\n        \"or\",\n        \"if\",\n        \"then\",\n        \"parent\",\n        // common variable name\n        \"list\",\n        // common variable name\n        \"value\"\n        // common variable name\n      ];\n      var DEFAULT_KEYWORD_SCOPE = \"keyword\";\n      function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n        const compiledKeywords = /* @__PURE__ */ Object.create(null);\n        if (typeof rawKeywords === \"string\") {\n          compileList(scopeName, rawKeywords.split(\" \"));\n        } else if (Array.isArray(rawKeywords)) {\n          compileList(scopeName, rawKeywords);\n        } else {\n          Object.keys(rawKeywords).forEach(function(scopeName2) {\n            Object.assign(\n              compiledKeywords,\n              compileKeywords(rawKeywords[scopeName2], caseInsensitive, scopeName2)\n            );\n          });\n        }\n        return compiledKeywords;\n        function compileList(scopeName2, keywordList) {\n          if (caseInsensitive) {\n            keywordList = keywordList.map((x) => x.toLowerCase());\n          }\n          keywordList.forEach(function(keyword) {\n            const pair = keyword.split(\"|\");\n            compiledKeywords[pair[0]] = [scopeName2, scoreForKeyword(pair[0], pair[1])];\n          });\n        }\n      }\n      function scoreForKeyword(keyword, providedScore) {\n        if (providedScore) {\n          return Number(providedScore);\n        }\n        return commonKeyword(keyword) ? 0 : 1;\n      }\n      function commonKeyword(keyword) {\n        return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n      }\n      var seenDeprecations = {};\n      var error = (message) => {\n        console.error(message);\n      };\n      var warn = (message, ...args) => {\n        console.log(`WARN: ${message}`, ...args);\n      };\n      var deprecated = (version2, message) => {\n        if (seenDeprecations[`${version2}/${message}`])\n          return;\n        console.log(`Deprecated as of ${version2}. ${message}`);\n        seenDeprecations[`${version2}/${message}`] = true;\n      };\n      var MultiClassError = new Error();\n      function remapScopeNames(mode, regexes, { key }) {\n        let offset2 = 0;\n        const scopeNames = mode[key];\n        const emit = {};\n        const positions = {};\n        for (let i = 1; i <= regexes.length; i++) {\n          positions[i + offset2] = scopeNames[i];\n          emit[i + offset2] = true;\n          offset2 += countMatchGroups(regexes[i - 1]);\n        }\n        mode[key] = positions;\n        mode[key]._emit = emit;\n        mode[key]._multi = true;\n      }\n      function beginMultiClass(mode) {\n        if (!Array.isArray(mode.begin))\n          return;\n        if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n          error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n          throw MultiClassError;\n        }\n        if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n          error(\"beginScope must be object\");\n          throw MultiClassError;\n        }\n        remapScopeNames(mode, mode.begin, { key: \"beginScope\" });\n        mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n      }\n      function endMultiClass(mode) {\n        if (!Array.isArray(mode.end))\n          return;\n        if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n          error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n          throw MultiClassError;\n        }\n        if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n          error(\"endScope must be object\");\n          throw MultiClassError;\n        }\n        remapScopeNames(mode, mode.end, { key: \"endScope\" });\n        mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n      }\n      function scopeSugar(mode) {\n        if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n          mode.beginScope = mode.scope;\n          delete mode.scope;\n        }\n      }\n      function MultiClass(mode) {\n        scopeSugar(mode);\n        if (typeof mode.beginScope === \"string\") {\n          mode.beginScope = { _wrap: mode.beginScope };\n        }\n        if (typeof mode.endScope === \"string\") {\n          mode.endScope = { _wrap: mode.endScope };\n        }\n        beginMultiClass(mode);\n        endMultiClass(mode);\n      }\n      function compileLanguage(language) {\n        function langRe(value, global2) {\n          return new RegExp(\n            source(value),\n            \"m\" + (language.case_insensitive ? \"i\" : \"\") + (language.unicodeRegex ? \"u\" : \"\") + (global2 ? \"g\" : \"\")\n          );\n        }\n        class MultiRegex {\n          constructor() {\n            this.matchIndexes = {};\n            this.regexes = [];\n            this.matchAt = 1;\n            this.position = 0;\n          }\n          // @ts-ignore\n          addRule(re, opts) {\n            opts.position = this.position++;\n            this.matchIndexes[this.matchAt] = opts;\n            this.regexes.push([opts, re]);\n            this.matchAt += countMatchGroups(re) + 1;\n          }\n          compile() {\n            if (this.regexes.length === 0) {\n              this.exec = () => null;\n            }\n            const terminators = this.regexes.map((el) => el[1]);\n            this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: \"|\" }), true);\n            this.lastIndex = 0;\n          }\n          /** @param {string} s */\n          exec(s) {\n            this.matcherRe.lastIndex = this.lastIndex;\n            const match = this.matcherRe.exec(s);\n            if (!match) {\n              return null;\n            }\n            const i = match.findIndex((el, i2) => i2 > 0 && el !== void 0);\n            const matchData = this.matchIndexes[i];\n            match.splice(0, i);\n            return Object.assign(match, matchData);\n          }\n        }\n        class ResumableMultiRegex {\n          constructor() {\n            this.rules = [];\n            this.multiRegexes = [];\n            this.count = 0;\n            this.lastIndex = 0;\n            this.regexIndex = 0;\n          }\n          // @ts-ignore\n          getMatcher(index) {\n            if (this.multiRegexes[index])\n              return this.multiRegexes[index];\n            const matcher = new MultiRegex();\n            this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n            matcher.compile();\n            this.multiRegexes[index] = matcher;\n            return matcher;\n          }\n          resumingScanAtSamePosition() {\n            return this.regexIndex !== 0;\n          }\n          considerAll() {\n            this.regexIndex = 0;\n          }\n          // @ts-ignore\n          addRule(re, opts) {\n            this.rules.push([re, opts]);\n            if (opts.type === \"begin\")\n              this.count++;\n          }\n          /** @param {string} s */\n          exec(s) {\n            const m = this.getMatcher(this.regexIndex);\n            m.lastIndex = this.lastIndex;\n            let result = m.exec(s);\n            if (this.resumingScanAtSamePosition()) {\n              if (result && result.index === this.lastIndex)\n                ;\n              else {\n                const m2 = this.getMatcher(0);\n                m2.lastIndex = this.lastIndex + 1;\n                result = m2.exec(s);\n              }\n            }\n            if (result) {\n              this.regexIndex += result.position + 1;\n              if (this.regexIndex === this.count) {\n                this.considerAll();\n              }\n            }\n            return result;\n          }\n        }\n        function buildModeRegex(mode) {\n          const mm = new ResumableMultiRegex();\n          mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n          if (mode.terminatorEnd) {\n            mm.addRule(mode.terminatorEnd, { type: \"end\" });\n          }\n          if (mode.illegal) {\n            mm.addRule(mode.illegal, { type: \"illegal\" });\n          }\n          return mm;\n        }\n        function compileMode(mode, parent) {\n          const cmode = (\n            /** @type CompiledMode */\n            mode\n          );\n          if (mode.isCompiled)\n            return cmode;\n          [\n            scopeClassName,\n            // do this early so compiler extensions generally don't have to worry about\n            // the distinction between match/begin\n            compileMatch,\n            MultiClass,\n            beforeMatchExt\n          ].forEach((ext) => ext(mode, parent));\n          language.compilerExtensions.forEach((ext) => ext(mode, parent));\n          mode.__beforeBegin = null;\n          [\n            beginKeywords,\n            // do this later so compiler extensions that come earlier have access to the\n            // raw array if they wanted to perhaps manipulate it, etc.\n            compileIllegal,\n            // default to 1 relevance if not specified\n            compileRelevance\n          ].forEach((ext) => ext(mode, parent));\n          mode.isCompiled = true;\n          let keywordPattern = null;\n          if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n            mode.keywords = Object.assign({}, mode.keywords);\n            keywordPattern = mode.keywords.$pattern;\n            delete mode.keywords.$pattern;\n          }\n          keywordPattern = keywordPattern || /\\w+/;\n          if (mode.keywords) {\n            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n          }\n          cmode.keywordPatternRe = langRe(keywordPattern, true);\n          if (parent) {\n            if (!mode.begin)\n              mode.begin = /\\B|\\b/;\n            cmode.beginRe = langRe(cmode.begin);\n            if (!mode.end && !mode.endsWithParent)\n              mode.end = /\\B|\\b/;\n            if (mode.end)\n              cmode.endRe = langRe(cmode.end);\n            cmode.terminatorEnd = source(cmode.end) || \"\";\n            if (mode.endsWithParent && parent.terminatorEnd) {\n              cmode.terminatorEnd += (mode.end ? \"|\" : \"\") + parent.terminatorEnd;\n            }\n          }\n          if (mode.illegal)\n            cmode.illegalRe = langRe(\n              /** @type {RegExp | string} */\n              mode.illegal\n            );\n          if (!mode.contains)\n            mode.contains = [];\n          mode.contains = [].concat(...mode.contains.map(function(c) {\n            return expandOrCloneMode(c === \"self\" ? mode : c);\n          }));\n          mode.contains.forEach(function(c) {\n            compileMode(\n              /** @type Mode */\n              c,\n              cmode\n            );\n          });\n          if (mode.starts) {\n            compileMode(mode.starts, parent);\n          }\n          cmode.matcher = buildModeRegex(cmode);\n          return cmode;\n        }\n        if (!language.compilerExtensions)\n          language.compilerExtensions = [];\n        if (language.contains && language.contains.includes(\"self\")) {\n          throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n        }\n        language.classNameAliases = inherit$1(language.classNameAliases || {});\n        return compileMode(\n          /** @type Mode */\n          language\n        );\n      }\n      function dependencyOnParent(mode) {\n        if (!mode)\n          return false;\n        return mode.endsWithParent || dependencyOnParent(mode.starts);\n      }\n      function expandOrCloneMode(mode) {\n        if (mode.variants && !mode.cachedVariants) {\n          mode.cachedVariants = mode.variants.map(function(variant) {\n            return inherit$1(mode, { variants: null }, variant);\n          });\n        }\n        if (mode.cachedVariants) {\n          return mode.cachedVariants;\n        }\n        if (dependencyOnParent(mode)) {\n          return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n        }\n        if (Object.isFrozen(mode)) {\n          return inherit$1(mode);\n        }\n        return mode;\n      }\n      var version = \"11.7.0\";\n      var HTMLInjectionError = class extends Error {\n        constructor(reason, html) {\n          super(reason);\n          this.name = \"HTMLInjectionError\";\n          this.html = html;\n        }\n      };\n      var escape2 = escapeHTML;\n      var inherit = inherit$1;\n      var NO_MATCH = Symbol(\"nomatch\");\n      var MAX_KEYWORD_HITS = 7;\n      var HLJS = function(hljs) {\n        const languages = /* @__PURE__ */ Object.create(null);\n        const aliases = /* @__PURE__ */ Object.create(null);\n        const plugins = [];\n        let SAFE_MODE = true;\n        const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n        const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: \"Plain text\", contains: [] };\n        let options = {\n          ignoreUnescapedHTML: false,\n          throwUnescapedHTML: false,\n          noHighlightRe: /^(no-?highlight)$/i,\n          languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n          classPrefix: \"hljs-\",\n          cssSelector: \"pre code\",\n          languages: null,\n          // beta configuration options, subject to change, welcome to discuss\n          // https://github.com/highlightjs/highlight.js/issues/1086\n          __emitter: TokenTreeEmitter\n        };\n        function shouldNotHighlight(languageName) {\n          return options.noHighlightRe.test(languageName);\n        }\n        function blockLanguage(block) {\n          let classes = block.className + \" \";\n          classes += block.parentNode ? block.parentNode.className : \"\";\n          const match = options.languageDetectRe.exec(classes);\n          if (match) {\n            const language = getLanguage(match[1]);\n            if (!language) {\n              warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n              warn(\"Falling back to no-highlight mode for this block.\", block);\n            }\n            return language ? match[1] : \"no-highlight\";\n          }\n          return classes.split(/\\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n        }\n        function highlight2(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n          let code = \"\";\n          let languageName = \"\";\n          if (typeof optionsOrCode === \"object\") {\n            code = codeOrLanguageName;\n            ignoreIllegals = optionsOrCode.ignoreIllegals;\n            languageName = optionsOrCode.language;\n          } else {\n            deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n            deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n            languageName = codeOrLanguageName;\n            code = optionsOrCode;\n          }\n          if (ignoreIllegals === void 0) {\n            ignoreIllegals = true;\n          }\n          const context = {\n            code,\n            language: languageName\n          };\n          fire(\"before:highlight\", context);\n          const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);\n          result.code = context.code;\n          fire(\"after:highlight\", result);\n          return result;\n        }\n        function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n          const keywordHits = /* @__PURE__ */ Object.create(null);\n          function keywordData(mode, matchText) {\n            return mode.keywords[matchText];\n          }\n          function processKeywords() {\n            if (!top2.keywords) {\n              emitter.addText(modeBuffer);\n              return;\n            }\n            let lastIndex = 0;\n            top2.keywordPatternRe.lastIndex = 0;\n            let match = top2.keywordPatternRe.exec(modeBuffer);\n            let buf = \"\";\n            while (match) {\n              buf += modeBuffer.substring(lastIndex, match.index);\n              const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n              const data = keywordData(top2, word);\n              if (data) {\n                const [kind, keywordRelevance] = data;\n                emitter.addText(buf);\n                buf = \"\";\n                keywordHits[word] = (keywordHits[word] || 0) + 1;\n                if (keywordHits[word] <= MAX_KEYWORD_HITS)\n                  relevance += keywordRelevance;\n                if (kind.startsWith(\"_\")) {\n                  buf += match[0];\n                } else {\n                  const cssClass = language.classNameAliases[kind] || kind;\n                  emitter.addKeyword(match[0], cssClass);\n                }\n              } else {\n                buf += match[0];\n              }\n              lastIndex = top2.keywordPatternRe.lastIndex;\n              match = top2.keywordPatternRe.exec(modeBuffer);\n            }\n            buf += modeBuffer.substring(lastIndex);\n            emitter.addText(buf);\n          }\n          function processSubLanguage() {\n            if (modeBuffer === \"\")\n              return;\n            let result2 = null;\n            if (typeof top2.subLanguage === \"string\") {\n              if (!languages[top2.subLanguage]) {\n                emitter.addText(modeBuffer);\n                return;\n              }\n              result2 = _highlight(top2.subLanguage, modeBuffer, true, continuations[top2.subLanguage]);\n              continuations[top2.subLanguage] = /** @type {CompiledMode} */\n              result2._top;\n            } else {\n              result2 = highlightAuto(modeBuffer, top2.subLanguage.length ? top2.subLanguage : null);\n            }\n            if (top2.relevance > 0) {\n              relevance += result2.relevance;\n            }\n            emitter.addSublanguage(result2._emitter, result2.language);\n          }\n          function processBuffer() {\n            if (top2.subLanguage != null) {\n              processSubLanguage();\n            } else {\n              processKeywords();\n            }\n            modeBuffer = \"\";\n          }\n          function emitMultiClass(scope, match) {\n            let i = 1;\n            const max2 = match.length - 1;\n            while (i <= max2) {\n              if (!scope._emit[i]) {\n                i++;\n                continue;\n              }\n              const klass = language.classNameAliases[scope[i]] || scope[i];\n              const text = match[i];\n              if (klass) {\n                emitter.addKeyword(text, klass);\n              } else {\n                modeBuffer = text;\n                processKeywords();\n                modeBuffer = \"\";\n              }\n              i++;\n            }\n          }\n          function startNewMode(mode, match) {\n            if (mode.scope && typeof mode.scope === \"string\") {\n              emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n            }\n            if (mode.beginScope) {\n              if (mode.beginScope._wrap) {\n                emitter.addKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n                modeBuffer = \"\";\n              } else if (mode.beginScope._multi) {\n                emitMultiClass(mode.beginScope, match);\n                modeBuffer = \"\";\n              }\n            }\n            top2 = Object.create(mode, { parent: { value: top2 } });\n            return top2;\n          }\n          function endOfMode(mode, match, matchPlusRemainder) {\n            let matched = startsWith2(mode.endRe, matchPlusRemainder);\n            if (matched) {\n              if (mode[\"on:end\"]) {\n                const resp = new Response2(mode);\n                mode[\"on:end\"](match, resp);\n                if (resp.isMatchIgnored)\n                  matched = false;\n              }\n              if (matched) {\n                while (mode.endsParent && mode.parent) {\n                  mode = mode.parent;\n                }\n                return mode;\n              }\n            }\n            if (mode.endsWithParent) {\n              return endOfMode(mode.parent, match, matchPlusRemainder);\n            }\n          }\n          function doIgnore(lexeme) {\n            if (top2.matcher.regexIndex === 0) {\n              modeBuffer += lexeme[0];\n              return 1;\n            } else {\n              resumeScanAtSamePosition = true;\n              return 0;\n            }\n          }\n          function doBeginMatch(match) {\n            const lexeme = match[0];\n            const newMode = match.rule;\n            const resp = new Response2(newMode);\n            const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n            for (const cb of beforeCallbacks) {\n              if (!cb)\n                continue;\n              cb(match, resp);\n              if (resp.isMatchIgnored)\n                return doIgnore(lexeme);\n            }\n            if (newMode.skip) {\n              modeBuffer += lexeme;\n            } else {\n              if (newMode.excludeBegin) {\n                modeBuffer += lexeme;\n              }\n              processBuffer();\n              if (!newMode.returnBegin && !newMode.excludeBegin) {\n                modeBuffer = lexeme;\n              }\n            }\n            startNewMode(newMode, match);\n            return newMode.returnBegin ? 0 : lexeme.length;\n          }\n          function doEndMatch(match) {\n            const lexeme = match[0];\n            const matchPlusRemainder = codeToHighlight.substring(match.index);\n            const endMode = endOfMode(top2, match, matchPlusRemainder);\n            if (!endMode) {\n              return NO_MATCH;\n            }\n            const origin = top2;\n            if (top2.endScope && top2.endScope._wrap) {\n              processBuffer();\n              emitter.addKeyword(lexeme, top2.endScope._wrap);\n            } else if (top2.endScope && top2.endScope._multi) {\n              processBuffer();\n              emitMultiClass(top2.endScope, match);\n            } else if (origin.skip) {\n              modeBuffer += lexeme;\n            } else {\n              if (!(origin.returnEnd || origin.excludeEnd)) {\n                modeBuffer += lexeme;\n              }\n              processBuffer();\n              if (origin.excludeEnd) {\n                modeBuffer = lexeme;\n              }\n            }\n            do {\n              if (top2.scope) {\n                emitter.closeNode();\n              }\n              if (!top2.skip && !top2.subLanguage) {\n                relevance += top2.relevance;\n              }\n              top2 = top2.parent;\n            } while (top2 !== endMode.parent);\n            if (endMode.starts) {\n              startNewMode(endMode.starts, match);\n            }\n            return origin.returnEnd ? 0 : lexeme.length;\n          }\n          function processContinuations() {\n            const list = [];\n            for (let current = top2; current !== language; current = current.parent) {\n              if (current.scope) {\n                list.unshift(current.scope);\n              }\n            }\n            list.forEach((item) => emitter.openNode(item));\n          }\n          let lastMatch = {};\n          function processLexeme(textBeforeMatch, match) {\n            const lexeme = match && match[0];\n            modeBuffer += textBeforeMatch;\n            if (lexeme == null) {\n              processBuffer();\n              return 0;\n            }\n            if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n              modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n              if (!SAFE_MODE) {\n                const err = new Error(`0 width match regex (${languageName})`);\n                err.languageName = languageName;\n                err.badRule = lastMatch.rule;\n                throw err;\n              }\n              return 1;\n            }\n            lastMatch = match;\n            if (match.type === \"begin\") {\n              return doBeginMatch(match);\n            } else if (match.type === \"illegal\" && !ignoreIllegals) {\n              const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top2.scope || \"<unnamed>\") + '\"');\n              err.mode = top2;\n              throw err;\n            } else if (match.type === \"end\") {\n              const processed = doEndMatch(match);\n              if (processed !== NO_MATCH) {\n                return processed;\n              }\n            }\n            if (match.type === \"illegal\" && lexeme === \"\") {\n              return 1;\n            }\n            if (iterations > 1e5 && iterations > match.index * 3) {\n              const err = new Error(\"potential infinite loop, way more iterations than matches\");\n              throw err;\n            }\n            modeBuffer += lexeme;\n            return lexeme.length;\n          }\n          const language = getLanguage(languageName);\n          if (!language) {\n            error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n            throw new Error('Unknown language: \"' + languageName + '\"');\n          }\n          const md = compileLanguage(language);\n          let result = \"\";\n          let top2 = continuation || md;\n          const continuations = {};\n          const emitter = new options.__emitter(options);\n          processContinuations();\n          let modeBuffer = \"\";\n          let relevance = 0;\n          let index = 0;\n          let iterations = 0;\n          let resumeScanAtSamePosition = false;\n          try {\n            top2.matcher.considerAll();\n            for (; ; ) {\n              iterations++;\n              if (resumeScanAtSamePosition) {\n                resumeScanAtSamePosition = false;\n              } else {\n                top2.matcher.considerAll();\n              }\n              top2.matcher.lastIndex = index;\n              const match = top2.matcher.exec(codeToHighlight);\n              if (!match)\n                break;\n              const beforeMatch = codeToHighlight.substring(index, match.index);\n              const processedCount = processLexeme(beforeMatch, match);\n              index = match.index + processedCount;\n            }\n            processLexeme(codeToHighlight.substring(index));\n            emitter.closeAllNodes();\n            emitter.finalize();\n            result = emitter.toHTML();\n            return {\n              language: languageName,\n              value: result,\n              relevance,\n              illegal: false,\n              _emitter: emitter,\n              _top: top2\n            };\n          } catch (err) {\n            if (err.message && err.message.includes(\"Illegal\")) {\n              return {\n                language: languageName,\n                value: escape2(codeToHighlight),\n                illegal: true,\n                relevance: 0,\n                _illegalBy: {\n                  message: err.message,\n                  index,\n                  context: codeToHighlight.slice(index - 100, index + 100),\n                  mode: err.mode,\n                  resultSoFar: result\n                },\n                _emitter: emitter\n              };\n            } else if (SAFE_MODE) {\n              return {\n                language: languageName,\n                value: escape2(codeToHighlight),\n                illegal: false,\n                relevance: 0,\n                errorRaised: err,\n                _emitter: emitter,\n                _top: top2\n              };\n            } else {\n              throw err;\n            }\n          }\n        }\n        function justTextHighlightResult(code) {\n          const result = {\n            value: escape2(code),\n            illegal: false,\n            relevance: 0,\n            _top: PLAINTEXT_LANGUAGE,\n            _emitter: new options.__emitter(options)\n          };\n          result._emitter.addText(code);\n          return result;\n        }\n        function highlightAuto(code, languageSubset) {\n          languageSubset = languageSubset || options.languages || Object.keys(languages);\n          const plaintext = justTextHighlightResult(code);\n          const results = languageSubset.filter(getLanguage).filter(autoDetection).map(\n            (name2) => _highlight(name2, code, false)\n          );\n          results.unshift(plaintext);\n          const sorted = results.sort((a, b) => {\n            if (a.relevance !== b.relevance)\n              return b.relevance - a.relevance;\n            if (a.language && b.language) {\n              if (getLanguage(a.language).supersetOf === b.language) {\n                return 1;\n              } else if (getLanguage(b.language).supersetOf === a.language) {\n                return -1;\n              }\n            }\n            return 0;\n          });\n          const [best, secondBest] = sorted;\n          const result = best;\n          result.secondBest = secondBest;\n          return result;\n        }\n        function updateClassName(element, currentLang, resultLang) {\n          const language = currentLang && aliases[currentLang] || resultLang;\n          element.classList.add(\"hljs\");\n          element.classList.add(`language-${language}`);\n        }\n        function highlightElement(element) {\n          let node = null;\n          const language = blockLanguage(element);\n          if (shouldNotHighlight(language))\n            return;\n          fire(\n            \"before:highlightElement\",\n            { el: element, language }\n          );\n          if (element.children.length > 0) {\n            if (!options.ignoreUnescapedHTML) {\n              console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n              console.warn(\"https://github.com/highlightjs/highlight.js/wiki/security\");\n              console.warn(\"The element with unescaped HTML:\");\n              console.warn(element);\n            }\n            if (options.throwUnescapedHTML) {\n              const err = new HTMLInjectionError(\n                \"One of your code blocks includes unescaped HTML.\",\n                element.innerHTML\n              );\n              throw err;\n            }\n          }\n          node = element;\n          const text = node.textContent;\n          const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n          element.innerHTML = result.value;\n          updateClassName(element, language, result.language);\n          element.result = {\n            language: result.language,\n            // TODO: remove with version 11.0\n            re: result.relevance,\n            relevance: result.relevance\n          };\n          if (result.secondBest) {\n            element.secondBest = {\n              language: result.secondBest.language,\n              relevance: result.secondBest.relevance\n            };\n          }\n          fire(\"after:highlightElement\", { el: element, result, text });\n        }\n        function configure(userOptions) {\n          options = inherit(options, userOptions);\n        }\n        const initHighlighting = () => {\n          highlightAll();\n          deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n        };\n        function initHighlightingOnLoad() {\n          highlightAll();\n          deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n        }\n        let wantsHighlight = false;\n        function highlightAll() {\n          if (document.readyState === \"loading\") {\n            wantsHighlight = true;\n            return;\n          }\n          const blocks = document.querySelectorAll(options.cssSelector);\n          blocks.forEach(highlightElement);\n        }\n        function boot() {\n          if (wantsHighlight)\n            highlightAll();\n        }\n        if (typeof window !== \"undefined\" && window.addEventListener) {\n          window.addEventListener(\"DOMContentLoaded\", boot, false);\n        }\n        function registerLanguage(languageName, languageDefinition) {\n          let lang = null;\n          try {\n            lang = languageDefinition(hljs);\n          } catch (error$1) {\n            error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n            if (!SAFE_MODE) {\n              throw error$1;\n            } else {\n              error(error$1);\n            }\n            lang = PLAINTEXT_LANGUAGE;\n          }\n          if (!lang.name)\n            lang.name = languageName;\n          languages[languageName] = lang;\n          lang.rawDefinition = languageDefinition.bind(null, hljs);\n          if (lang.aliases) {\n            registerAliases(lang.aliases, { languageName });\n          }\n        }\n        function unregisterLanguage(languageName) {\n          delete languages[languageName];\n          for (const alias of Object.keys(aliases)) {\n            if (aliases[alias] === languageName) {\n              delete aliases[alias];\n            }\n          }\n        }\n        function listLanguages() {\n          return Object.keys(languages);\n        }\n        function getLanguage(name2) {\n          name2 = (name2 || \"\").toLowerCase();\n          return languages[name2] || languages[aliases[name2]];\n        }\n        function registerAliases(aliasList, { languageName }) {\n          if (typeof aliasList === \"string\") {\n            aliasList = [aliasList];\n          }\n          aliasList.forEach((alias) => {\n            aliases[alias.toLowerCase()] = languageName;\n          });\n        }\n        function autoDetection(name2) {\n          const lang = getLanguage(name2);\n          return lang && !lang.disableAutodetect;\n        }\n        function upgradePluginAPI(plugin) {\n          if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n            plugin[\"before:highlightElement\"] = (data) => {\n              plugin[\"before:highlightBlock\"](\n                Object.assign({ block: data.el }, data)\n              );\n            };\n          }\n          if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n            plugin[\"after:highlightElement\"] = (data) => {\n              plugin[\"after:highlightBlock\"](\n                Object.assign({ block: data.el }, data)\n              );\n            };\n          }\n        }\n        function addPlugin(plugin) {\n          upgradePluginAPI(plugin);\n          plugins.push(plugin);\n        }\n        function fire(event, args) {\n          const cb = event;\n          plugins.forEach(function(plugin) {\n            if (plugin[cb]) {\n              plugin[cb](args);\n            }\n          });\n        }\n        function deprecateHighlightBlock(el) {\n          deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n          deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n          return highlightElement(el);\n        }\n        Object.assign(hljs, {\n          highlight: highlight2,\n          highlightAuto,\n          highlightAll,\n          highlightElement,\n          // TODO: Remove with v12 API\n          highlightBlock: deprecateHighlightBlock,\n          configure,\n          initHighlighting,\n          initHighlightingOnLoad,\n          registerLanguage,\n          unregisterLanguage,\n          listLanguages,\n          getLanguage,\n          registerAliases,\n          autoDetection,\n          inherit,\n          addPlugin\n        });\n        hljs.debugMode = function() {\n          SAFE_MODE = false;\n        };\n        hljs.safeMode = function() {\n          SAFE_MODE = true;\n        };\n        hljs.versionString = version;\n        hljs.regex = {\n          concat,\n          lookahead,\n          either,\n          optional,\n          anyNumberOfTimes\n        };\n        for (const key in MODES) {\n          if (typeof MODES[key] === \"object\") {\n            deepFreezeEs6.exports(MODES[key]);\n          }\n        }\n        Object.assign(hljs, MODES);\n        return hljs;\n      };\n      var highlight = HLJS({});\n      module2.exports = highlight;\n      highlight.HighlightJS = highlight;\n      highlight.default = highlight;\n    }\n  });\n\n  // node_modules/@fnando/sparkline/dist/sparkline.commonjs2.js\n  var require_sparkline_commonjs2 = __commonJS({\n    \"node_modules/@fnando/sparkline/dist/sparkline.commonjs2.js\"(exports, module2) {\n      module2.exports = function(t) {\n        var e2 = {};\n        function r2(n) {\n          if (e2[n])\n            return e2[n].exports;\n          var o = e2[n] = { i: n, l: false, exports: {} };\n          return t[n].call(o.exports, o, o.exports, r2), o.l = true, o.exports;\n        }\n        return r2.m = t, r2.c = e2, r2.d = function(t2, e3, n) {\n          r2.o(t2, e3) || Object.defineProperty(t2, e3, { enumerable: true, get: n });\n        }, r2.r = function(t2) {\n          \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(t2, \"__esModule\", { value: true });\n        }, r2.t = function(t2, e3) {\n          if (1 & e3 && (t2 = r2(t2)), 8 & e3)\n            return t2;\n          if (4 & e3 && \"object\" == typeof t2 && t2 && t2.__esModule)\n            return t2;\n          var n = /* @__PURE__ */ Object.create(null);\n          if (r2.r(n), Object.defineProperty(n, \"default\", { enumerable: true, value: t2 }), 2 & e3 && \"string\" != typeof t2)\n            for (var o in t2)\n              r2.d(n, o, function(e4) {\n                return t2[e4];\n              }.bind(null, o));\n          return n;\n        }, r2.n = function(t2) {\n          var e3 = t2 && t2.__esModule ? function() {\n            return t2.default;\n          } : function() {\n            return t2;\n          };\n          return r2.d(e3, \"a\", e3), e3;\n        }, r2.o = function(t2, e3) {\n          return Object.prototype.hasOwnProperty.call(t2, e3);\n        }, r2.p = \"\", r2(r2.s = 1);\n      }([function(t, e2, r2) {\n        var n = r2(2), o = r2(3), i = r2(4);\n        t.exports = function(t2) {\n          return n(t2) || o(t2) || i();\n        };\n      }, function(t, e2, r2) {\n        \"use strict\";\n        r2.r(e2), r2.d(e2, \"sparkline\", function() {\n          return c;\n        });\n        var n = r2(0), o = r2.n(n);\n        function i(t2, e3, r3, n2) {\n          return parseFloat((e3 - n2 * e3 / t2 + r3).toFixed(2));\n        }\n        function a(t2) {\n          return t2.value;\n        }\n        function u(t2, e3) {\n          var r3 = document.createElementNS(\"http://www.w3.org/2000/svg\", t2);\n          for (var n2 in e3)\n            r3.setAttribute(n2, e3[n2]);\n          return r3;\n        }\n        function c(t2, e3, r3) {\n          var n2;\n          if (n2 = t2, o()(n2.querySelectorAll(\"*\")).forEach(function(t3) {\n            return n2.removeChild(t3);\n          }), !(e3.length <= 1)) {\n            r3 = r3 || {}, \"number\" == typeof e3[0] && (e3 = e3.map(function(t3) {\n              return { value: t3 };\n            }));\n            var c2 = r3.onmousemove, l = r3.onmouseout, s = \"interactive\" in r3 ? r3.interactive : !!c2, f = r3.spotRadius || 2, p = 2 * f, d = r3.cursorWidth || 2, v = parseFloat(t2.attributes[\"stroke-width\"].value), b = r3.fetch || a, h = e3.map(function(t3) {\n              return b(t3);\n            }), y = parseFloat(t2.attributes.width.value) - 2 * p, x = parseFloat(t2.attributes.height.value), m = x - 2 * v - p, g = Math.max.apply(Math, o()(h)), A = -1e3, w = h.length - 1, j = y / w, O = [], k = i(g, m, v + f, h[0]), S = \"M\".concat(p, \" \").concat(k);\n            h.forEach(function(t3, r4) {\n              var n3 = r4 * j + p, o2 = i(g, m, v + f, t3);\n              O.push(Object.assign({}, e3[r4], { index: r4, x: n3, y: o2 })), S += \" L \".concat(n3, \" \").concat(o2);\n            });\n            var M = u(\"path\", { class: \"sparkline--line\", d: S, fill: \"none\" }), C = u(\"path\", { class: \"sparkline--fill\", d: \"\".concat(S, \" V \").concat(x, \" L \").concat(p, \" \").concat(x, \" Z\"), stroke: \"none\" });\n            if (t2.appendChild(C), t2.appendChild(M), s) {\n              var E = u(\"line\", { class: \"sparkline--cursor\", x1: A, x2: A, y1: 0, y2: x, \"stroke-width\": d }), _ = u(\"circle\", { class: \"sparkline--spot\", cx: A, cy: A, r: f });\n              t2.appendChild(E), t2.appendChild(_);\n              var F = u(\"rect\", { width: t2.attributes.width.value, height: t2.attributes.height.value, style: \"fill: transparent; stroke: transparent\", class: \"sparkline--interaction-layer\" });\n              t2.appendChild(F), F.addEventListener(\"mouseout\", function(t3) {\n                E.setAttribute(\"x1\", A), E.setAttribute(\"x2\", A), _.setAttribute(\"cx\", A), l && l(t3);\n              }), F.addEventListener(\"mousemove\", function(t3) {\n                var e4 = t3.offsetX, r4 = O.find(function(t4) {\n                  return t4.x >= e4;\n                });\n                r4 || (r4 = O[w]);\n                var n3, o2 = O[O.indexOf(r4) - 1], i2 = (n3 = o2 ? o2.x + (r4.x - o2.x) / 2 <= e4 ? r4 : o2 : r4).x, a2 = n3.y;\n                _.setAttribute(\"cx\", i2), _.setAttribute(\"cy\", a2), E.setAttribute(\"x1\", i2), E.setAttribute(\"x2\", i2), c2 && c2(t3, n3);\n              });\n            }\n          }\n        }\n        e2.default = c;\n      }, function(t, e2) {\n        t.exports = function(t2) {\n          if (Array.isArray(t2)) {\n            for (var e3 = 0, r2 = new Array(t2.length); e3 < t2.length; e3++)\n              r2[e3] = t2[e3];\n            return r2;\n          }\n        };\n      }, function(t, e2) {\n        t.exports = function(t2) {\n          if (Symbol.iterator in Object(t2) || \"[object Arguments]\" === Object.prototype.toString.call(t2))\n            return Array.from(t2);\n        };\n      }, function(t, e2) {\n        t.exports = function() {\n          throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n        };\n      }]);\n    }\n  });\n\n  // node_modules/htmx.org/dist/htmx.esm.js\n  var htmx2 = function() {\n    \"use strict\";\n    const htmx = {\n      // Tsc madness here, assigning the functions directly results in an invalid TypeScript output, but reassigning is fine\n      /* Event processing */\n      /** @type {typeof onLoadHelper} */\n      onLoad: null,\n      /** @type {typeof processNode} */\n      process: null,\n      /** @type {typeof addEventListenerImpl} */\n      on: null,\n      /** @type {typeof removeEventListenerImpl} */\n      off: null,\n      /** @type {typeof triggerEvent} */\n      trigger: null,\n      /** @type {typeof ajaxHelper} */\n      ajax: null,\n      /* DOM querying helpers */\n      /** @type {typeof find} */\n      find: null,\n      /** @type {typeof findAll} */\n      findAll: null,\n      /** @type {typeof closest} */\n      closest: null,\n      /**\n       * Returns the input values that would resolve for a given element via the htmx value resolution mechanism\n       *\n       * @see https://htmx.org/api/#values\n       *\n       * @param {Element} elt the element to resolve values on\n       * @param {HttpVerb} type the request type (e.g. **get** or **post**) non-GET's will include the enclosing form of the element. Defaults to **post**\n       * @returns {Object}\n       */\n      values: function(elt, type) {\n        const inputValues = getInputValues(elt, type || \"post\");\n        return inputValues.values;\n      },\n      /* DOM manipulation helpers */\n      /** @type {typeof removeElement} */\n      remove: null,\n      /** @type {typeof addClassToElement} */\n      addClass: null,\n      /** @type {typeof removeClassFromElement} */\n      removeClass: null,\n      /** @type {typeof toggleClassOnElement} */\n      toggleClass: null,\n      /** @type {typeof takeClassForElement} */\n      takeClass: null,\n      /** @type {typeof swap} */\n      swap: null,\n      /* Extension entrypoints */\n      /** @type {typeof defineExtension} */\n      defineExtension: null,\n      /** @type {typeof removeExtension} */\n      removeExtension: null,\n      /* Debugging */\n      /** @type {typeof logAll} */\n      logAll: null,\n      /** @type {typeof logNone} */\n      logNone: null,\n      /* Debugging */\n      /**\n       * The logger htmx uses to log with\n       *\n       * @see https://htmx.org/api/#logger\n       */\n      logger: null,\n      /**\n       * A property holding the configuration htmx uses at runtime.\n       *\n       * Note that using a [meta tag](https://htmx.org/docs/#config) is the preferred mechanism for setting these properties.\n       *\n       * @see https://htmx.org/api/#config\n       */\n      config: {\n        /**\n         * Whether to use history.\n         * @type boolean\n         * @default true\n         */\n        historyEnabled: true,\n        /**\n         * The number of pages to keep in **localStorage** for history support.\n         * @type number\n         * @default 10\n         */\n        historyCacheSize: 10,\n        /**\n         * @type boolean\n         * @default false\n         */\n        refreshOnHistoryMiss: false,\n        /**\n         * The default swap style to use if **[hx-swap](https://htmx.org/attributes/hx-swap)** is omitted.\n         * @type HtmxSwapStyle\n         * @default 'innerHTML'\n         */\n        defaultSwapStyle: \"innerHTML\",\n        /**\n         * The default delay between receiving a response from the server and doing the swap.\n         * @type number\n         * @default 0\n         */\n        defaultSwapDelay: 0,\n        /**\n         * The default delay between completing the content swap and settling attributes.\n         * @type number\n         * @default 20\n         */\n        defaultSettleDelay: 20,\n        /**\n         * If true, htmx will inject a small amount of CSS into the page to make indicators invisible unless the **htmx-indicator** class is present.\n         * @type boolean\n         * @default true\n         */\n        includeIndicatorStyles: true,\n        /**\n         * The class to place on indicators when a request is in flight.\n         * @type string\n         * @default 'htmx-indicator'\n         */\n        indicatorClass: \"htmx-indicator\",\n        /**\n         * The class to place on triggering elements when a request is in flight.\n         * @type string\n         * @default 'htmx-request'\n         */\n        requestClass: \"htmx-request\",\n        /**\n         * The class to temporarily place on elements that htmx has added to the DOM.\n         * @type string\n         * @default 'htmx-added'\n         */\n        addedClass: \"htmx-added\",\n        /**\n         * The class to place on target elements when htmx is in the settling phase.\n         * @type string\n         * @default 'htmx-settling'\n         */\n        settlingClass: \"htmx-settling\",\n        /**\n         * The class to place on target elements when htmx is in the swapping phase.\n         * @type string\n         * @default 'htmx-swapping'\n         */\n        swappingClass: \"htmx-swapping\",\n        /**\n         * Allows the use of eval-like functionality in htmx, to enable **hx-vars**, trigger conditions & script tag evaluation. Can be set to **false** for CSP compatibility.\n         * @type boolean\n         * @default true\n         */\n        allowEval: true,\n        /**\n         * If set to false, disables the interpretation of script tags.\n         * @type boolean\n         * @default true\n         */\n        allowScriptTags: true,\n        /**\n         * If set, the nonce will be added to inline scripts.\n         * @type string\n         * @default ''\n         */\n        inlineScriptNonce: \"\",\n        /**\n         * If set, the nonce will be added to inline styles.\n         * @type string\n         * @default ''\n         */\n        inlineStyleNonce: \"\",\n        /**\n         * The attributes to settle during the settling phase.\n         * @type string[]\n         * @default ['class', 'style', 'width', 'height']\n         */\n        attributesToSettle: [\"class\", \"style\", \"width\", \"height\"],\n        /**\n         * Allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates.\n         * @type boolean\n         * @default false\n         */\n        withCredentials: false,\n        /**\n         * @type number\n         * @default 0\n         */\n        timeout: 0,\n        /**\n         * The default implementation of **getWebSocketReconnectDelay** for reconnecting after unexpected connection loss by the event code **Abnormal Closure**, **Service Restart** or **Try Again Later**.\n         * @type {'full-jitter' | ((retryCount:number) => number)}\n         * @default \"full-jitter\"\n         */\n        wsReconnectDelay: \"full-jitter\",\n        /**\n         * The type of binary data being received over the WebSocket connection\n         * @type BinaryType\n         * @default 'blob'\n         */\n        wsBinaryType: \"blob\",\n        /**\n         * @type string\n         * @default '[hx-disable], [data-hx-disable]'\n         */\n        disableSelector: \"[hx-disable], [data-hx-disable]\",\n        /**\n         * @type {'auto' | 'instant' | 'smooth'}\n         * @default 'smooth'\n         */\n        scrollBehavior: \"instant\",\n        /**\n         * If the focused element should be scrolled into view.\n         * @type boolean\n         * @default false\n         */\n        defaultFocusScroll: false,\n        /**\n         * If set to true htmx will include a cache-busting parameter in GET requests to avoid caching partial responses by the browser\n         * @type boolean\n         * @default false\n         */\n        getCacheBusterParam: false,\n        /**\n         * If set to true, htmx will use the View Transition API when swapping in new content.\n         * @type boolean\n         * @default false\n         */\n        globalViewTransitions: false,\n        /**\n         * htmx will format requests with these methods by encoding their parameters in the URL, not the request body\n         * @type {(HttpVerb)[]}\n         * @default ['get', 'delete']\n         */\n        methodsThatUseUrlParams: [\"get\", \"delete\"],\n        /**\n         * If set to true, disables htmx-based requests to non-origin hosts.\n         * @type boolean\n         * @default false\n         */\n        selfRequestsOnly: true,\n        /**\n         * If set to true htmx will not update the title of the document when a title tag is found in new content\n         * @type boolean\n         * @default false\n         */\n        ignoreTitle: false,\n        /**\n         * Whether the target of a boosted element is scrolled into the viewport.\n         * @type boolean\n         * @default true\n         */\n        scrollIntoViewOnBoost: true,\n        /**\n         * The cache to store evaluated trigger specifications into.\n         * You may define a simple object to use a never-clearing cache, or implement your own system using a [proxy object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n         * @type {Object|null}\n         * @default null\n         */\n        triggerSpecsCache: null,\n        /** @type boolean */\n        disableInheritance: false,\n        /** @type HtmxResponseHandlingConfig[] */\n        responseHandling: [\n          { code: \"204\", swap: false },\n          { code: \"[23]..\", swap: true },\n          { code: \"[45]..\", swap: false, error: true }\n        ],\n        /**\n         * Whether to process OOB swaps on elements that are nested within the main response element.\n         * @type boolean\n         * @default true\n         */\n        allowNestedOobSwaps: true\n      },\n      /** @type {typeof parseInterval} */\n      parseInterval: null,\n      /** @type {typeof internalEval} */\n      _: null,\n      version: \"2.0.0\"\n    };\n    htmx.onLoad = onLoadHelper;\n    htmx.process = processNode;\n    htmx.on = addEventListenerImpl;\n    htmx.off = removeEventListenerImpl;\n    htmx.trigger = triggerEvent;\n    htmx.ajax = ajaxHelper;\n    htmx.find = find;\n    htmx.findAll = findAll;\n    htmx.closest = closest;\n    htmx.remove = removeElement;\n    htmx.addClass = addClassToElement;\n    htmx.removeClass = removeClassFromElement;\n    htmx.toggleClass = toggleClassOnElement;\n    htmx.takeClass = takeClassForElement;\n    htmx.swap = swap;\n    htmx.defineExtension = defineExtension;\n    htmx.removeExtension = removeExtension;\n    htmx.logAll = logAll;\n    htmx.logNone = logNone;\n    htmx.parseInterval = parseInterval;\n    htmx._ = internalEval;\n    const internalAPI = {\n      addTriggerHandler,\n      bodyContains,\n      canAccessLocalStorage,\n      findThisElement,\n      filterValues,\n      swap,\n      hasAttribute,\n      getAttributeValue,\n      getClosestAttributeValue,\n      getClosestMatch,\n      getExpressionVars,\n      getHeaders,\n      getInputValues,\n      getInternalData,\n      getSwapSpecification,\n      getTriggerSpecs,\n      getTarget,\n      makeFragment,\n      mergeObjects,\n      makeSettleInfo,\n      oobSwap,\n      querySelectorExt,\n      settleImmediately,\n      shouldCancel,\n      triggerEvent,\n      triggerErrorEvent,\n      withExtensions\n    };\n    const VERBS = [\"get\", \"post\", \"put\", \"delete\", \"patch\"];\n    const VERB_SELECTOR = VERBS.map(function(verb) {\n      return \"[hx-\" + verb + \"], [data-hx-\" + verb + \"]\";\n    }).join(\", \");\n    const HEAD_TAG_REGEX = makeTagRegEx(\"head\");\n    function makeTagRegEx(tag, global2 = false) {\n      return new RegExp(\n        `<${tag}(\\\\s[^>]*>|>)([\\\\s\\\\S]*?)<\\\\/${tag}>`,\n        global2 ? \"gim\" : \"im\"\n      );\n    }\n    function parseInterval(str2) {\n      if (str2 == void 0) {\n        return void 0;\n      }\n      let interval = NaN;\n      if (str2.slice(-2) == \"ms\") {\n        interval = parseFloat(str2.slice(0, -2));\n      } else if (str2.slice(-1) == \"s\") {\n        interval = parseFloat(str2.slice(0, -1)) * 1e3;\n      } else if (str2.slice(-1) == \"m\") {\n        interval = parseFloat(str2.slice(0, -1)) * 1e3 * 60;\n      } else {\n        interval = parseFloat(str2);\n      }\n      return isNaN(interval) ? void 0 : interval;\n    }\n    function getRawAttribute(elt, name2) {\n      return elt instanceof Element && elt.getAttribute(name2);\n    }\n    function hasAttribute(elt, qualifiedName) {\n      return !!elt.hasAttribute && (elt.hasAttribute(qualifiedName) || elt.hasAttribute(\"data-\" + qualifiedName));\n    }\n    function getAttributeValue(elt, qualifiedName) {\n      return getRawAttribute(elt, qualifiedName) || getRawAttribute(elt, \"data-\" + qualifiedName);\n    }\n    function parentElt(elt) {\n      const parent = elt.parentElement;\n      if (!parent && elt.parentNode instanceof ShadowRoot)\n        return elt.parentNode;\n      return parent;\n    }\n    function getDocument() {\n      return document;\n    }\n    function getRootNode(elt, global2) {\n      return elt.getRootNode ? elt.getRootNode({ composed: global2 }) : getDocument();\n    }\n    function getClosestMatch(elt, condition) {\n      while (elt && !condition(elt)) {\n        elt = parentElt(elt);\n      }\n      return elt || null;\n    }\n    function getAttributeValueWithDisinheritance(initialElement, ancestor, attributeName) {\n      const attributeValue = getAttributeValue(ancestor, attributeName);\n      const disinherit = getAttributeValue(ancestor, \"hx-disinherit\");\n      var inherit = getAttributeValue(ancestor, \"hx-inherit\");\n      if (initialElement !== ancestor) {\n        if (htmx.config.disableInheritance) {\n          if (inherit && (inherit === \"*\" || inherit.split(\" \").indexOf(attributeName) >= 0)) {\n            return attributeValue;\n          } else {\n            return null;\n          }\n        }\n        if (disinherit && (disinherit === \"*\" || disinherit.split(\" \").indexOf(attributeName) >= 0)) {\n          return \"unset\";\n        }\n      }\n      return attributeValue;\n    }\n    function getClosestAttributeValue(elt, attributeName) {\n      let closestAttr = null;\n      getClosestMatch(elt, function(e2) {\n        return !!(closestAttr = getAttributeValueWithDisinheritance(elt, asElement(e2), attributeName));\n      });\n      if (closestAttr !== \"unset\") {\n        return closestAttr;\n      }\n    }\n    function matches(elt, selector) {\n      const matchesFunction = elt instanceof Element && (elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector);\n      return !!matchesFunction && matchesFunction.call(elt, selector);\n    }\n    function getStartTag(str2) {\n      const tagMatcher = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n      const match = tagMatcher.exec(str2);\n      if (match) {\n        return match[1].toLowerCase();\n      } else {\n        return \"\";\n      }\n    }\n    function parseHTML(resp) {\n      const parser = new DOMParser();\n      return parser.parseFromString(resp, \"text/html\");\n    }\n    function takeChildrenFor(fragment, elt) {\n      while (elt.childNodes.length > 0) {\n        fragment.append(elt.childNodes[0]);\n      }\n    }\n    function duplicateScript(script) {\n      const newScript = getDocument().createElement(\"script\");\n      forEach(script.attributes, function(attr) {\n        newScript.setAttribute(attr.name, attr.value);\n      });\n      newScript.textContent = script.textContent;\n      newScript.async = false;\n      if (htmx.config.inlineScriptNonce) {\n        newScript.nonce = htmx.config.inlineScriptNonce;\n      }\n      return newScript;\n    }\n    function isJavaScriptScriptNode(script) {\n      return script.matches(\"script\") && (script.type === \"text/javascript\" || script.type === \"module\" || script.type === \"\");\n    }\n    function normalizeScriptTags(fragment) {\n      Array.from(fragment.querySelectorAll(\"script\")).forEach(\n        /** @param {HTMLScriptElement} script */\n        (script) => {\n          if (isJavaScriptScriptNode(script)) {\n            const newScript = duplicateScript(script);\n            const parent = script.parentNode;\n            try {\n              parent.insertBefore(newScript, script);\n            } catch (e2) {\n              logError(e2);\n            } finally {\n              script.remove();\n            }\n          }\n        }\n      );\n    }\n    function makeFragment(response) {\n      const responseWithNoHead = response.replace(HEAD_TAG_REGEX, \"\");\n      const startTag = getStartTag(responseWithNoHead);\n      let fragment;\n      if (startTag === \"html\") {\n        fragment = /** @type DocumentFragmentWithTitle */\n        new DocumentFragment();\n        const doc = parseHTML(response);\n        takeChildrenFor(fragment, doc.body);\n        fragment.title = doc.title;\n      } else if (startTag === \"body\") {\n        fragment = /** @type DocumentFragmentWithTitle */\n        new DocumentFragment();\n        const doc = parseHTML(responseWithNoHead);\n        takeChildrenFor(fragment, doc.body);\n        fragment.title = doc.title;\n      } else {\n        const doc = parseHTML('<body><template class=\"internal-htmx-wrapper\">' + responseWithNoHead + \"</template></body>\");\n        fragment = /** @type DocumentFragmentWithTitle */\n        doc.querySelector(\"template\").content;\n        fragment.title = doc.title;\n        var titleElement = fragment.querySelector(\"title\");\n        if (titleElement && titleElement.parentNode === fragment) {\n          titleElement.remove();\n          fragment.title = titleElement.innerText;\n        }\n      }\n      if (fragment) {\n        if (htmx.config.allowScriptTags) {\n          normalizeScriptTags(fragment);\n        } else {\n          fragment.querySelectorAll(\"script\").forEach((script) => script.remove());\n        }\n      }\n      return fragment;\n    }\n    function maybeCall(func) {\n      if (func) {\n        func();\n      }\n    }\n    function isType(o, type) {\n      return Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n    }\n    function isFunction(o) {\n      return typeof o === \"function\";\n    }\n    function isRawObject(o) {\n      return isType(o, \"Object\");\n    }\n    function getInternalData(elt) {\n      const dataProp = \"htmx-internal-data\";\n      let data = elt[dataProp];\n      if (!data) {\n        data = elt[dataProp] = {};\n      }\n      return data;\n    }\n    function toArray(arr) {\n      const returnArr = [];\n      if (arr) {\n        for (let i = 0; i < arr.length; i++) {\n          returnArr.push(arr[i]);\n        }\n      }\n      return returnArr;\n    }\n    function forEach(arr, func) {\n      if (arr) {\n        for (let i = 0; i < arr.length; i++) {\n          func(arr[i]);\n        }\n      }\n    }\n    function isScrolledIntoView(el) {\n      const rect = el.getBoundingClientRect();\n      const elemTop = rect.top;\n      const elemBottom = rect.bottom;\n      return elemTop < window.innerHeight && elemBottom >= 0;\n    }\n    function bodyContains(elt) {\n      const rootNode = elt.getRootNode && elt.getRootNode();\n      if (rootNode && rootNode instanceof window.ShadowRoot) {\n        return getDocument().body.contains(rootNode.host);\n      } else {\n        return getDocument().body.contains(elt);\n      }\n    }\n    function splitOnWhitespace(trigger) {\n      return trigger.trim().split(/\\s+/);\n    }\n    function mergeObjects(obj1, obj2) {\n      for (const key in obj2) {\n        if (obj2.hasOwnProperty(key)) {\n          obj1[key] = obj2[key];\n        }\n      }\n      return obj1;\n    }\n    function parseJSON(jString) {\n      try {\n        return JSON.parse(jString);\n      } catch (error) {\n        logError(error);\n        return null;\n      }\n    }\n    function canAccessLocalStorage() {\n      const test = \"htmx:localStorageTest\";\n      try {\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n      } catch (e2) {\n        return false;\n      }\n    }\n    function normalizePath(path) {\n      try {\n        const url = new URL(path);\n        if (url) {\n          path = url.pathname + url.search;\n        }\n        if (!/^\\/$/.test(path)) {\n          path = path.replace(/\\/+$/, \"\");\n        }\n        return path;\n      } catch (e2) {\n        return path;\n      }\n    }\n    function internalEval(str) {\n      return maybeEval(getDocument().body, function() {\n        return eval(str);\n      });\n    }\n    function onLoadHelper(callback) {\n      const value = htmx.on(\n        \"htmx:load\",\n        /** @param {CustomEvent} evt */\n        function(evt) {\n          callback(evt.detail.elt);\n        }\n      );\n      return value;\n    }\n    function logAll() {\n      htmx.logger = function(elt, event, data) {\n        if (console) {\n          console.log(event, elt, data);\n        }\n      };\n    }\n    function logNone() {\n      htmx.logger = null;\n    }\n    function find(eltOrSelector, selector) {\n      if (typeof eltOrSelector !== \"string\") {\n        return eltOrSelector.querySelector(selector);\n      } else {\n        return find(getDocument(), eltOrSelector);\n      }\n    }\n    function findAll(eltOrSelector, selector) {\n      if (typeof eltOrSelector !== \"string\") {\n        return eltOrSelector.querySelectorAll(selector);\n      } else {\n        return findAll(getDocument(), eltOrSelector);\n      }\n    }\n    function getWindow() {\n      return window;\n    }\n    function removeElement(elt, delay) {\n      elt = resolveTarget(elt);\n      if (delay) {\n        getWindow().setTimeout(function() {\n          removeElement(elt);\n          elt = null;\n        }, delay);\n      } else {\n        parentElt(elt).removeChild(elt);\n      }\n    }\n    function asElement(elt) {\n      return elt instanceof Element ? elt : null;\n    }\n    function asHtmlElement(elt) {\n      return elt instanceof HTMLElement ? elt : null;\n    }\n    function asString(value) {\n      return typeof value === \"string\" ? value : null;\n    }\n    function asParentNode(elt) {\n      return elt instanceof Element || elt instanceof Document || elt instanceof DocumentFragment ? elt : null;\n    }\n    function addClassToElement(elt, clazz, delay) {\n      elt = asElement(resolveTarget(elt));\n      if (!elt) {\n        return;\n      }\n      if (delay) {\n        getWindow().setTimeout(function() {\n          addClassToElement(elt, clazz);\n          elt = null;\n        }, delay);\n      } else {\n        elt.classList && elt.classList.add(clazz);\n      }\n    }\n    function removeClassFromElement(node, clazz, delay) {\n      let elt = asElement(resolveTarget(node));\n      if (!elt) {\n        return;\n      }\n      if (delay) {\n        getWindow().setTimeout(function() {\n          removeClassFromElement(elt, clazz);\n          elt = null;\n        }, delay);\n      } else {\n        if (elt.classList) {\n          elt.classList.remove(clazz);\n          if (elt.classList.length === 0) {\n            elt.removeAttribute(\"class\");\n          }\n        }\n      }\n    }\n    function toggleClassOnElement(elt, clazz) {\n      elt = resolveTarget(elt);\n      elt.classList.toggle(clazz);\n    }\n    function takeClassForElement(elt, clazz) {\n      elt = resolveTarget(elt);\n      forEach(elt.parentElement.children, function(child) {\n        removeClassFromElement(child, clazz);\n      });\n      addClassToElement(asElement(elt), clazz);\n    }\n    function closest(elt, selector) {\n      elt = asElement(resolveTarget(elt));\n      if (elt && elt.closest) {\n        return elt.closest(selector);\n      } else {\n        do {\n          if (elt == null || matches(elt, selector)) {\n            return elt;\n          }\n        } while (elt = elt && asElement(parentElt(elt)));\n        return null;\n      }\n    }\n    function startsWith(str2, prefix) {\n      return str2.substring(0, prefix.length) === prefix;\n    }\n    function endsWith(str2, suffix) {\n      return str2.substring(str2.length - suffix.length) === suffix;\n    }\n    function normalizeSelector(selector) {\n      const trimmedSelector = selector.trim();\n      if (startsWith(trimmedSelector, \"<\") && endsWith(trimmedSelector, \"/>\")) {\n        return trimmedSelector.substring(1, trimmedSelector.length - 2);\n      } else {\n        return trimmedSelector;\n      }\n    }\n    function querySelectorAllExt(elt, selector, global2) {\n      elt = resolveTarget(elt);\n      if (selector.indexOf(\"closest \") === 0) {\n        return [closest(asElement(elt), normalizeSelector(selector.substr(8)))];\n      } else if (selector.indexOf(\"find \") === 0) {\n        return [find(asParentNode(elt), normalizeSelector(selector.substr(5)))];\n      } else if (selector === \"next\") {\n        return [asElement(elt).nextElementSibling];\n      } else if (selector.indexOf(\"next \") === 0) {\n        return [scanForwardQuery(elt, normalizeSelector(selector.substr(5)), !!global2)];\n      } else if (selector === \"previous\") {\n        return [asElement(elt).previousElementSibling];\n      } else if (selector.indexOf(\"previous \") === 0) {\n        return [scanBackwardsQuery(elt, normalizeSelector(selector.substr(9)), !!global2)];\n      } else if (selector === \"document\") {\n        return [document];\n      } else if (selector === \"window\") {\n        return [window];\n      } else if (selector === \"body\") {\n        return [document.body];\n      } else if (selector === \"root\") {\n        return [getRootNode(elt, !!global2)];\n      } else if (selector.indexOf(\"global \") === 0) {\n        return querySelectorAllExt(elt, selector.slice(7), true);\n      } else {\n        return toArray(asParentNode(getRootNode(elt, !!global2)).querySelectorAll(normalizeSelector(selector)));\n      }\n    }\n    var scanForwardQuery = function(start2, match, global2) {\n      const results = asParentNode(getRootNode(start2, global2)).querySelectorAll(match);\n      for (let i = 0; i < results.length; i++) {\n        const elt = results[i];\n        if (elt.compareDocumentPosition(start2) === Node.DOCUMENT_POSITION_PRECEDING) {\n          return elt;\n        }\n      }\n    };\n    var scanBackwardsQuery = function(start2, match, global2) {\n      const results = asParentNode(getRootNode(start2, global2)).querySelectorAll(match);\n      for (let i = results.length - 1; i >= 0; i--) {\n        const elt = results[i];\n        if (elt.compareDocumentPosition(start2) === Node.DOCUMENT_POSITION_FOLLOWING) {\n          return elt;\n        }\n      }\n    };\n    function querySelectorExt(eltOrSelector, selector) {\n      if (typeof eltOrSelector !== \"string\") {\n        return querySelectorAllExt(eltOrSelector, selector)[0];\n      } else {\n        return querySelectorAllExt(getDocument().body, eltOrSelector)[0];\n      }\n    }\n    function resolveTarget(eltOrSelector, context) {\n      if (typeof eltOrSelector === \"string\") {\n        return find(asParentNode(context) || document, eltOrSelector);\n      } else {\n        return eltOrSelector;\n      }\n    }\n    function processEventArgs(arg1, arg2, arg3) {\n      if (isFunction(arg2)) {\n        return {\n          target: getDocument().body,\n          event: asString(arg1),\n          listener: arg2\n        };\n      } else {\n        return {\n          target: resolveTarget(arg1),\n          event: asString(arg2),\n          listener: arg3\n        };\n      }\n    }\n    function addEventListenerImpl(arg1, arg2, arg3) {\n      ready(function() {\n        const eventArgs = processEventArgs(arg1, arg2, arg3);\n        eventArgs.target.addEventListener(eventArgs.event, eventArgs.listener);\n      });\n      const b = isFunction(arg2);\n      return b ? arg2 : arg3;\n    }\n    function removeEventListenerImpl(arg1, arg2, arg3) {\n      ready(function() {\n        const eventArgs = processEventArgs(arg1, arg2, arg3);\n        eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener);\n      });\n      return isFunction(arg2) ? arg2 : arg3;\n    }\n    const DUMMY_ELT = getDocument().createElement(\"output\");\n    function findAttributeTargets(elt, attrName) {\n      const attrTarget = getClosestAttributeValue(elt, attrName);\n      if (attrTarget) {\n        if (attrTarget === \"this\") {\n          return [findThisElement(elt, attrName)];\n        } else {\n          const result = querySelectorAllExt(elt, attrTarget);\n          if (result.length === 0) {\n            logError('The selector \"' + attrTarget + '\" on ' + attrName + \" returned no matches!\");\n            return [DUMMY_ELT];\n          } else {\n            return result;\n          }\n        }\n      }\n    }\n    function findThisElement(elt, attribute) {\n      return asElement(getClosestMatch(elt, function(elt2) {\n        return getAttributeValue(asElement(elt2), attribute) != null;\n      }));\n    }\n    function getTarget(elt) {\n      const targetStr = getClosestAttributeValue(elt, \"hx-target\");\n      if (targetStr) {\n        if (targetStr === \"this\") {\n          return findThisElement(elt, \"hx-target\");\n        } else {\n          return querySelectorExt(elt, targetStr);\n        }\n      } else {\n        const data = getInternalData(elt);\n        if (data.boosted) {\n          return getDocument().body;\n        } else {\n          return elt;\n        }\n      }\n    }\n    function shouldSettleAttribute(name2) {\n      const attributesToSettle = htmx.config.attributesToSettle;\n      for (let i = 0; i < attributesToSettle.length; i++) {\n        if (name2 === attributesToSettle[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function cloneAttributes(mergeTo, mergeFrom) {\n      forEach(mergeTo.attributes, function(attr) {\n        if (!mergeFrom.hasAttribute(attr.name) && shouldSettleAttribute(attr.name)) {\n          mergeTo.removeAttribute(attr.name);\n        }\n      });\n      forEach(mergeFrom.attributes, function(attr) {\n        if (shouldSettleAttribute(attr.name)) {\n          mergeTo.setAttribute(attr.name, attr.value);\n        }\n      });\n    }\n    function isInlineSwap(swapStyle, target) {\n      const extensions2 = getExtensions(target);\n      for (let i = 0; i < extensions2.length; i++) {\n        const extension = extensions2[i];\n        try {\n          if (extension.isInlineSwap(swapStyle)) {\n            return true;\n          }\n        } catch (e2) {\n          logError(e2);\n        }\n      }\n      return swapStyle === \"outerHTML\";\n    }\n    function oobSwap(oobValue, oobElement, settleInfo) {\n      let selector = \"#\" + getRawAttribute(oobElement, \"id\");\n      let swapStyle = \"outerHTML\";\n      if (oobValue === \"true\") {\n      } else if (oobValue.indexOf(\":\") > 0) {\n        swapStyle = oobValue.substr(0, oobValue.indexOf(\":\"));\n        selector = oobValue.substr(oobValue.indexOf(\":\") + 1, oobValue.length);\n      } else {\n        swapStyle = oobValue;\n      }\n      const targets = getDocument().querySelectorAll(selector);\n      if (targets) {\n        forEach(\n          targets,\n          function(target) {\n            let fragment;\n            const oobElementClone = oobElement.cloneNode(true);\n            fragment = getDocument().createDocumentFragment();\n            fragment.appendChild(oobElementClone);\n            if (!isInlineSwap(swapStyle, target)) {\n              fragment = asParentNode(oobElementClone);\n            }\n            const beforeSwapDetails = { shouldSwap: true, target, fragment };\n            if (!triggerEvent(target, \"htmx:oobBeforeSwap\", beforeSwapDetails))\n              return;\n            target = beforeSwapDetails.target;\n            if (beforeSwapDetails.shouldSwap) {\n              swapWithStyle(swapStyle, target, target, fragment, settleInfo);\n            }\n            forEach(settleInfo.elts, function(elt) {\n              triggerEvent(elt, \"htmx:oobAfterSwap\", beforeSwapDetails);\n            });\n          }\n        );\n        oobElement.parentNode.removeChild(oobElement);\n      } else {\n        oobElement.parentNode.removeChild(oobElement);\n        triggerErrorEvent(getDocument().body, \"htmx:oobErrorNoTarget\", { content: oobElement });\n      }\n      return oobValue;\n    }\n    function handlePreservedElements(fragment) {\n      forEach(findAll(fragment, \"[hx-preserve], [data-hx-preserve]\"), function(preservedElt) {\n        const id = getAttributeValue(preservedElt, \"id\");\n        const oldElt = getDocument().getElementById(id);\n        if (oldElt != null) {\n          preservedElt.parentNode.replaceChild(oldElt, preservedElt);\n        }\n      });\n    }\n    function handleAttributes(parentNode, fragment, settleInfo) {\n      forEach(fragment.querySelectorAll(\"[id]\"), function(newNode) {\n        const id = getRawAttribute(newNode, \"id\");\n        if (id && id.length > 0) {\n          const normalizedId = id.replace(\"'\", \"\\\\'\");\n          const normalizedTag = newNode.tagName.replace(\":\", \"\\\\:\");\n          const parentElt2 = asParentNode(parentNode);\n          const oldNode = parentElt2 && parentElt2.querySelector(normalizedTag + \"[id='\" + normalizedId + \"']\");\n          if (oldNode && oldNode !== parentElt2) {\n            const newAttributes = newNode.cloneNode();\n            cloneAttributes(newNode, oldNode);\n            settleInfo.tasks.push(function() {\n              cloneAttributes(newNode, newAttributes);\n            });\n          }\n        }\n      });\n    }\n    function makeAjaxLoadTask(child) {\n      return function() {\n        removeClassFromElement(child, htmx.config.addedClass);\n        processNode(asElement(child));\n        processFocus(asParentNode(child));\n        triggerEvent(child, \"htmx:load\");\n      };\n    }\n    function processFocus(child) {\n      const autofocus = \"[autofocus]\";\n      const autoFocusedElt = asHtmlElement(matches(child, autofocus) ? child : child.querySelector(autofocus));\n      if (autoFocusedElt != null) {\n        autoFocusedElt.focus();\n      }\n    }\n    function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {\n      handleAttributes(parentNode, fragment, settleInfo);\n      while (fragment.childNodes.length > 0) {\n        const child = fragment.firstChild;\n        addClassToElement(asElement(child), htmx.config.addedClass);\n        parentNode.insertBefore(child, insertBefore);\n        if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n          settleInfo.tasks.push(makeAjaxLoadTask(child));\n        }\n      }\n    }\n    function stringHash(string, hash4) {\n      let char = 0;\n      while (char < string.length) {\n        hash4 = (hash4 << 5) - hash4 + string.charCodeAt(char++) | 0;\n      }\n      return hash4;\n    }\n    function attributeHash(elt) {\n      let hash4 = 0;\n      if (elt.attributes) {\n        for (let i = 0; i < elt.attributes.length; i++) {\n          const attribute = elt.attributes[i];\n          if (attribute.value) {\n            hash4 = stringHash(attribute.name, hash4);\n            hash4 = stringHash(attribute.value, hash4);\n          }\n        }\n      }\n      return hash4;\n    }\n    function deInitOnHandlers(elt) {\n      const internalData = getInternalData(elt);\n      if (internalData.onHandlers) {\n        for (let i = 0; i < internalData.onHandlers.length; i++) {\n          const handlerInfo = internalData.onHandlers[i];\n          removeEventListenerImpl(elt, handlerInfo.event, handlerInfo.listener);\n        }\n        delete internalData.onHandlers;\n      }\n    }\n    function deInitNode(element) {\n      const internalData = getInternalData(element);\n      if (internalData.timeout) {\n        clearTimeout(internalData.timeout);\n      }\n      if (internalData.listenerInfos) {\n        forEach(internalData.listenerInfos, function(info) {\n          if (info.on) {\n            removeEventListenerImpl(info.on, info.trigger, info.listener);\n          }\n        });\n      }\n      deInitOnHandlers(element);\n      forEach(Object.keys(internalData), function(key) {\n        delete internalData[key];\n      });\n    }\n    function cleanUpElement(element) {\n      triggerEvent(element, \"htmx:beforeCleanupElement\");\n      deInitNode(element);\n      if (element.children) {\n        forEach(element.children, function(child) {\n          cleanUpElement(child);\n        });\n      }\n    }\n    function swapOuterHTML(target, fragment, settleInfo) {\n      let newElt;\n      const eltBeforeNewContent = target.previousSibling;\n      insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n      if (eltBeforeNewContent == null) {\n        newElt = parentElt(target).firstChild;\n      } else {\n        newElt = eltBeforeNewContent.nextSibling;\n      }\n      settleInfo.elts = settleInfo.elts.filter(function(e2) {\n        return e2 !== target;\n      });\n      while (newElt && newElt !== target) {\n        if (newElt instanceof Element) {\n          settleInfo.elts.push(newElt);\n          newElt = newElt.nextElementSibling;\n        } else {\n          newElt = null;\n        }\n      }\n      cleanUpElement(target);\n      if (target instanceof Element) {\n        target.remove();\n      } else {\n        target.parentNode.removeChild(target);\n      }\n    }\n    function swapAfterBegin(target, fragment, settleInfo) {\n      return insertNodesBefore(target, target.firstChild, fragment, settleInfo);\n    }\n    function swapBeforeBegin(target, fragment, settleInfo) {\n      return insertNodesBefore(parentElt(target), target, fragment, settleInfo);\n    }\n    function swapBeforeEnd(target, fragment, settleInfo) {\n      return insertNodesBefore(target, null, fragment, settleInfo);\n    }\n    function swapAfterEnd(target, fragment, settleInfo) {\n      return insertNodesBefore(parentElt(target), target.nextSibling, fragment, settleInfo);\n    }\n    function swapDelete(target) {\n      cleanUpElement(target);\n      return parentElt(target).removeChild(target);\n    }\n    function swapInnerHTML(target, fragment, settleInfo) {\n      const firstChild = target.firstChild;\n      insertNodesBefore(target, firstChild, fragment, settleInfo);\n      if (firstChild) {\n        while (firstChild.nextSibling) {\n          cleanUpElement(firstChild.nextSibling);\n          target.removeChild(firstChild.nextSibling);\n        }\n        cleanUpElement(firstChild);\n        target.removeChild(firstChild);\n      }\n    }\n    function swapWithStyle(swapStyle, elt, target, fragment, settleInfo) {\n      switch (swapStyle) {\n        case \"none\":\n          return;\n        case \"outerHTML\":\n          swapOuterHTML(target, fragment, settleInfo);\n          return;\n        case \"afterbegin\":\n          swapAfterBegin(target, fragment, settleInfo);\n          return;\n        case \"beforebegin\":\n          swapBeforeBegin(target, fragment, settleInfo);\n          return;\n        case \"beforeend\":\n          swapBeforeEnd(target, fragment, settleInfo);\n          return;\n        case \"afterend\":\n          swapAfterEnd(target, fragment, settleInfo);\n          return;\n        case \"delete\":\n          swapDelete(target);\n          return;\n        default:\n          var extensions2 = getExtensions(elt);\n          for (let i = 0; i < extensions2.length; i++) {\n            const ext = extensions2[i];\n            try {\n              const newElements = ext.handleSwap(swapStyle, target, fragment, settleInfo);\n              if (newElements) {\n                if (typeof newElements.length !== \"undefined\") {\n                  for (let j = 0; j < newElements.length; j++) {\n                    const child = newElements[j];\n                    if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                      settleInfo.tasks.push(makeAjaxLoadTask(child));\n                    }\n                  }\n                }\n                return;\n              }\n            } catch (e2) {\n              logError(e2);\n            }\n          }\n          if (swapStyle === \"innerHTML\") {\n            swapInnerHTML(target, fragment, settleInfo);\n          } else {\n            swapWithStyle(htmx.config.defaultSwapStyle, elt, target, fragment, settleInfo);\n          }\n      }\n    }\n    function findAndSwapOobElements(fragment, settleInfo) {\n      forEach(findAll(fragment, \"[hx-swap-oob], [data-hx-swap-oob]\"), function(oobElement) {\n        if (htmx.config.allowNestedOobSwaps || oobElement.parentElement === null) {\n          const oobValue = getAttributeValue(oobElement, \"hx-swap-oob\");\n          if (oobValue != null) {\n            oobSwap(oobValue, oobElement, settleInfo);\n          }\n        } else {\n          oobElement.removeAttribute(\"hx-swap-oob\");\n          oobElement.removeAttribute(\"data-hx-swap-oob\");\n        }\n      });\n    }\n    function swap(target, content, swapSpec, swapOptions) {\n      if (!swapOptions) {\n        swapOptions = {};\n      }\n      target = resolveTarget(target);\n      const activeElt = document.activeElement;\n      let selectionInfo = {};\n      try {\n        selectionInfo = {\n          elt: activeElt,\n          // @ts-ignore\n          start: activeElt ? activeElt.selectionStart : null,\n          // @ts-ignore\n          end: activeElt ? activeElt.selectionEnd : null\n        };\n      } catch (e2) {\n      }\n      const settleInfo = makeSettleInfo(target);\n      if (swapSpec.swapStyle === \"textContent\") {\n        target.textContent = content;\n      } else {\n        let fragment = makeFragment(content);\n        settleInfo.title = fragment.title;\n        if (swapOptions.selectOOB) {\n          const oobSelectValues = swapOptions.selectOOB.split(\",\");\n          for (let i = 0; i < oobSelectValues.length; i++) {\n            const oobSelectValue = oobSelectValues[i].split(\":\", 2);\n            let id = oobSelectValue[0].trim();\n            if (id.indexOf(\"#\") === 0) {\n              id = id.substring(1);\n            }\n            const oobValue = oobSelectValue[1] || \"true\";\n            const oobElement = fragment.querySelector(\"#\" + id);\n            if (oobElement) {\n              oobSwap(oobValue, oobElement, settleInfo);\n            }\n          }\n        }\n        findAndSwapOobElements(fragment, settleInfo);\n        forEach(\n          findAll(fragment, \"template\"),\n          /** @param {HTMLTemplateElement} template */\n          function(template) {\n            findAndSwapOobElements(template.content, settleInfo);\n            if (template.content.childElementCount === 0) {\n              template.remove();\n            }\n          }\n        );\n        if (swapOptions.select) {\n          const newFragment = getDocument().createDocumentFragment();\n          forEach(fragment.querySelectorAll(swapOptions.select), function(node) {\n            newFragment.appendChild(node);\n          });\n          fragment = newFragment;\n        }\n        handlePreservedElements(fragment);\n        swapWithStyle(swapSpec.swapStyle, swapOptions.contextElement, target, fragment, settleInfo);\n      }\n      if (selectionInfo.elt && !bodyContains(selectionInfo.elt) && getRawAttribute(selectionInfo.elt, \"id\")) {\n        const newActiveElt = document.getElementById(getRawAttribute(selectionInfo.elt, \"id\"));\n        const focusOptions = { preventScroll: swapSpec.focusScroll !== void 0 ? !swapSpec.focusScroll : !htmx.config.defaultFocusScroll };\n        if (newActiveElt) {\n          if (selectionInfo.start && newActiveElt.setSelectionRange) {\n            try {\n              newActiveElt.setSelectionRange(selectionInfo.start, selectionInfo.end);\n            } catch (e2) {\n            }\n          }\n          newActiveElt.focus(focusOptions);\n        }\n      }\n      target.classList.remove(htmx.config.swappingClass);\n      forEach(settleInfo.elts, function(elt) {\n        if (elt.classList) {\n          elt.classList.add(htmx.config.settlingClass);\n        }\n        triggerEvent(elt, \"htmx:afterSwap\", swapOptions.eventInfo);\n      });\n      if (swapOptions.afterSwapCallback) {\n        swapOptions.afterSwapCallback();\n      }\n      if (!swapSpec.ignoreTitle) {\n        handleTitle(settleInfo.title);\n      }\n      const doSettle = function() {\n        forEach(settleInfo.tasks, function(task) {\n          task.call();\n        });\n        forEach(settleInfo.elts, function(elt) {\n          if (elt.classList) {\n            elt.classList.remove(htmx.config.settlingClass);\n          }\n          triggerEvent(elt, \"htmx:afterSettle\", swapOptions.eventInfo);\n        });\n        if (swapOptions.anchor) {\n          const anchorTarget = asElement(resolveTarget(\"#\" + swapOptions.anchor));\n          if (anchorTarget) {\n            anchorTarget.scrollIntoView({ block: \"start\", behavior: \"auto\" });\n          }\n        }\n        updateScrollState(settleInfo.elts, swapSpec);\n        if (swapOptions.afterSettleCallback) {\n          swapOptions.afterSettleCallback();\n        }\n      };\n      if (swapSpec.settleDelay > 0) {\n        getWindow().setTimeout(doSettle, swapSpec.settleDelay);\n      } else {\n        doSettle();\n      }\n    }\n    function handleTriggerHeader(xhr, header, elt) {\n      const triggerBody = xhr.getResponseHeader(header);\n      if (triggerBody.indexOf(\"{\") === 0) {\n        const triggers = parseJSON(triggerBody);\n        for (const eventName in triggers) {\n          if (triggers.hasOwnProperty(eventName)) {\n            let detail = triggers[eventName];\n            if (!isRawObject(detail)) {\n              detail = { value: detail };\n            }\n            triggerEvent(elt, eventName, detail);\n          }\n        }\n      } else {\n        const eventNames = triggerBody.split(\",\");\n        for (let i = 0; i < eventNames.length; i++) {\n          triggerEvent(elt, eventNames[i].trim(), []);\n        }\n      }\n    }\n    const WHITESPACE = /\\s/;\n    const WHITESPACE_OR_COMMA = /[\\s,]/;\n    const SYMBOL_START = /[_$a-zA-Z]/;\n    const SYMBOL_CONT = /[_$a-zA-Z0-9]/;\n    const STRINGISH_START = ['\"', \"'\", \"/\"];\n    const NOT_WHITESPACE = /[^\\s]/;\n    const COMBINED_SELECTOR_START = /[{(]/;\n    const COMBINED_SELECTOR_END = /[})]/;\n    function tokenizeString(str2) {\n      const tokens = [];\n      let position = 0;\n      while (position < str2.length) {\n        if (SYMBOL_START.exec(str2.charAt(position))) {\n          var startPosition = position;\n          while (SYMBOL_CONT.exec(str2.charAt(position + 1))) {\n            position++;\n          }\n          tokens.push(str2.substr(startPosition, position - startPosition + 1));\n        } else if (STRINGISH_START.indexOf(str2.charAt(position)) !== -1) {\n          const startChar = str2.charAt(position);\n          var startPosition = position;\n          position++;\n          while (position < str2.length && str2.charAt(position) !== startChar) {\n            if (str2.charAt(position) === \"\\\\\") {\n              position++;\n            }\n            position++;\n          }\n          tokens.push(str2.substr(startPosition, position - startPosition + 1));\n        } else {\n          const symbol = str2.charAt(position);\n          tokens.push(symbol);\n        }\n        position++;\n      }\n      return tokens;\n    }\n    function isPossibleRelativeReference(token, last, paramName) {\n      return SYMBOL_START.exec(token.charAt(0)) && token !== \"true\" && token !== \"false\" && token !== \"this\" && token !== paramName && last !== \".\";\n    }\n    function maybeGenerateConditional(elt, tokens, paramName) {\n      if (tokens[0] === \"[\") {\n        tokens.shift();\n        let bracketCount = 1;\n        let conditionalSource = \" return (function(\" + paramName + \"){ return (\";\n        let last = null;\n        while (tokens.length > 0) {\n          const token = tokens[0];\n          if (token === \"]\") {\n            bracketCount--;\n            if (bracketCount === 0) {\n              if (last === null) {\n                conditionalSource = conditionalSource + \"true\";\n              }\n              tokens.shift();\n              conditionalSource += \")})\";\n              try {\n                const conditionFunction = maybeEval(\n                  elt,\n                  function() {\n                    return Function(conditionalSource)();\n                  },\n                  function() {\n                    return true;\n                  }\n                );\n                conditionFunction.source = conditionalSource;\n                return conditionFunction;\n              } catch (e2) {\n                triggerErrorEvent(getDocument().body, \"htmx:syntax:error\", { error: e2, source: conditionalSource });\n                return null;\n              }\n            }\n          } else if (token === \"[\") {\n            bracketCount++;\n          }\n          if (isPossibleRelativeReference(token, last, paramName)) {\n            conditionalSource += \"((\" + paramName + \".\" + token + \") ? (\" + paramName + \".\" + token + \") : (window.\" + token + \"))\";\n          } else {\n            conditionalSource = conditionalSource + token;\n          }\n          last = tokens.shift();\n        }\n      }\n    }\n    function consumeUntil(tokens, match) {\n      let result = \"\";\n      while (tokens.length > 0 && !match.test(tokens[0])) {\n        result += tokens.shift();\n      }\n      return result;\n    }\n    function consumeCSSSelector(tokens) {\n      let result;\n      if (tokens.length > 0 && COMBINED_SELECTOR_START.test(tokens[0])) {\n        tokens.shift();\n        result = consumeUntil(tokens, COMBINED_SELECTOR_END).trim();\n        tokens.shift();\n      } else {\n        result = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n      }\n      return result;\n    }\n    const INPUT_SELECTOR = \"input, textarea, select\";\n    function parseAndCacheTrigger(elt, explicitTrigger, cache) {\n      const triggerSpecs = [];\n      const tokens = tokenizeString(explicitTrigger);\n      do {\n        consumeUntil(tokens, NOT_WHITESPACE);\n        const initialLength = tokens.length;\n        const trigger = consumeUntil(tokens, /[,\\[\\s]/);\n        if (trigger !== \"\") {\n          if (trigger === \"every\") {\n            const every = { trigger: \"every\" };\n            consumeUntil(tokens, NOT_WHITESPACE);\n            every.pollInterval = parseInterval(consumeUntil(tokens, /[,\\[\\s]/));\n            consumeUntil(tokens, NOT_WHITESPACE);\n            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n            if (eventFilter) {\n              every.eventFilter = eventFilter;\n            }\n            triggerSpecs.push(every);\n          } else {\n            const triggerSpec = { trigger };\n            var eventFilter = maybeGenerateConditional(elt, tokens, \"event\");\n            if (eventFilter) {\n              triggerSpec.eventFilter = eventFilter;\n            }\n            while (tokens.length > 0 && tokens[0] !== \",\") {\n              consumeUntil(tokens, NOT_WHITESPACE);\n              const token = tokens.shift();\n              if (token === \"changed\") {\n                triggerSpec.changed = true;\n              } else if (token === \"once\") {\n                triggerSpec.once = true;\n              } else if (token === \"consume\") {\n                triggerSpec.consume = true;\n              } else if (token === \"delay\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec.delay = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n              } else if (token === \"from\" && tokens[0] === \":\") {\n                tokens.shift();\n                if (COMBINED_SELECTOR_START.test(tokens[0])) {\n                  var from_arg = consumeCSSSelector(tokens);\n                } else {\n                  var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n                  if (from_arg === \"closest\" || from_arg === \"find\" || from_arg === \"next\" || from_arg === \"previous\") {\n                    tokens.shift();\n                    const selector = consumeCSSSelector(tokens);\n                    if (selector.length > 0) {\n                      from_arg += \" \" + selector;\n                    }\n                  }\n                }\n                triggerSpec.from = from_arg;\n              } else if (token === \"target\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec.target = consumeCSSSelector(tokens);\n              } else if (token === \"throttle\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec.throttle = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));\n              } else if (token === \"queue\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n              } else if (token === \"root\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec[token] = consumeCSSSelector(tokens);\n              } else if (token === \"threshold\" && tokens[0] === \":\") {\n                tokens.shift();\n                triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA);\n              } else {\n                triggerErrorEvent(elt, \"htmx:syntax:error\", { token: tokens.shift() });\n              }\n            }\n            triggerSpecs.push(triggerSpec);\n          }\n        }\n        if (tokens.length === initialLength) {\n          triggerErrorEvent(elt, \"htmx:syntax:error\", { token: tokens.shift() });\n        }\n        consumeUntil(tokens, NOT_WHITESPACE);\n      } while (tokens[0] === \",\" && tokens.shift());\n      if (cache) {\n        cache[explicitTrigger] = triggerSpecs;\n      }\n      return triggerSpecs;\n    }\n    function getTriggerSpecs(elt) {\n      const explicitTrigger = getAttributeValue(elt, \"hx-trigger\");\n      let triggerSpecs = [];\n      if (explicitTrigger) {\n        const cache = htmx.config.triggerSpecsCache;\n        triggerSpecs = cache && cache[explicitTrigger] || parseAndCacheTrigger(elt, explicitTrigger, cache);\n      }\n      if (triggerSpecs.length > 0) {\n        return triggerSpecs;\n      } else if (matches(elt, \"form\")) {\n        return [{ trigger: \"submit\" }];\n      } else if (matches(elt, 'input[type=\"button\"], input[type=\"submit\"]')) {\n        return [{ trigger: \"click\" }];\n      } else if (matches(elt, INPUT_SELECTOR)) {\n        return [{ trigger: \"change\" }];\n      } else {\n        return [{ trigger: \"click\" }];\n      }\n    }\n    function cancelPolling(elt) {\n      getInternalData(elt).cancelled = true;\n    }\n    function processPolling(elt, handler, spec) {\n      const nodeData = getInternalData(elt);\n      nodeData.timeout = getWindow().setTimeout(function() {\n        if (bodyContains(elt) && nodeData.cancelled !== true) {\n          if (!maybeFilterEvent(spec, elt, makeEvent(\"hx:poll:trigger\", {\n            triggerSpec: spec,\n            target: elt\n          }))) {\n            handler(elt);\n          }\n          processPolling(elt, handler, spec);\n        }\n      }, spec.pollInterval);\n    }\n    function isLocalLink(elt) {\n      return location.hostname === elt.hostname && getRawAttribute(elt, \"href\") && getRawAttribute(elt, \"href\").indexOf(\"#\") !== 0;\n    }\n    function eltIsDisabled(elt) {\n      return closest(elt, htmx.config.disableSelector);\n    }\n    function boostElement(elt, nodeData, triggerSpecs) {\n      if (elt instanceof HTMLAnchorElement && isLocalLink(elt) && (elt.target === \"\" || elt.target === \"_self\") || elt.tagName === \"FORM\") {\n        nodeData.boosted = true;\n        let verb, path;\n        if (elt.tagName === \"A\") {\n          verb = \"get\";\n          path = getRawAttribute(elt, \"href\");\n        } else {\n          const rawAttribute = getRawAttribute(elt, \"method\");\n          verb = rawAttribute ? rawAttribute.toLowerCase() : \"get\";\n          if (verb === \"get\") {\n          }\n          path = getRawAttribute(elt, \"action\");\n        }\n        triggerSpecs.forEach(function(triggerSpec) {\n          addEventListener(elt, function(node, evt) {\n            const elt2 = asElement(node);\n            if (eltIsDisabled(elt2)) {\n              cleanUpElement(elt2);\n              return;\n            }\n            issueAjaxRequest(verb, path, elt2, evt);\n          }, nodeData, triggerSpec, true);\n        });\n      }\n    }\n    function shouldCancel(evt, node) {\n      const elt = asElement(node);\n      if (!elt) {\n        return false;\n      }\n      if (evt.type === \"submit\" || evt.type === \"click\") {\n        if (elt.tagName === \"FORM\") {\n          return true;\n        }\n        if (matches(elt, 'input[type=\"submit\"], button') && closest(elt, \"form\") !== null) {\n          return true;\n        }\n        if (elt instanceof HTMLAnchorElement && elt.href && (elt.getAttribute(\"href\") === \"#\" || elt.getAttribute(\"href\").indexOf(\"#\") !== 0)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function ignoreBoostedAnchorCtrlClick(elt, evt) {\n      return getInternalData(elt).boosted && elt instanceof HTMLAnchorElement && evt.type === \"click\" && // @ts-ignore this will resolve to undefined for events that don't define those properties, which is fine\n      (evt.ctrlKey || evt.metaKey);\n    }\n    function maybeFilterEvent(triggerSpec, elt, evt) {\n      const eventFilter = triggerSpec.eventFilter;\n      if (eventFilter) {\n        try {\n          return eventFilter.call(elt, evt) !== true;\n        } catch (e2) {\n          const source = eventFilter.source;\n          triggerErrorEvent(getDocument().body, \"htmx:eventFilter:error\", { error: e2, source });\n          return true;\n        }\n      }\n      return false;\n    }\n    function addEventListener(elt, handler, nodeData, triggerSpec, explicitCancel) {\n      const elementData = getInternalData(elt);\n      let eltsToListenOn;\n      if (triggerSpec.from) {\n        eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from);\n      } else {\n        eltsToListenOn = [elt];\n      }\n      if (triggerSpec.changed) {\n        eltsToListenOn.forEach(function(eltToListenOn) {\n          const eltToListenOnData = getInternalData(eltToListenOn);\n          eltToListenOnData.lastValue = eltToListenOn.value;\n        });\n      }\n      forEach(eltsToListenOn, function(eltToListenOn) {\n        const eventListener = function(evt) {\n          if (!bodyContains(elt)) {\n            eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener);\n            return;\n          }\n          if (ignoreBoostedAnchorCtrlClick(elt, evt)) {\n            return;\n          }\n          if (explicitCancel || shouldCancel(evt, elt)) {\n            evt.preventDefault();\n          }\n          if (maybeFilterEvent(triggerSpec, elt, evt)) {\n            return;\n          }\n          const eventData = getInternalData(evt);\n          eventData.triggerSpec = triggerSpec;\n          if (eventData.handledFor == null) {\n            eventData.handledFor = [];\n          }\n          if (eventData.handledFor.indexOf(elt) < 0) {\n            eventData.handledFor.push(elt);\n            if (triggerSpec.consume) {\n              evt.stopPropagation();\n            }\n            if (triggerSpec.target && evt.target) {\n              if (!matches(asElement(evt.target), triggerSpec.target)) {\n                return;\n              }\n            }\n            if (triggerSpec.once) {\n              if (elementData.triggeredOnce) {\n                return;\n              } else {\n                elementData.triggeredOnce = true;\n              }\n            }\n            if (triggerSpec.changed) {\n              const eltToListenOnData = getInternalData(eltToListenOn);\n              const value = eltToListenOn.value;\n              if (eltToListenOnData.lastValue === value) {\n                return;\n              }\n              eltToListenOnData.lastValue = value;\n            }\n            if (elementData.delayed) {\n              clearTimeout(elementData.delayed);\n            }\n            if (elementData.throttle) {\n              return;\n            }\n            if (triggerSpec.throttle > 0) {\n              if (!elementData.throttle) {\n                handler(elt, evt);\n                elementData.throttle = getWindow().setTimeout(function() {\n                  elementData.throttle = null;\n                }, triggerSpec.throttle);\n              }\n            } else if (triggerSpec.delay > 0) {\n              elementData.delayed = getWindow().setTimeout(function() {\n                handler(elt, evt);\n              }, triggerSpec.delay);\n            } else {\n              triggerEvent(elt, \"htmx:trigger\");\n              handler(elt, evt);\n            }\n          }\n        };\n        if (nodeData.listenerInfos == null) {\n          nodeData.listenerInfos = [];\n        }\n        nodeData.listenerInfos.push({\n          trigger: triggerSpec.trigger,\n          listener: eventListener,\n          on: eltToListenOn\n        });\n        eltToListenOn.addEventListener(triggerSpec.trigger, eventListener);\n      });\n    }\n    let windowIsScrolling = false;\n    let scrollHandler = null;\n    function initScrollHandler() {\n      if (!scrollHandler) {\n        scrollHandler = function() {\n          windowIsScrolling = true;\n        };\n        window.addEventListener(\"scroll\", scrollHandler);\n        setInterval(function() {\n          if (windowIsScrolling) {\n            windowIsScrolling = false;\n            forEach(getDocument().querySelectorAll(\"[hx-trigger*='revealed'],[data-hx-trigger*='revealed']\"), function(elt) {\n              maybeReveal(elt);\n            });\n          }\n        }, 200);\n      }\n    }\n    function maybeReveal(elt) {\n      if (!hasAttribute(elt, \"data-hx-revealed\") && isScrolledIntoView(elt)) {\n        elt.setAttribute(\"data-hx-revealed\", \"true\");\n        const nodeData = getInternalData(elt);\n        if (nodeData.initHash) {\n          triggerEvent(elt, \"revealed\");\n        } else {\n          elt.addEventListener(\"htmx:afterProcessNode\", function() {\n            triggerEvent(elt, \"revealed\");\n          }, { once: true });\n        }\n      }\n    }\n    function loadImmediately(elt, handler, nodeData, delay) {\n      const load = function() {\n        if (!nodeData.loaded) {\n          nodeData.loaded = true;\n          handler(elt);\n        }\n      };\n      if (delay > 0) {\n        getWindow().setTimeout(load, delay);\n      } else {\n        load();\n      }\n    }\n    function processVerbs(elt, nodeData, triggerSpecs) {\n      let explicitAction = false;\n      forEach(VERBS, function(verb) {\n        if (hasAttribute(elt, \"hx-\" + verb)) {\n          const path = getAttributeValue(elt, \"hx-\" + verb);\n          explicitAction = true;\n          nodeData.path = path;\n          nodeData.verb = verb;\n          triggerSpecs.forEach(function(triggerSpec) {\n            addTriggerHandler(elt, triggerSpec, nodeData, function(node, evt) {\n              const elt2 = asElement(node);\n              if (closest(elt2, htmx.config.disableSelector)) {\n                cleanUpElement(elt2);\n                return;\n              }\n              issueAjaxRequest(verb, path, elt2, evt);\n            });\n          });\n        }\n      });\n      return explicitAction;\n    }\n    function addTriggerHandler(elt, triggerSpec, nodeData, handler) {\n      if (triggerSpec.trigger === \"revealed\") {\n        initScrollHandler();\n        addEventListener(elt, handler, nodeData, triggerSpec);\n        maybeReveal(asElement(elt));\n      } else if (triggerSpec.trigger === \"intersect\") {\n        const observerOptions = {};\n        if (triggerSpec.root) {\n          observerOptions.root = querySelectorExt(elt, triggerSpec.root);\n        }\n        if (triggerSpec.threshold) {\n          observerOptions.threshold = parseFloat(triggerSpec.threshold);\n        }\n        const observer = new IntersectionObserver(function(entries) {\n          for (let i = 0; i < entries.length; i++) {\n            const entry = entries[i];\n            if (entry.isIntersecting) {\n              triggerEvent(elt, \"intersect\");\n              break;\n            }\n          }\n        }, observerOptions);\n        observer.observe(asElement(elt));\n        addEventListener(asElement(elt), handler, nodeData, triggerSpec);\n      } else if (triggerSpec.trigger === \"load\") {\n        if (!maybeFilterEvent(triggerSpec, elt, makeEvent(\"load\", { elt }))) {\n          loadImmediately(asElement(elt), handler, nodeData, triggerSpec.delay);\n        }\n      } else if (triggerSpec.pollInterval > 0) {\n        nodeData.polling = true;\n        processPolling(asElement(elt), handler, triggerSpec);\n      } else {\n        addEventListener(elt, handler, nodeData, triggerSpec);\n      }\n    }\n    function shouldProcessHxOn(node) {\n      const elt = asElement(node);\n      if (!elt) {\n        return false;\n      }\n      const attributes = elt.attributes;\n      for (let j = 0; j < attributes.length; j++) {\n        const attrName = attributes[j].name;\n        if (startsWith(attrName, \"hx-on:\") || startsWith(attrName, \"data-hx-on:\") || startsWith(attrName, \"hx-on-\") || startsWith(attrName, \"data-hx-on-\")) {\n          return true;\n        }\n      }\n      return false;\n    }\n    const HX_ON_QUERY = new XPathEvaluator().createExpression('.//*[@*[ starts-with(name(), \"hx-on:\") or starts-with(name(), \"data-hx-on:\") or starts-with(name(), \"hx-on-\") or starts-with(name(), \"data-hx-on-\") ]]');\n    function processHXOnRoot(elt, elements) {\n      if (shouldProcessHxOn(elt)) {\n        elements.push(asElement(elt));\n      }\n      const iter = HX_ON_QUERY.evaluate(elt);\n      let node = null;\n      while (node = iter.iterateNext())\n        elements.push(asElement(node));\n    }\n    function findHxOnWildcardElements(elt) {\n      const elements = [];\n      if (elt instanceof DocumentFragment) {\n        for (const child of elt.childNodes) {\n          processHXOnRoot(child, elements);\n        }\n      } else {\n        processHXOnRoot(elt, elements);\n      }\n      return elements;\n    }\n    function findElementsToProcess(elt) {\n      if (elt.querySelectorAll) {\n        const boostedSelector = \", [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]\";\n        const extensionSelectors = [];\n        for (const e2 in extensions) {\n          const extension = extensions[e2];\n          if (extension.getSelectors) {\n            var selectors = extension.getSelectors();\n            if (selectors) {\n              extensionSelectors.push(selectors);\n            }\n          }\n        }\n        const results = elt.querySelectorAll(VERB_SELECTOR + boostedSelector + \", form, [type='submit'], [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger]\" + extensionSelectors.flat().map((s) => \", \" + s).join(\"\"));\n        return results;\n      } else {\n        return [];\n      }\n    }\n    function maybeSetLastButtonClicked(evt) {\n      const elt = (\n        /** @type {HTMLButtonElement|HTMLInputElement} */\n        closest(asElement(evt.target), \"button, input[type='submit']\")\n      );\n      const internalData = getRelatedFormData(evt);\n      if (internalData) {\n        internalData.lastButtonClicked = elt;\n      }\n    }\n    function maybeUnsetLastButtonClicked(evt) {\n      const internalData = getRelatedFormData(evt);\n      if (internalData) {\n        internalData.lastButtonClicked = null;\n      }\n    }\n    function getRelatedFormData(evt) {\n      const elt = closest(asElement(evt.target), \"button, input[type='submit']\");\n      if (!elt) {\n        return;\n      }\n      const form = resolveTarget(\"#\" + getRawAttribute(elt, \"form\"), elt.getRootNode()) || closest(elt, \"form\");\n      if (!form) {\n        return;\n      }\n      return getInternalData(form);\n    }\n    function initButtonTracking(elt) {\n      elt.addEventListener(\"click\", maybeSetLastButtonClicked);\n      elt.addEventListener(\"focusin\", maybeSetLastButtonClicked);\n      elt.addEventListener(\"focusout\", maybeUnsetLastButtonClicked);\n    }\n    function addHxOnEventHandler(elt, eventName, code) {\n      const nodeData = getInternalData(elt);\n      if (!Array.isArray(nodeData.onHandlers)) {\n        nodeData.onHandlers = [];\n      }\n      let func;\n      const listener = function(e2) {\n        maybeEval(elt, function() {\n          if (eltIsDisabled(elt)) {\n            return;\n          }\n          if (!func) {\n            func = new Function(\"event\", code);\n          }\n          func.call(elt, e2);\n        });\n      };\n      elt.addEventListener(eventName, listener);\n      nodeData.onHandlers.push({ event: eventName, listener });\n    }\n    function processHxOnWildcard(elt) {\n      deInitOnHandlers(elt);\n      for (let i = 0; i < elt.attributes.length; i++) {\n        const name2 = elt.attributes[i].name;\n        const value = elt.attributes[i].value;\n        if (startsWith(name2, \"hx-on\") || startsWith(name2, \"data-hx-on\")) {\n          const afterOnPosition = name2.indexOf(\"-on\") + 3;\n          const nextChar = name2.slice(afterOnPosition, afterOnPosition + 1);\n          if (nextChar === \"-\" || nextChar === \":\") {\n            let eventName = name2.slice(afterOnPosition + 1);\n            if (startsWith(eventName, \":\")) {\n              eventName = \"htmx\" + eventName;\n            } else if (startsWith(eventName, \"-\")) {\n              eventName = \"htmx:\" + eventName.slice(1);\n            } else if (startsWith(eventName, \"htmx-\")) {\n              eventName = \"htmx:\" + eventName.slice(5);\n            }\n            addHxOnEventHandler(elt, eventName, value);\n          }\n        }\n      }\n    }\n    function initNode(elt) {\n      if (closest(elt, htmx.config.disableSelector)) {\n        cleanUpElement(elt);\n        return;\n      }\n      const nodeData = getInternalData(elt);\n      if (nodeData.initHash !== attributeHash(elt)) {\n        deInitNode(elt);\n        nodeData.initHash = attributeHash(elt);\n        triggerEvent(elt, \"htmx:beforeProcessNode\");\n        if (elt.value) {\n          nodeData.lastValue = elt.value;\n        }\n        const triggerSpecs = getTriggerSpecs(elt);\n        const hasExplicitHttpAction = processVerbs(elt, nodeData, triggerSpecs);\n        if (!hasExplicitHttpAction) {\n          if (getClosestAttributeValue(elt, \"hx-boost\") === \"true\") {\n            boostElement(elt, nodeData, triggerSpecs);\n          } else if (hasAttribute(elt, \"hx-trigger\")) {\n            triggerSpecs.forEach(function(triggerSpec) {\n              addTriggerHandler(elt, triggerSpec, nodeData, function() {\n              });\n            });\n          }\n        }\n        if (elt.tagName === \"FORM\" || getRawAttribute(elt, \"type\") === \"submit\" && hasAttribute(elt, \"form\")) {\n          initButtonTracking(elt);\n        }\n        triggerEvent(elt, \"htmx:afterProcessNode\");\n      }\n    }\n    function processNode(elt) {\n      elt = resolveTarget(elt);\n      if (closest(elt, htmx.config.disableSelector)) {\n        cleanUpElement(elt);\n        return;\n      }\n      initNode(elt);\n      forEach(findElementsToProcess(elt), function(child) {\n        initNode(child);\n      });\n      forEach(findHxOnWildcardElements(elt), processHxOnWildcard);\n    }\n    function kebabEventName(str2) {\n      return str2.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\n    }\n    function makeEvent(eventName, detail) {\n      let evt;\n      if (window.CustomEvent && typeof window.CustomEvent === \"function\") {\n        evt = new CustomEvent(eventName, { bubbles: true, cancelable: true, composed: true, detail });\n      } else {\n        evt = getDocument().createEvent(\"CustomEvent\");\n        evt.initCustomEvent(eventName, true, true, detail);\n      }\n      return evt;\n    }\n    function triggerErrorEvent(elt, eventName, detail) {\n      triggerEvent(elt, eventName, mergeObjects({ error: eventName }, detail));\n    }\n    function ignoreEventForLogging(eventName) {\n      return eventName === \"htmx:afterProcessNode\";\n    }\n    function withExtensions(elt, toDo) {\n      forEach(getExtensions(elt), function(extension) {\n        try {\n          toDo(extension);\n        } catch (e2) {\n          logError(e2);\n        }\n      });\n    }\n    function logError(msg) {\n      if (console.error) {\n        console.error(msg);\n      } else if (console.log) {\n        console.log(\"ERROR: \", msg);\n      }\n    }\n    function triggerEvent(elt, eventName, detail) {\n      elt = resolveTarget(elt);\n      if (detail == null) {\n        detail = {};\n      }\n      detail.elt = elt;\n      const event = makeEvent(eventName, detail);\n      if (htmx.logger && !ignoreEventForLogging(eventName)) {\n        htmx.logger(elt, eventName, detail);\n      }\n      if (detail.error) {\n        logError(detail.error);\n        triggerEvent(elt, \"htmx:error\", { errorInfo: detail });\n      }\n      let eventResult = elt.dispatchEvent(event);\n      const kebabName = kebabEventName(eventName);\n      if (eventResult && kebabName !== eventName) {\n        const kebabedEvent = makeEvent(kebabName, event.detail);\n        eventResult = eventResult && elt.dispatchEvent(kebabedEvent);\n      }\n      withExtensions(asElement(elt), function(extension) {\n        eventResult = eventResult && (extension.onEvent(eventName, event) !== false && !event.defaultPrevented);\n      });\n      return eventResult;\n    }\n    let currentPathForHistory = location.pathname + location.search;\n    function getHistoryElement() {\n      const historyElt = getDocument().querySelector(\"[hx-history-elt],[data-hx-history-elt]\");\n      return historyElt || getDocument().body;\n    }\n    function saveToHistoryCache(url, rootElt) {\n      if (!canAccessLocalStorage()) {\n        return;\n      }\n      const innerHTML3 = cleanInnerHtmlForHistory(rootElt);\n      const title = getDocument().title;\n      const scroll = window.scrollY;\n      if (htmx.config.historyCacheSize <= 0) {\n        localStorage.removeItem(\"htmx-history-cache\");\n        return;\n      }\n      url = normalizePath(url);\n      const historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n      for (let i = 0; i < historyCache.length; i++) {\n        if (historyCache[i].url === url) {\n          historyCache.splice(i, 1);\n          break;\n        }\n      }\n      const newHistoryItem = { url, content: innerHTML3, title, scroll };\n      triggerEvent(getDocument().body, \"htmx:historyItemCreated\", { item: newHistoryItem, cache: historyCache });\n      historyCache.push(newHistoryItem);\n      while (historyCache.length > htmx.config.historyCacheSize) {\n        historyCache.shift();\n      }\n      while (historyCache.length > 0) {\n        try {\n          localStorage.setItem(\"htmx-history-cache\", JSON.stringify(historyCache));\n          break;\n        } catch (e2) {\n          triggerErrorEvent(getDocument().body, \"htmx:historyCacheError\", { cause: e2, cache: historyCache });\n          historyCache.shift();\n        }\n      }\n    }\n    function getCachedHistory(url) {\n      if (!canAccessLocalStorage()) {\n        return null;\n      }\n      url = normalizePath(url);\n      const historyCache = parseJSON(localStorage.getItem(\"htmx-history-cache\")) || [];\n      for (let i = 0; i < historyCache.length; i++) {\n        if (historyCache[i].url === url) {\n          return historyCache[i];\n        }\n      }\n      return null;\n    }\n    function cleanInnerHtmlForHistory(elt) {\n      const className = htmx.config.requestClass;\n      const clone = (\n        /** @type Element */\n        elt.cloneNode(true)\n      );\n      forEach(findAll(clone, \".\" + className), function(child) {\n        removeClassFromElement(child, className);\n      });\n      return clone.innerHTML;\n    }\n    function saveCurrentPageToHistory() {\n      const elt = getHistoryElement();\n      const path = currentPathForHistory || location.pathname + location.search;\n      let disableHistoryCache;\n      try {\n        disableHistoryCache = getDocument().querySelector('[hx-history=\"false\" i],[data-hx-history=\"false\" i]');\n      } catch (e2) {\n        disableHistoryCache = getDocument().querySelector('[hx-history=\"false\"],[data-hx-history=\"false\"]');\n      }\n      if (!disableHistoryCache) {\n        triggerEvent(getDocument().body, \"htmx:beforeHistorySave\", { path, historyElt: elt });\n        saveToHistoryCache(path, elt);\n      }\n      if (htmx.config.historyEnabled)\n        history.replaceState({ htmx: true }, getDocument().title, window.location.href);\n    }\n    function pushUrlIntoHistory(path) {\n      if (htmx.config.getCacheBusterParam) {\n        path = path.replace(/org\\.htmx\\.cache-buster=[^&]*&?/, \"\");\n        if (endsWith(path, \"&\") || endsWith(path, \"?\")) {\n          path = path.slice(0, -1);\n        }\n      }\n      if (htmx.config.historyEnabled) {\n        history.pushState({ htmx: true }, \"\", path);\n      }\n      currentPathForHistory = path;\n    }\n    function replaceUrlInHistory(path) {\n      if (htmx.config.historyEnabled)\n        history.replaceState({ htmx: true }, \"\", path);\n      currentPathForHistory = path;\n    }\n    function settleImmediately(tasks) {\n      forEach(tasks, function(task) {\n        task.call(void 0);\n      });\n    }\n    function loadHistoryFromServer(path) {\n      const request = new XMLHttpRequest();\n      const details = { path, xhr: request };\n      triggerEvent(getDocument().body, \"htmx:historyCacheMiss\", details);\n      request.open(\"GET\", path, true);\n      request.setRequestHeader(\"HX-Request\", \"true\");\n      request.setRequestHeader(\"HX-History-Restore-Request\", \"true\");\n      request.setRequestHeader(\"HX-Current-URL\", getDocument().location.href);\n      request.onload = function() {\n        if (this.status >= 200 && this.status < 400) {\n          triggerEvent(getDocument().body, \"htmx:historyCacheMissLoad\", details);\n          const fragment = makeFragment(this.response);\n          const content = fragment.querySelector(\"[hx-history-elt],[data-hx-history-elt]\") || fragment;\n          const historyElement = getHistoryElement();\n          const settleInfo = makeSettleInfo(historyElement);\n          handleTitle(fragment.title);\n          swapInnerHTML(historyElement, content, settleInfo);\n          settleImmediately(settleInfo.tasks);\n          currentPathForHistory = path;\n          triggerEvent(getDocument().body, \"htmx:historyRestore\", { path, cacheMiss: true, serverResponse: this.response });\n        } else {\n          triggerErrorEvent(getDocument().body, \"htmx:historyCacheMissLoadError\", details);\n        }\n      };\n      request.send();\n    }\n    function restoreHistory(path) {\n      saveCurrentPageToHistory();\n      path = path || location.pathname + location.search;\n      const cached = getCachedHistory(path);\n      if (cached) {\n        const fragment = makeFragment(cached.content);\n        const historyElement = getHistoryElement();\n        const settleInfo = makeSettleInfo(historyElement);\n        handleTitle(fragment.title);\n        swapInnerHTML(historyElement, fragment, settleInfo);\n        settleImmediately(settleInfo.tasks);\n        getWindow().setTimeout(function() {\n          window.scrollTo(0, cached.scroll);\n        }, 0);\n        currentPathForHistory = path;\n        triggerEvent(getDocument().body, \"htmx:historyRestore\", { path, item: cached });\n      } else {\n        if (htmx.config.refreshOnHistoryMiss) {\n          window.location.reload(true);\n        } else {\n          loadHistoryFromServer(path);\n        }\n      }\n    }\n    function addRequestIndicatorClasses(elt) {\n      let indicators = (\n        /** @type Element[] */\n        findAttributeTargets(elt, \"hx-indicator\")\n      );\n      if (indicators == null) {\n        indicators = [elt];\n      }\n      forEach(indicators, function(ic) {\n        const internalData = getInternalData(ic);\n        internalData.requestCount = (internalData.requestCount || 0) + 1;\n        ic.classList.add.call(ic.classList, htmx.config.requestClass);\n      });\n      return indicators;\n    }\n    function disableElements(elt) {\n      let disabledElts = (\n        /** @type Element[] */\n        findAttributeTargets(elt, \"hx-disabled-elt\")\n      );\n      if (disabledElts == null) {\n        disabledElts = [];\n      }\n      forEach(disabledElts, function(disabledElement) {\n        const internalData = getInternalData(disabledElement);\n        internalData.requestCount = (internalData.requestCount || 0) + 1;\n        disabledElement.setAttribute(\"disabled\", \"\");\n      });\n      return disabledElts;\n    }\n    function removeRequestIndicators(indicators, disabled) {\n      forEach(indicators, function(ic) {\n        const internalData = getInternalData(ic);\n        internalData.requestCount = (internalData.requestCount || 0) - 1;\n        if (internalData.requestCount === 0) {\n          ic.classList.remove.call(ic.classList, htmx.config.requestClass);\n        }\n      });\n      forEach(disabled, function(disabledElement) {\n        const internalData = getInternalData(disabledElement);\n        internalData.requestCount = (internalData.requestCount || 0) - 1;\n        if (internalData.requestCount === 0) {\n          disabledElement.removeAttribute(\"disabled\");\n        }\n      });\n    }\n    function haveSeenNode(processed, elt) {\n      for (let i = 0; i < processed.length; i++) {\n        const node = processed[i];\n        if (node.isSameNode(elt)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function shouldInclude(element) {\n      const elt = (\n        /** @type {HTMLInputElement} */\n        element\n      );\n      if (elt.name === \"\" || elt.name == null || elt.disabled || closest(elt, \"fieldset[disabled]\")) {\n        return false;\n      }\n      if (elt.type === \"button\" || elt.type === \"submit\" || elt.tagName === \"image\" || elt.tagName === \"reset\" || elt.tagName === \"file\") {\n        return false;\n      }\n      if (elt.type === \"checkbox\" || elt.type === \"radio\") {\n        return elt.checked;\n      }\n      return true;\n    }\n    function addValueToFormData(name2, value, formData) {\n      if (name2 != null && value != null) {\n        if (Array.isArray(value)) {\n          value.forEach(function(v) {\n            formData.append(name2, v);\n          });\n        } else {\n          formData.append(name2, value);\n        }\n      }\n    }\n    function removeValueFromFormData(name2, value, formData) {\n      if (name2 != null && value != null) {\n        let values = formData.getAll(name2);\n        if (Array.isArray(value)) {\n          values = values.filter((v) => value.indexOf(v) < 0);\n        } else {\n          values = values.filter((v) => v !== value);\n        }\n        formData.delete(name2);\n        forEach(values, (v) => formData.append(name2, v));\n      }\n    }\n    function processInputValue(processed, formData, errors, elt, validate) {\n      if (elt == null || haveSeenNode(processed, elt)) {\n        return;\n      } else {\n        processed.push(elt);\n      }\n      if (shouldInclude(elt)) {\n        const name2 = getRawAttribute(elt, \"name\");\n        let value = elt.value;\n        if (elt instanceof HTMLSelectElement && elt.multiple) {\n          value = toArray(elt.querySelectorAll(\"option:checked\")).map(function(e2) {\n            return (\n              /** @type HTMLOptionElement */\n              e2.value\n            );\n          });\n        }\n        if (elt instanceof HTMLInputElement && elt.files) {\n          value = toArray(elt.files);\n        }\n        addValueToFormData(name2, value, formData);\n        if (validate) {\n          validateElement(elt, errors);\n        }\n      }\n      if (elt instanceof HTMLFormElement) {\n        forEach(elt.elements, function(input) {\n          if (processed.indexOf(input) >= 0) {\n            removeValueFromFormData(input.name, input.value, formData);\n          } else {\n            processed.push(input);\n          }\n          if (validate) {\n            validateElement(input, errors);\n          }\n        });\n        new FormData(elt).forEach(function(value, name2) {\n          if (value instanceof File && value.name === \"\") {\n            return;\n          }\n          addValueToFormData(name2, value, formData);\n        });\n      }\n    }\n    function validateElement(elt, errors) {\n      const element = (\n        /** @type {HTMLElement & ElementInternals} */\n        elt\n      );\n      if (element.willValidate) {\n        triggerEvent(element, \"htmx:validation:validate\");\n        if (!element.checkValidity()) {\n          errors.push({ elt: element, message: element.validationMessage, validity: element.validity });\n          triggerEvent(element, \"htmx:validation:failed\", { message: element.validationMessage, validity: element.validity });\n        }\n      }\n    }\n    function overrideFormData(receiver, donor) {\n      for (const key of donor.keys()) {\n        receiver.delete(key);\n        donor.getAll(key).forEach(function(value) {\n          receiver.append(key, value);\n        });\n      }\n      return receiver;\n    }\n    function getInputValues(elt, verb) {\n      const processed = [];\n      const formData = new FormData();\n      const priorityFormData = new FormData();\n      const errors = [];\n      const internalData = getInternalData(elt);\n      if (internalData.lastButtonClicked && !bodyContains(internalData.lastButtonClicked)) {\n        internalData.lastButtonClicked = null;\n      }\n      let validate = elt instanceof HTMLFormElement && elt.noValidate !== true || getAttributeValue(elt, \"hx-validate\") === \"true\";\n      if (internalData.lastButtonClicked) {\n        validate = validate && internalData.lastButtonClicked.formNoValidate !== true;\n      }\n      if (verb !== \"get\") {\n        processInputValue(processed, priorityFormData, errors, closest(elt, \"form\"), validate);\n      }\n      processInputValue(processed, formData, errors, elt, validate);\n      if (internalData.lastButtonClicked || elt.tagName === \"BUTTON\" || elt.tagName === \"INPUT\" && getRawAttribute(elt, \"type\") === \"submit\") {\n        const button = internalData.lastButtonClicked || /** @type HTMLInputElement|HTMLButtonElement */\n        elt;\n        const name2 = getRawAttribute(button, \"name\");\n        addValueToFormData(name2, button.value, priorityFormData);\n      }\n      const includes = findAttributeTargets(elt, \"hx-include\");\n      forEach(includes, function(node) {\n        processInputValue(processed, formData, errors, asElement(node), validate);\n        if (!matches(node, \"form\")) {\n          forEach(asParentNode(node).querySelectorAll(INPUT_SELECTOR), function(descendant) {\n            processInputValue(processed, formData, errors, descendant, validate);\n          });\n        }\n      });\n      overrideFormData(formData, priorityFormData);\n      return { errors, formData, values: formDataProxy(formData) };\n    }\n    function appendParam(returnStr, name2, realValue) {\n      if (returnStr !== \"\") {\n        returnStr += \"&\";\n      }\n      if (String(realValue) === \"[object Object]\") {\n        realValue = JSON.stringify(realValue);\n      }\n      const s = encodeURIComponent(realValue);\n      returnStr += encodeURIComponent(name2) + \"=\" + s;\n      return returnStr;\n    }\n    function urlEncode(values) {\n      values = formDataFromObject(values);\n      let returnStr = \"\";\n      values.forEach(function(value, key) {\n        returnStr = appendParam(returnStr, key, value);\n      });\n      return returnStr;\n    }\n    function getHeaders(elt, target, prompt2) {\n      const headers = {\n        \"HX-Request\": \"true\",\n        \"HX-Trigger\": getRawAttribute(elt, \"id\"),\n        \"HX-Trigger-Name\": getRawAttribute(elt, \"name\"),\n        \"HX-Target\": getAttributeValue(target, \"id\"),\n        \"HX-Current-URL\": getDocument().location.href\n      };\n      getValuesForElement(elt, \"hx-headers\", false, headers);\n      if (prompt2 !== void 0) {\n        headers[\"HX-Prompt\"] = prompt2;\n      }\n      if (getInternalData(elt).boosted) {\n        headers[\"HX-Boosted\"] = \"true\";\n      }\n      return headers;\n    }\n    function filterValues(inputValues, elt) {\n      const paramsValue = getClosestAttributeValue(elt, \"hx-params\");\n      if (paramsValue) {\n        if (paramsValue === \"none\") {\n          return new FormData();\n        } else if (paramsValue === \"*\") {\n          return inputValues;\n        } else if (paramsValue.indexOf(\"not \") === 0) {\n          forEach(paramsValue.substr(4).split(\",\"), function(name2) {\n            name2 = name2.trim();\n            inputValues.delete(name2);\n          });\n          return inputValues;\n        } else {\n          const newValues = new FormData();\n          forEach(paramsValue.split(\",\"), function(name2) {\n            name2 = name2.trim();\n            if (inputValues.has(name2)) {\n              inputValues.getAll(name2).forEach(function(value) {\n                newValues.append(name2, value);\n              });\n            }\n          });\n          return newValues;\n        }\n      } else {\n        return inputValues;\n      }\n    }\n    function isAnchorLink(elt) {\n      return !!getRawAttribute(elt, \"href\") && getRawAttribute(elt, \"href\").indexOf(\"#\") >= 0;\n    }\n    function getSwapSpecification(elt, swapInfoOverride) {\n      const swapInfo = swapInfoOverride || getClosestAttributeValue(elt, \"hx-swap\");\n      const swapSpec = {\n        swapStyle: getInternalData(elt).boosted ? \"innerHTML\" : htmx.config.defaultSwapStyle,\n        swapDelay: htmx.config.defaultSwapDelay,\n        settleDelay: htmx.config.defaultSettleDelay\n      };\n      if (htmx.config.scrollIntoViewOnBoost && getInternalData(elt).boosted && !isAnchorLink(elt)) {\n        swapSpec.show = \"top\";\n      }\n      if (swapInfo) {\n        const split = splitOnWhitespace(swapInfo);\n        if (split.length > 0) {\n          for (let i = 0; i < split.length; i++) {\n            const value = split[i];\n            if (value.indexOf(\"swap:\") === 0) {\n              swapSpec.swapDelay = parseInterval(value.substr(5));\n            } else if (value.indexOf(\"settle:\") === 0) {\n              swapSpec.settleDelay = parseInterval(value.substr(7));\n            } else if (value.indexOf(\"transition:\") === 0) {\n              swapSpec.transition = value.substr(11) === \"true\";\n            } else if (value.indexOf(\"ignoreTitle:\") === 0) {\n              swapSpec.ignoreTitle = value.substr(12) === \"true\";\n            } else if (value.indexOf(\"scroll:\") === 0) {\n              const scrollSpec = value.substr(7);\n              var splitSpec = scrollSpec.split(\":\");\n              const scrollVal = splitSpec.pop();\n              var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n              swapSpec.scroll = scrollVal;\n              swapSpec.scrollTarget = selectorVal;\n            } else if (value.indexOf(\"show:\") === 0) {\n              const showSpec = value.substr(5);\n              var splitSpec = showSpec.split(\":\");\n              const showVal = splitSpec.pop();\n              var selectorVal = splitSpec.length > 0 ? splitSpec.join(\":\") : null;\n              swapSpec.show = showVal;\n              swapSpec.showTarget = selectorVal;\n            } else if (value.indexOf(\"focus-scroll:\") === 0) {\n              const focusScrollVal = value.substr(\"focus-scroll:\".length);\n              swapSpec.focusScroll = focusScrollVal == \"true\";\n            } else if (i == 0) {\n              swapSpec.swapStyle = value;\n            } else {\n              logError(\"Unknown modifier in hx-swap: \" + value);\n            }\n          }\n        }\n      }\n      return swapSpec;\n    }\n    function usesFormData(elt) {\n      return getClosestAttributeValue(elt, \"hx-encoding\") === \"multipart/form-data\" || matches(elt, \"form\") && getRawAttribute(elt, \"enctype\") === \"multipart/form-data\";\n    }\n    function encodeParamsForBody(xhr, elt, filteredParameters) {\n      let encodedParameters = null;\n      withExtensions(elt, function(extension) {\n        if (encodedParameters == null) {\n          encodedParameters = extension.encodeParameters(xhr, filteredParameters, elt);\n        }\n      });\n      if (encodedParameters != null) {\n        return encodedParameters;\n      } else {\n        if (usesFormData(elt)) {\n          return overrideFormData(new FormData(), formDataFromObject(filteredParameters));\n        } else {\n          return urlEncode(filteredParameters);\n        }\n      }\n    }\n    function makeSettleInfo(target) {\n      return { tasks: [], elts: [target] };\n    }\n    function updateScrollState(content, swapSpec) {\n      const first = content[0];\n      const last = content[content.length - 1];\n      if (swapSpec.scroll) {\n        var target = null;\n        if (swapSpec.scrollTarget) {\n          target = asElement(querySelectorExt(first, swapSpec.scrollTarget));\n        }\n        if (swapSpec.scroll === \"top\" && (first || target)) {\n          target = target || first;\n          target.scrollTop = 0;\n        }\n        if (swapSpec.scroll === \"bottom\" && (last || target)) {\n          target = target || last;\n          target.scrollTop = target.scrollHeight;\n        }\n      }\n      if (swapSpec.show) {\n        var target = null;\n        if (swapSpec.showTarget) {\n          let targetStr = swapSpec.showTarget;\n          if (swapSpec.showTarget === \"window\") {\n            targetStr = \"body\";\n          }\n          target = asElement(querySelectorExt(first, targetStr));\n        }\n        if (swapSpec.show === \"top\" && (first || target)) {\n          target = target || first;\n          target.scrollIntoView({ block: \"start\", behavior: htmx.config.scrollBehavior });\n        }\n        if (swapSpec.show === \"bottom\" && (last || target)) {\n          target = target || last;\n          target.scrollIntoView({ block: \"end\", behavior: htmx.config.scrollBehavior });\n        }\n      }\n    }\n    function getValuesForElement(elt, attr, evalAsDefault, values) {\n      if (values == null) {\n        values = {};\n      }\n      if (elt == null) {\n        return values;\n      }\n      const attributeValue = getAttributeValue(elt, attr);\n      if (attributeValue) {\n        let str2 = attributeValue.trim();\n        let evaluateValue = evalAsDefault;\n        if (str2 === \"unset\") {\n          return null;\n        }\n        if (str2.indexOf(\"javascript:\") === 0) {\n          str2 = str2.substr(11);\n          evaluateValue = true;\n        } else if (str2.indexOf(\"js:\") === 0) {\n          str2 = str2.substr(3);\n          evaluateValue = true;\n        }\n        if (str2.indexOf(\"{\") !== 0) {\n          str2 = \"{\" + str2 + \"}\";\n        }\n        let varsValues;\n        if (evaluateValue) {\n          varsValues = maybeEval(elt, function() {\n            return Function(\"return (\" + str2 + \")\")();\n          }, {});\n        } else {\n          varsValues = parseJSON(str2);\n        }\n        for (const key in varsValues) {\n          if (varsValues.hasOwnProperty(key)) {\n            if (values[key] == null) {\n              values[key] = varsValues[key];\n            }\n          }\n        }\n      }\n      return getValuesForElement(asElement(parentElt(elt)), attr, evalAsDefault, values);\n    }\n    function maybeEval(elt, toEval, defaultVal) {\n      if (htmx.config.allowEval) {\n        return toEval();\n      } else {\n        triggerErrorEvent(elt, \"htmx:evalDisallowedError\");\n        return defaultVal;\n      }\n    }\n    function getHXVarsForElement(elt, expressionVars) {\n      return getValuesForElement(elt, \"hx-vars\", true, expressionVars);\n    }\n    function getHXValsForElement(elt, expressionVars) {\n      return getValuesForElement(elt, \"hx-vals\", false, expressionVars);\n    }\n    function getExpressionVars(elt) {\n      return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt));\n    }\n    function safelySetHeaderValue(xhr, header, headerValue) {\n      if (headerValue !== null) {\n        try {\n          xhr.setRequestHeader(header, headerValue);\n        } catch (e2) {\n          xhr.setRequestHeader(header, encodeURIComponent(headerValue));\n          xhr.setRequestHeader(header + \"-URI-AutoEncoded\", \"true\");\n        }\n      }\n    }\n    function getPathFromResponse(xhr) {\n      if (xhr.responseURL && typeof URL !== \"undefined\") {\n        try {\n          const url = new URL(xhr.responseURL);\n          return url.pathname + url.search;\n        } catch (e2) {\n          triggerErrorEvent(getDocument().body, \"htmx:badResponseUrl\", { url: xhr.responseURL });\n        }\n      }\n    }\n    function hasHeader(xhr, regexp) {\n      return regexp.test(xhr.getAllResponseHeaders());\n    }\n    function ajaxHelper(verb, path, context) {\n      verb = /** @type HttpVerb */\n      verb.toLowerCase();\n      if (context) {\n        if (context instanceof Element || typeof context === \"string\") {\n          return issueAjaxRequest(verb, path, null, null, {\n            targetOverride: resolveTarget(context),\n            returnPromise: true\n          });\n        } else {\n          return issueAjaxRequest(\n            verb,\n            path,\n            resolveTarget(context.source),\n            context.event,\n            {\n              handler: context.handler,\n              headers: context.headers,\n              values: context.values,\n              targetOverride: resolveTarget(context.target),\n              swapOverride: context.swap,\n              select: context.select,\n              returnPromise: true\n            }\n          );\n        }\n      } else {\n        return issueAjaxRequest(verb, path, null, null, {\n          returnPromise: true\n        });\n      }\n    }\n    function hierarchyForElt(elt) {\n      const arr = [];\n      while (elt) {\n        arr.push(elt);\n        elt = elt.parentElement;\n      }\n      return arr;\n    }\n    function verifyPath(elt, path, requestConfig) {\n      let sameHost;\n      let url;\n      if (typeof URL === \"function\") {\n        url = new URL(path, document.location.href);\n        const origin = document.location.origin;\n        sameHost = origin === url.origin;\n      } else {\n        url = path;\n        sameHost = startsWith(path, document.location.origin);\n      }\n      if (htmx.config.selfRequestsOnly) {\n        if (!sameHost) {\n          return false;\n        }\n      }\n      return triggerEvent(elt, \"htmx:validateUrl\", mergeObjects({ url, sameHost }, requestConfig));\n    }\n    function formDataFromObject(obj) {\n      if (obj instanceof FormData)\n        return obj;\n      const formData = new FormData();\n      for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          if (typeof obj[key].forEach === \"function\") {\n            obj[key].forEach(function(v) {\n              formData.append(key, v);\n            });\n          } else if (typeof obj[key] === \"object\") {\n            formData.append(key, JSON.stringify(obj[key]));\n          } else {\n            formData.append(key, obj[key]);\n          }\n        }\n      }\n      return formData;\n    }\n    function formDataArrayProxy(formData, name2, array) {\n      return new Proxy(array, {\n        get: function(target, key) {\n          if (typeof key === \"number\")\n            return target[key];\n          if (key === \"length\")\n            return target.length;\n          if (key === \"push\") {\n            return function(value) {\n              target.push(value);\n              formData.append(name2, value);\n            };\n          }\n          if (typeof target[key] === \"function\") {\n            return function() {\n              target[key].apply(target, arguments);\n              formData.delete(name2);\n              target.forEach(function(v) {\n                formData.append(name2, v);\n              });\n            };\n          }\n          if (target[key] && target[key].length === 1) {\n            return target[key][0];\n          } else {\n            return target[key];\n          }\n        },\n        set: function(target, index, value) {\n          target[index] = value;\n          formData.delete(name2);\n          target.forEach(function(v) {\n            formData.append(name2, v);\n          });\n          return true;\n        }\n      });\n    }\n    function formDataProxy(formData) {\n      return new Proxy(formData, {\n        get: function(target, name2) {\n          if (typeof name2 === \"symbol\") {\n            return Reflect.get(target, name2);\n          }\n          if (name2 === \"toJSON\") {\n            return () => Object.fromEntries(formData);\n          }\n          if (name2 in target) {\n            if (typeof target[name2] === \"function\") {\n              return function() {\n                return formData[name2].apply(formData, arguments);\n              };\n            } else {\n              return target[name2];\n            }\n          }\n          const array = formData.getAll(name2);\n          if (array.length === 0) {\n            return void 0;\n          } else if (array.length === 1) {\n            return array[0];\n          } else {\n            return formDataArrayProxy(target, name2, array);\n          }\n        },\n        set: function(target, name2, value) {\n          if (typeof name2 !== \"string\") {\n            return false;\n          }\n          target.delete(name2);\n          if (typeof value.forEach === \"function\") {\n            value.forEach(function(v) {\n              target.append(name2, v);\n            });\n          } else {\n            target.append(name2, value);\n          }\n          return true;\n        },\n        deleteProperty: function(target, name2) {\n          if (typeof name2 === \"string\") {\n            target.delete(name2);\n          }\n          return true;\n        },\n        // Support Object.assign call from proxy\n        ownKeys: function(target) {\n          return Reflect.ownKeys(Object.fromEntries(target));\n        },\n        getOwnPropertyDescriptor: function(target, prop) {\n          return Reflect.getOwnPropertyDescriptor(Object.fromEntries(target), prop);\n        }\n      });\n    }\n    function issueAjaxRequest(verb, path, elt, event, etc, confirmed) {\n      let resolve = null;\n      let reject = null;\n      etc = etc != null ? etc : {};\n      if (etc.returnPromise && typeof Promise !== \"undefined\") {\n        var promise = new Promise(function(_resolve, _reject) {\n          resolve = _resolve;\n          reject = _reject;\n        });\n      }\n      if (elt == null) {\n        elt = getDocument().body;\n      }\n      const responseHandler = etc.handler || handleAjaxResponse;\n      const select = etc.select || null;\n      if (!bodyContains(elt)) {\n        maybeCall(resolve);\n        return promise;\n      }\n      const target = etc.targetOverride || asElement(getTarget(elt));\n      if (target == null || target == DUMMY_ELT) {\n        triggerErrorEvent(elt, \"htmx:targetError\", { target: getAttributeValue(elt, \"hx-target\") });\n        maybeCall(reject);\n        return promise;\n      }\n      let eltData = getInternalData(elt);\n      const submitter = eltData.lastButtonClicked;\n      if (submitter) {\n        const buttonPath = getRawAttribute(submitter, \"formaction\");\n        if (buttonPath != null) {\n          path = buttonPath;\n        }\n        const buttonVerb = getRawAttribute(submitter, \"formmethod\");\n        if (buttonVerb != null) {\n          if (buttonVerb.toLowerCase() !== \"dialog\") {\n            verb = /** @type HttpVerb */\n            buttonVerb;\n          }\n        }\n      }\n      const confirmQuestion = getClosestAttributeValue(elt, \"hx-confirm\");\n      if (confirmed === void 0) {\n        const issueRequest = function(skipConfirmation) {\n          return issueAjaxRequest(verb, path, elt, event, etc, !!skipConfirmation);\n        };\n        const confirmDetails = { target, elt, path, verb, triggeringEvent: event, etc, issueRequest, question: confirmQuestion };\n        if (triggerEvent(elt, \"htmx:confirm\", confirmDetails) === false) {\n          maybeCall(resolve);\n          return promise;\n        }\n      }\n      let syncElt = elt;\n      let syncStrategy = getClosestAttributeValue(elt, \"hx-sync\");\n      let queueStrategy = null;\n      let abortable = false;\n      if (syncStrategy) {\n        const syncStrings = syncStrategy.split(\":\");\n        const selector = syncStrings[0].trim();\n        if (selector === \"this\") {\n          syncElt = findThisElement(elt, \"hx-sync\");\n        } else {\n          syncElt = asElement(querySelectorExt(elt, selector));\n        }\n        syncStrategy = (syncStrings[1] || \"drop\").trim();\n        eltData = getInternalData(syncElt);\n        if (syncStrategy === \"drop\" && eltData.xhr && eltData.abortable !== true) {\n          maybeCall(resolve);\n          return promise;\n        } else if (syncStrategy === \"abort\") {\n          if (eltData.xhr) {\n            maybeCall(resolve);\n            return promise;\n          } else {\n            abortable = true;\n          }\n        } else if (syncStrategy === \"replace\") {\n          triggerEvent(syncElt, \"htmx:abort\");\n        } else if (syncStrategy.indexOf(\"queue\") === 0) {\n          const queueStrArray = syncStrategy.split(\" \");\n          queueStrategy = (queueStrArray[1] || \"last\").trim();\n        }\n      }\n      if (eltData.xhr) {\n        if (eltData.abortable) {\n          triggerEvent(syncElt, \"htmx:abort\");\n        } else {\n          if (queueStrategy == null) {\n            if (event) {\n              const eventData = getInternalData(event);\n              if (eventData && eventData.triggerSpec && eventData.triggerSpec.queue) {\n                queueStrategy = eventData.triggerSpec.queue;\n              }\n            }\n            if (queueStrategy == null) {\n              queueStrategy = \"last\";\n            }\n          }\n          if (eltData.queuedRequests == null) {\n            eltData.queuedRequests = [];\n          }\n          if (queueStrategy === \"first\" && eltData.queuedRequests.length === 0) {\n            eltData.queuedRequests.push(function() {\n              issueAjaxRequest(verb, path, elt, event, etc);\n            });\n          } else if (queueStrategy === \"all\") {\n            eltData.queuedRequests.push(function() {\n              issueAjaxRequest(verb, path, elt, event, etc);\n            });\n          } else if (queueStrategy === \"last\") {\n            eltData.queuedRequests = [];\n            eltData.queuedRequests.push(function() {\n              issueAjaxRequest(verb, path, elt, event, etc);\n            });\n          }\n          maybeCall(resolve);\n          return promise;\n        }\n      }\n      const xhr = new XMLHttpRequest();\n      eltData.xhr = xhr;\n      eltData.abortable = abortable;\n      const endRequestLock = function() {\n        eltData.xhr = null;\n        eltData.abortable = false;\n        if (eltData.queuedRequests != null && eltData.queuedRequests.length > 0) {\n          const queuedRequest = eltData.queuedRequests.shift();\n          queuedRequest();\n        }\n      };\n      const promptQuestion = getClosestAttributeValue(elt, \"hx-prompt\");\n      if (promptQuestion) {\n        var promptResponse = prompt(promptQuestion);\n        if (promptResponse === null || !triggerEvent(elt, \"htmx:prompt\", { prompt: promptResponse, target })) {\n          maybeCall(resolve);\n          endRequestLock();\n          return promise;\n        }\n      }\n      if (confirmQuestion && !confirmed) {\n        if (!confirm(confirmQuestion)) {\n          maybeCall(resolve);\n          endRequestLock();\n          return promise;\n        }\n      }\n      let headers = getHeaders(elt, target, promptResponse);\n      if (verb !== \"get\" && !usesFormData(elt)) {\n        headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n      }\n      if (etc.headers) {\n        headers = mergeObjects(headers, etc.headers);\n      }\n      const results = getInputValues(elt, verb);\n      let errors = results.errors;\n      const rawFormData = results.formData;\n      if (etc.values) {\n        overrideFormData(rawFormData, formDataFromObject(etc.values));\n      }\n      const expressionVars = formDataFromObject(getExpressionVars(elt));\n      const allFormData = overrideFormData(rawFormData, expressionVars);\n      let filteredFormData = filterValues(allFormData, elt);\n      if (htmx.config.getCacheBusterParam && verb === \"get\") {\n        filteredFormData.set(\"org.htmx.cache-buster\", getRawAttribute(target, \"id\") || \"true\");\n      }\n      if (path == null || path === \"\") {\n        path = getDocument().location.href;\n      }\n      const requestAttrValues = getValuesForElement(elt, \"hx-request\");\n      const eltIsBoosted = getInternalData(elt).boosted;\n      let useUrlParams = htmx.config.methodsThatUseUrlParams.indexOf(verb) >= 0;\n      const requestConfig = {\n        boosted: eltIsBoosted,\n        useUrlParams,\n        formData: filteredFormData,\n        parameters: formDataProxy(filteredFormData),\n        unfilteredFormData: allFormData,\n        unfilteredParameters: formDataProxy(allFormData),\n        headers,\n        target,\n        verb,\n        errors,\n        withCredentials: etc.credentials || requestAttrValues.credentials || htmx.config.withCredentials,\n        timeout: etc.timeout || requestAttrValues.timeout || htmx.config.timeout,\n        path,\n        triggeringEvent: event\n      };\n      if (!triggerEvent(elt, \"htmx:configRequest\", requestConfig)) {\n        maybeCall(resolve);\n        endRequestLock();\n        return promise;\n      }\n      path = requestConfig.path;\n      verb = requestConfig.verb;\n      headers = requestConfig.headers;\n      filteredFormData = formDataFromObject(requestConfig.parameters);\n      errors = requestConfig.errors;\n      useUrlParams = requestConfig.useUrlParams;\n      if (errors && errors.length > 0) {\n        triggerEvent(elt, \"htmx:validation:halted\", requestConfig);\n        maybeCall(resolve);\n        endRequestLock();\n        return promise;\n      }\n      const splitPath = path.split(\"#\");\n      const pathNoAnchor = splitPath[0];\n      const anchor = splitPath[1];\n      let finalPath = path;\n      if (useUrlParams) {\n        finalPath = pathNoAnchor;\n        const hasValues = !filteredFormData.keys().next().done;\n        if (hasValues) {\n          if (finalPath.indexOf(\"?\") < 0) {\n            finalPath += \"?\";\n          } else {\n            finalPath += \"&\";\n          }\n          finalPath += urlEncode(filteredFormData);\n          if (anchor) {\n            finalPath += \"#\" + anchor;\n          }\n        }\n      }\n      if (!verifyPath(elt, finalPath, requestConfig)) {\n        triggerErrorEvent(elt, \"htmx:invalidPath\", requestConfig);\n        maybeCall(reject);\n        return promise;\n      }\n      xhr.open(verb.toUpperCase(), finalPath, true);\n      xhr.overrideMimeType(\"text/html\");\n      xhr.withCredentials = requestConfig.withCredentials;\n      xhr.timeout = requestConfig.timeout;\n      if (requestAttrValues.noHeaders) {\n      } else {\n        for (const header in headers) {\n          if (headers.hasOwnProperty(header)) {\n            const headerValue = headers[header];\n            safelySetHeaderValue(xhr, header, headerValue);\n          }\n        }\n      }\n      const responseInfo = {\n        xhr,\n        target,\n        requestConfig,\n        etc,\n        boosted: eltIsBoosted,\n        select,\n        pathInfo: {\n          requestPath: path,\n          finalRequestPath: finalPath,\n          responsePath: null,\n          anchor\n        }\n      };\n      xhr.onload = function() {\n        try {\n          const hierarchy = hierarchyForElt(elt);\n          responseInfo.pathInfo.responsePath = getPathFromResponse(xhr);\n          responseHandler(elt, responseInfo);\n          removeRequestIndicators(indicators, disableElts);\n          triggerEvent(elt, \"htmx:afterRequest\", responseInfo);\n          triggerEvent(elt, \"htmx:afterOnLoad\", responseInfo);\n          if (!bodyContains(elt)) {\n            let secondaryTriggerElt = null;\n            while (hierarchy.length > 0 && secondaryTriggerElt == null) {\n              const parentEltInHierarchy = hierarchy.shift();\n              if (bodyContains(parentEltInHierarchy)) {\n                secondaryTriggerElt = parentEltInHierarchy;\n              }\n            }\n            if (secondaryTriggerElt) {\n              triggerEvent(secondaryTriggerElt, \"htmx:afterRequest\", responseInfo);\n              triggerEvent(secondaryTriggerElt, \"htmx:afterOnLoad\", responseInfo);\n            }\n          }\n          maybeCall(resolve);\n          endRequestLock();\n        } catch (e2) {\n          triggerErrorEvent(elt, \"htmx:onLoadError\", mergeObjects({ error: e2 }, responseInfo));\n          throw e2;\n        }\n      };\n      xhr.onerror = function() {\n        removeRequestIndicators(indicators, disableElts);\n        triggerErrorEvent(elt, \"htmx:afterRequest\", responseInfo);\n        triggerErrorEvent(elt, \"htmx:sendError\", responseInfo);\n        maybeCall(reject);\n        endRequestLock();\n      };\n      xhr.onabort = function() {\n        removeRequestIndicators(indicators, disableElts);\n        triggerErrorEvent(elt, \"htmx:afterRequest\", responseInfo);\n        triggerErrorEvent(elt, \"htmx:sendAbort\", responseInfo);\n        maybeCall(reject);\n        endRequestLock();\n      };\n      xhr.ontimeout = function() {\n        removeRequestIndicators(indicators, disableElts);\n        triggerErrorEvent(elt, \"htmx:afterRequest\", responseInfo);\n        triggerErrorEvent(elt, \"htmx:timeout\", responseInfo);\n        maybeCall(reject);\n        endRequestLock();\n      };\n      if (!triggerEvent(elt, \"htmx:beforeRequest\", responseInfo)) {\n        maybeCall(resolve);\n        endRequestLock();\n        return promise;\n      }\n      var indicators = addRequestIndicatorClasses(elt);\n      var disableElts = disableElements(elt);\n      forEach([\"loadstart\", \"loadend\", \"progress\", \"abort\"], function(eventName) {\n        forEach([xhr, xhr.upload], function(target2) {\n          target2.addEventListener(eventName, function(event2) {\n            triggerEvent(elt, \"htmx:xhr:\" + eventName, {\n              lengthComputable: event2.lengthComputable,\n              loaded: event2.loaded,\n              total: event2.total\n            });\n          });\n        });\n      });\n      triggerEvent(elt, \"htmx:beforeSend\", responseInfo);\n      const params = useUrlParams ? null : encodeParamsForBody(xhr, elt, filteredFormData);\n      xhr.send(params);\n      return promise;\n    }\n    function determineHistoryUpdates(elt, responseInfo) {\n      const xhr = responseInfo.xhr;\n      let pathFromHeaders = null;\n      let typeFromHeaders = null;\n      if (hasHeader(xhr, /HX-Push:/i)) {\n        pathFromHeaders = xhr.getResponseHeader(\"HX-Push\");\n        typeFromHeaders = \"push\";\n      } else if (hasHeader(xhr, /HX-Push-Url:/i)) {\n        pathFromHeaders = xhr.getResponseHeader(\"HX-Push-Url\");\n        typeFromHeaders = \"push\";\n      } else if (hasHeader(xhr, /HX-Replace-Url:/i)) {\n        pathFromHeaders = xhr.getResponseHeader(\"HX-Replace-Url\");\n        typeFromHeaders = \"replace\";\n      }\n      if (pathFromHeaders) {\n        if (pathFromHeaders === \"false\") {\n          return {};\n        } else {\n          return {\n            type: typeFromHeaders,\n            path: pathFromHeaders\n          };\n        }\n      }\n      const requestPath = responseInfo.pathInfo.finalRequestPath;\n      const responsePath = responseInfo.pathInfo.responsePath;\n      const pushUrl = getClosestAttributeValue(elt, \"hx-push-url\");\n      const replaceUrl = getClosestAttributeValue(elt, \"hx-replace-url\");\n      const elementIsBoosted = getInternalData(elt).boosted;\n      let saveType = null;\n      let path = null;\n      if (pushUrl) {\n        saveType = \"push\";\n        path = pushUrl;\n      } else if (replaceUrl) {\n        saveType = \"replace\";\n        path = replaceUrl;\n      } else if (elementIsBoosted) {\n        saveType = \"push\";\n        path = responsePath || requestPath;\n      }\n      if (path) {\n        if (path === \"false\") {\n          return {};\n        }\n        if (path === \"true\") {\n          path = responsePath || requestPath;\n        }\n        if (responseInfo.pathInfo.anchor && path.indexOf(\"#\") === -1) {\n          path = path + \"#\" + responseInfo.pathInfo.anchor;\n        }\n        return {\n          type: saveType,\n          path\n        };\n      } else {\n        return {};\n      }\n    }\n    function codeMatches(responseHandlingConfig, status) {\n      var regExp = new RegExp(responseHandlingConfig.code);\n      return regExp.test(status.toString(10));\n    }\n    function resolveResponseHandling(xhr) {\n      for (var i = 0; i < htmx.config.responseHandling.length; i++) {\n        var responseHandlingElement = htmx.config.responseHandling[i];\n        if (codeMatches(responseHandlingElement, xhr.status)) {\n          return responseHandlingElement;\n        }\n      }\n      return {\n        swap: false\n      };\n    }\n    function handleTitle(title) {\n      if (title) {\n        const titleElt = find(\"title\");\n        if (titleElt) {\n          titleElt.innerHTML = title;\n        } else {\n          window.document.title = title;\n        }\n      }\n    }\n    function handleAjaxResponse(elt, responseInfo) {\n      const xhr = responseInfo.xhr;\n      let target = responseInfo.target;\n      const etc = responseInfo.etc;\n      const responseInfoSelect = responseInfo.select;\n      if (!triggerEvent(elt, \"htmx:beforeOnLoad\", responseInfo))\n        return;\n      if (hasHeader(xhr, /HX-Trigger:/i)) {\n        handleTriggerHeader(xhr, \"HX-Trigger\", elt);\n      }\n      if (hasHeader(xhr, /HX-Location:/i)) {\n        saveCurrentPageToHistory();\n        let redirectPath = xhr.getResponseHeader(\"HX-Location\");\n        var redirectSwapSpec;\n        if (redirectPath.indexOf(\"{\") === 0) {\n          redirectSwapSpec = parseJSON(redirectPath);\n          redirectPath = redirectSwapSpec.path;\n          delete redirectSwapSpec.path;\n        }\n        ajaxHelper(\"get\", redirectPath, redirectSwapSpec).then(function() {\n          pushUrlIntoHistory(redirectPath);\n        });\n        return;\n      }\n      const shouldRefresh = hasHeader(xhr, /HX-Refresh:/i) && xhr.getResponseHeader(\"HX-Refresh\") === \"true\";\n      if (hasHeader(xhr, /HX-Redirect:/i)) {\n        location.href = xhr.getResponseHeader(\"HX-Redirect\");\n        shouldRefresh && location.reload();\n        return;\n      }\n      if (shouldRefresh) {\n        location.reload();\n        return;\n      }\n      if (hasHeader(xhr, /HX-Retarget:/i)) {\n        if (xhr.getResponseHeader(\"HX-Retarget\") === \"this\") {\n          responseInfo.target = elt;\n        } else {\n          responseInfo.target = asElement(querySelectorExt(elt, xhr.getResponseHeader(\"HX-Retarget\")));\n        }\n      }\n      const historyUpdate = determineHistoryUpdates(elt, responseInfo);\n      const responseHandling = resolveResponseHandling(xhr);\n      const shouldSwap = responseHandling.swap;\n      let isError2 = !!responseHandling.error;\n      let ignoreTitle = htmx.config.ignoreTitle || responseHandling.ignoreTitle;\n      let selectOverride = responseHandling.select;\n      if (responseHandling.target) {\n        responseInfo.target = asElement(querySelectorExt(elt, responseHandling.target));\n      }\n      var swapOverride = etc.swapOverride;\n      if (swapOverride == null && responseHandling.swapOverride) {\n        swapOverride = responseHandling.swapOverride;\n      }\n      if (hasHeader(xhr, /HX-Retarget:/i)) {\n        if (xhr.getResponseHeader(\"HX-Retarget\") === \"this\") {\n          responseInfo.target = elt;\n        } else {\n          responseInfo.target = asElement(querySelectorExt(elt, xhr.getResponseHeader(\"HX-Retarget\")));\n        }\n      }\n      if (hasHeader(xhr, /HX-Reswap:/i)) {\n        swapOverride = xhr.getResponseHeader(\"HX-Reswap\");\n      }\n      var serverResponse = xhr.response;\n      var beforeSwapDetails = mergeObjects({\n        shouldSwap,\n        serverResponse,\n        isError: isError2,\n        ignoreTitle,\n        selectOverride\n      }, responseInfo);\n      if (responseHandling.event && !triggerEvent(target, responseHandling.event, beforeSwapDetails))\n        return;\n      if (!triggerEvent(target, \"htmx:beforeSwap\", beforeSwapDetails))\n        return;\n      target = beforeSwapDetails.target;\n      serverResponse = beforeSwapDetails.serverResponse;\n      isError2 = beforeSwapDetails.isError;\n      ignoreTitle = beforeSwapDetails.ignoreTitle;\n      selectOverride = beforeSwapDetails.selectOverride;\n      responseInfo.target = target;\n      responseInfo.failed = isError2;\n      responseInfo.successful = !isError2;\n      if (beforeSwapDetails.shouldSwap) {\n        if (xhr.status === 286) {\n          cancelPolling(elt);\n        }\n        withExtensions(elt, function(extension) {\n          serverResponse = extension.transformResponse(serverResponse, xhr, elt);\n        });\n        if (historyUpdate.type) {\n          saveCurrentPageToHistory();\n        }\n        if (hasHeader(xhr, /HX-Reswap:/i)) {\n          swapOverride = xhr.getResponseHeader(\"HX-Reswap\");\n        }\n        var swapSpec = getSwapSpecification(elt, swapOverride);\n        if (!swapSpec.hasOwnProperty(\"ignoreTitle\")) {\n          swapSpec.ignoreTitle = ignoreTitle;\n        }\n        target.classList.add(htmx.config.swappingClass);\n        let settleResolve = null;\n        let settleReject = null;\n        if (responseInfoSelect) {\n          selectOverride = responseInfoSelect;\n        }\n        if (hasHeader(xhr, /HX-Reselect:/i)) {\n          selectOverride = xhr.getResponseHeader(\"HX-Reselect\");\n        }\n        const selectOOB = getClosestAttributeValue(elt, \"hx-select-oob\");\n        const select = getClosestAttributeValue(elt, \"hx-select\");\n        let doSwap = function() {\n          try {\n            if (historyUpdate.type) {\n              triggerEvent(getDocument().body, \"htmx:beforeHistoryUpdate\", mergeObjects({ history: historyUpdate }, responseInfo));\n              if (historyUpdate.type === \"push\") {\n                pushUrlIntoHistory(historyUpdate.path);\n                triggerEvent(getDocument().body, \"htmx:pushedIntoHistory\", { path: historyUpdate.path });\n              } else {\n                replaceUrlInHistory(historyUpdate.path);\n                triggerEvent(getDocument().body, \"htmx:replacedInHistory\", { path: historyUpdate.path });\n              }\n            }\n            swap(target, serverResponse, swapSpec, {\n              select: selectOverride || select,\n              selectOOB,\n              eventInfo: responseInfo,\n              anchor: responseInfo.pathInfo.anchor,\n              contextElement: elt,\n              afterSwapCallback: function() {\n                if (hasHeader(xhr, /HX-Trigger-After-Swap:/i)) {\n                  let finalElt = elt;\n                  if (!bodyContains(elt)) {\n                    finalElt = getDocument().body;\n                  }\n                  handleTriggerHeader(xhr, \"HX-Trigger-After-Swap\", finalElt);\n                }\n              },\n              afterSettleCallback: function() {\n                if (hasHeader(xhr, /HX-Trigger-After-Settle:/i)) {\n                  let finalElt = elt;\n                  if (!bodyContains(elt)) {\n                    finalElt = getDocument().body;\n                  }\n                  handleTriggerHeader(xhr, \"HX-Trigger-After-Settle\", finalElt);\n                }\n                maybeCall(settleResolve);\n              }\n            });\n          } catch (e2) {\n            triggerErrorEvent(elt, \"htmx:swapError\", responseInfo);\n            maybeCall(settleReject);\n            throw e2;\n          }\n        };\n        let shouldTransition = htmx.config.globalViewTransitions;\n        if (swapSpec.hasOwnProperty(\"transition\")) {\n          shouldTransition = swapSpec.transition;\n        }\n        if (shouldTransition && triggerEvent(elt, \"htmx:beforeTransition\", responseInfo) && typeof Promise !== \"undefined\" && // @ts-ignore experimental feature atm\n        document.startViewTransition) {\n          const settlePromise = new Promise(function(_resolve, _reject) {\n            settleResolve = _resolve;\n            settleReject = _reject;\n          });\n          const innerDoSwap = doSwap;\n          doSwap = function() {\n            document.startViewTransition(function() {\n              innerDoSwap();\n              return settlePromise;\n            });\n          };\n        }\n        if (swapSpec.swapDelay > 0) {\n          getWindow().setTimeout(doSwap, swapSpec.swapDelay);\n        } else {\n          doSwap();\n        }\n      }\n      if (isError2) {\n        triggerErrorEvent(elt, \"htmx:responseError\", mergeObjects({ error: \"Response Status Error Code \" + xhr.status + \" from \" + responseInfo.pathInfo.requestPath }, responseInfo));\n      }\n    }\n    const extensions = {};\n    function extensionBase() {\n      return {\n        init: function(api) {\n          return null;\n        },\n        getSelectors: function() {\n          return null;\n        },\n        onEvent: function(name2, evt) {\n          return true;\n        },\n        transformResponse: function(text, xhr, elt) {\n          return text;\n        },\n        isInlineSwap: function(swapStyle) {\n          return false;\n        },\n        handleSwap: function(swapStyle, target, fragment, settleInfo) {\n          return false;\n        },\n        encodeParameters: function(xhr, parameters, elt) {\n          return null;\n        }\n      };\n    }\n    function defineExtension(name2, extension) {\n      if (extension.init) {\n        extension.init(internalAPI);\n      }\n      extensions[name2] = mergeObjects(extensionBase(), extension);\n    }\n    function removeExtension(name2) {\n      delete extensions[name2];\n    }\n    function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {\n      if (extensionsToReturn == void 0) {\n        extensionsToReturn = [];\n      }\n      if (elt == void 0) {\n        return extensionsToReturn;\n      }\n      if (extensionsToIgnore == void 0) {\n        extensionsToIgnore = [];\n      }\n      const extensionsForElement = getAttributeValue(elt, \"hx-ext\");\n      if (extensionsForElement) {\n        forEach(extensionsForElement.split(\",\"), function(extensionName) {\n          extensionName = extensionName.replace(/ /g, \"\");\n          if (extensionName.slice(0, 7) == \"ignore:\") {\n            extensionsToIgnore.push(extensionName.slice(7));\n            return;\n          }\n          if (extensionsToIgnore.indexOf(extensionName) < 0) {\n            const extension = extensions[extensionName];\n            if (extension && extensionsToReturn.indexOf(extension) < 0) {\n              extensionsToReturn.push(extension);\n            }\n          }\n        });\n      }\n      return getExtensions(asElement(parentElt(elt)), extensionsToReturn, extensionsToIgnore);\n    }\n    var isReady = false;\n    getDocument().addEventListener(\"DOMContentLoaded\", function() {\n      isReady = true;\n    });\n    function ready(fn2) {\n      if (isReady || getDocument().readyState === \"complete\") {\n        fn2();\n      } else {\n        getDocument().addEventListener(\"DOMContentLoaded\", fn2);\n      }\n    }\n    function insertIndicatorStyles() {\n      if (htmx.config.includeIndicatorStyles !== false) {\n        const nonceAttribute = htmx.config.inlineStyleNonce ? ` nonce=\"${htmx.config.inlineStyleNonce}\"` : \"\";\n        getDocument().head.insertAdjacentHTML(\n          \"beforeend\",\n          \"<style\" + nonceAttribute + \">      .\" + htmx.config.indicatorClass + \"{opacity:0}      .\" + htmx.config.requestClass + \" .\" + htmx.config.indicatorClass + \"{opacity:1; transition: opacity 200ms ease-in;}      .\" + htmx.config.requestClass + \".\" + htmx.config.indicatorClass + \"{opacity:1; transition: opacity 200ms ease-in;}      </style>\"\n        );\n      }\n    }\n    function getMetaConfig() {\n      const element = getDocument().querySelector('meta[name=\"htmx-config\"]');\n      if (element) {\n        return parseJSON(element.content);\n      } else {\n        return null;\n      }\n    }\n    function mergeMetaConfig() {\n      const metaConfig = getMetaConfig();\n      if (metaConfig) {\n        htmx.config = mergeObjects(htmx.config, metaConfig);\n      }\n    }\n    ready(function() {\n      mergeMetaConfig();\n      insertIndicatorStyles();\n      let body = getDocument().body;\n      processNode(body);\n      const restoredElts = getDocument().querySelectorAll(\n        \"[hx-trigger='restored'],[data-hx-trigger='restored']\"\n      );\n      body.addEventListener(\"htmx:abort\", function(evt) {\n        const target = evt.target;\n        const internalData = getInternalData(target);\n        if (internalData && internalData.xhr) {\n          internalData.xhr.abort();\n        }\n      });\n      const originalPopstate = window.onpopstate ? window.onpopstate.bind(window) : null;\n      window.onpopstate = function(event) {\n        if (event.state && event.state.htmx) {\n          restoreHistory();\n          forEach(restoredElts, function(elt) {\n            triggerEvent(elt, \"htmx:restored\", {\n              document: getDocument(),\n              triggerEvent\n            });\n          });\n        } else {\n          if (originalPopstate) {\n            originalPopstate(event);\n          }\n        }\n      };\n      getWindow().setTimeout(function() {\n        triggerEvent(body, \"htmx:load\", {});\n        body = null;\n      }, 0);\n    });\n    return htmx;\n  }();\n  var htmx_esm_default = htmx2;\n\n  // js/base.ts\n  var import_bulma_toast = __toESM(require_bulma_toast_min());\n\n  // js/dao.ts\n  var store = __toESM(require_store2());\n  var prefs = store.namespace(\"preferences\");\n  var defaults = {\n    papLevel: \"white\",\n    emailSubject: \"Phishing site: {{Domain}}\",\n    emailBody: `To whom it may concern,\n\nThe following website recently came to my attention: {{URL}}\n\nDespite what it is pretending, this is a phishing site and not the official website.\n\nYou are providing services to the people operating the Website while it is very obviously being used for fraud.\nI'm writing to request that you take it down as soon as possible.\n\nYours faithfully`,\n    ccEmail: \"\",\n    autoCopyURL: \"true\"\n  };\n  function getPreference(key) {\n    return prefs.get(key, defaults[key]);\n  }\n\n  // js/mustache.js\n  function mustache(template, self2, parent, invert) {\n    var render2 = mustache;\n    var output = \"\";\n    var i;\n    function get(ctx2, path) {\n      path = path.pop ? path : path.split(\".\");\n      ctx2 = ctx2[path.shift()];\n      ctx2 = ctx2 != null ? ctx2 : \"\";\n      return 0 in path ? get(ctx2, path) : ctx2;\n    }\n    self2 = Array.isArray(self2) ? self2 : self2 ? [self2] : [];\n    self2 = invert ? 0 in self2 ? [] : [1] : self2;\n    for (i = 0; i < self2.length; i++) {\n      var childCode = \"\";\n      var depth = 0;\n      var inverted;\n      var ctx = typeof self2[i] == \"object\" ? self2[i] : {};\n      ctx = Object.assign({}, parent, ctx);\n      ctx[\"\"] = { \"\": self2[i] };\n      template.replace(\n        /([\\s\\S]*?)({{((\\/)|(\\^)|#)(.*?)}}|$)/g,\n        function(match, code, y, z, close2, invert2, name2) {\n          if (!depth) {\n            output += code.replace(\n              /{{{(.*?)}}}|{{(!?)(&?)(>?)(.*?)}}/g,\n              function(match2, raw, comment, isRaw, partial, name3) {\n                return raw ? get(ctx, raw) : isRaw ? get(ctx, name3) : partial ? render2(get(ctx, name3), ctx) : !comment ? new Option(get(ctx, name3)).innerHTML : \"\";\n              }\n            );\n            inverted = invert2;\n          } else {\n            childCode += depth && !close2 || depth > 1 ? match : code;\n          }\n          if (close2) {\n            if (!--depth) {\n              name2 = get(ctx, name2);\n              if (/^f/.test(typeof name2)) {\n                output += name2.call(ctx, childCode, function(template2) {\n                  return render2(template2, ctx);\n                });\n              } else {\n                output += render2(childCode, name2, ctx, inverted);\n              }\n              childCode = \"\";\n            }\n          } else {\n            ++depth;\n          }\n        }\n      );\n    }\n    return output;\n  }\n\n  // js/modals.ts\n  function closeModal($el) {\n    $el.classList.remove(\"is-active\");\n  }\n  function closeAllModals() {\n    (document.querySelectorAll(\".modal\") || []).forEach(($modal) => {\n      closeModal($modal);\n    });\n  }\n  document.addEventListener(\"keydown\", (event) => {\n    const e2 = event || window.event;\n    if (e2.keyCode === 27) {\n      closeAllModals();\n    }\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    (fragment.querySelectorAll(\".modal-trigger\") || []).forEach(($trigger) => {\n      const modal = $trigger.dataset.target;\n      const $target = document.getElementById(modal);\n      $trigger.addEventListener(\"click\", () => {\n        $target.classList.add(\"is-active\");\n      });\n    });\n    (fragment.querySelectorAll(\".modal-background, .modal-close, .modal-card-head .delete\") || []).forEach(($close) => {\n      const $target = $close.closest(\".modal\");\n      $close.addEventListener(\"click\", () => {\n        closeModal($target);\n      });\n    });\n  });\n\n  // js/dropdowns.ts\n  function closeAll(except) {\n    document.querySelectorAll(\"[aria-controls][aria-expanded]\").forEach((el) => {\n      if (except.id == el.id) {\n        return;\n      }\n      closeToggle(el);\n    });\n  }\n  function buttonTarget(el) {\n    return document.getElementById(el.getAttribute(\"aria-controls\"));\n  }\n  function toggleToggle(el) {\n    closeAll(el);\n    buttonTarget(el).classList.toggle(\"tw-hidden\");\n    updateARIA(el);\n  }\n  function closeToggle(el) {\n    buttonTarget(el).classList.add(\"tw-hidden\");\n    updateARIA(el);\n  }\n  function updateARIA(el) {\n    const $target = buttonTarget(el);\n    el.setAttribute(\"aria-expanded\", (!$target.classList.contains(\"tw-hidden\")).toString());\n  }\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[aria-controls][aria-expanded]\").forEach((el) => {\n      if (el.hasAttribute(\"data-toggle-element\")) {\n        return;\n      }\n      el.addEventListener(\"click\", (e2) => {\n        e2.stopPropagation();\n        toggleToggle(el);\n      });\n    });\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    if (fragment.nodeName != \"BODY\") {\n      return;\n    }\n    fragment.addEventListener(\"click\", (e2) => {\n      if (Array.from(document.querySelectorAll(\"[role=menu],[aria-labelledby]\")).some((el) => {\n        return el.contains(e2.target);\n      })) {\n        return;\n      }\n      document.querySelectorAll(\"[aria-controls][aria-expanded=true]\").forEach((el) => {\n        const $target = document.getElementById(el.getAttribute(\"aria-controls\"));\n        $target.classList.add(\"tw-hidden\");\n        el.setAttribute(\"aria-expanded\", \"false\");\n      });\n    });\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    const $navbarBurgers = Array.prototype.slice.call(\n      fragment.querySelectorAll(\".navbar-burger\"),\n      0\n    );\n    if ($navbarBurgers.length > 0) {\n      $navbarBurgers.forEach((el) => {\n        el.addEventListener(\"click\", () => {\n          const target = el.dataset.target;\n          const $target = document.getElementById(target);\n          el.classList.toggle(\"is-active\");\n          $target.classList.toggle(\"is-active\");\n        });\n      });\n    }\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[data-toggle-element]\").forEach((el) => {\n      el.addEventListener(\"click\", (e2) => {\n        e2.stopPropagation();\n        const target = el.dataset.toggleElement;\n        const $target = document.getElementById(target);\n        $target.classList.toggle(\"tw-hidden\");\n      });\n    });\n  });\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/enums.js\n  var top = \"top\";\n  var bottom = \"bottom\";\n  var right = \"right\";\n  var left = \"left\";\n  var auto = \"auto\";\n  var basePlacements = [top, bottom, right, left];\n  var start = \"start\";\n  var end = \"end\";\n  var clippingParents = \"clippingParents\";\n  var viewport = \"viewport\";\n  var popper = \"popper\";\n  var reference = \"reference\";\n  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var beforeRead = \"beforeRead\";\n  var read = \"read\";\n  var afterRead = \"afterRead\";\n  var beforeMain = \"beforeMain\";\n  var main = \"main\";\n  var afterMain = \"afterMain\";\n  var beforeWrite = \"beforeWrite\";\n  var write = \"write\";\n  var afterWrite = \"afterWrite\";\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\n  function getNodeName(element) {\n    return element ? (element.nodeName || \"\").toLowerCase() : null;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n  function getWindow2(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== \"[object Window]\") {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n  function isElement(node) {\n    var OwnElement = getWindow2(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow2(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    if (typeof ShadowRoot === \"undefined\") {\n      return false;\n    }\n    var OwnElement = getWindow2(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function(name2) {\n      var style = state.styles[name2] || {};\n      var attributes = state.attributes[name2] || {};\n      var element = state.elements[name2];\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function(name3) {\n        var value = attributes[name3];\n        if (value === false) {\n          element.removeAttribute(name3);\n        } else {\n          element.setAttribute(name3, value === true ? \"\" : value);\n        }\n      });\n    });\n  }\n  function effect(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: \"0\",\n        top: \"0\",\n        margin: \"0\"\n      },\n      arrow: {\n        position: \"absolute\"\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function() {\n      Object.keys(state.elements).forEach(function(name2) {\n        var element = state.elements[name2];\n        var attributes = state.attributes[name2] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);\n        var style = styleProperties.reduce(function(style2, property) {\n          style2[property] = \"\";\n          return style2;\n        }, {});\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function(attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  }\n  var applyStyles_default = {\n    name: \"applyStyles\",\n    enabled: true,\n    phase: \"write\",\n    fn: applyStyles,\n    effect,\n    requires: [\"computeStyles\"]\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n  function getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/math.js\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth;\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element);\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width,\n      height\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/contains.js\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode();\n    if (parent.contains(child)) {\n      return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        }\n        next = next.parentNode || next.host;\n      } while (next);\n    }\n    return false;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n  function getComputedStyle(element) {\n    return getWindow2(element).getComputedStyle(element);\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n  function isTableElement(element) {\n    return [\"table\", \"td\", \"th\"].indexOf(getNodeName(element)) >= 0;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n  function getDocumentElement(element) {\n    return ((isElement(element) ? element.ownerDocument : (\n      // $FlowFixMe[prop-missing]\n      element.document\n    )) || window.document).documentElement;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n  function getParentNode(element) {\n    if (getNodeName(element) === \"html\") {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || // DOM Element detected\n      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element)\n    );\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === \"fixed\") {\n      return null;\n    }\n    return element.offsetParent;\n  }\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf(\"firefox\") !== -1;\n    var isIE = navigator.userAgent.indexOf(\"Trident\") !== -1;\n    if (isIE && isHTMLElement(element)) {\n      var elementCss = getComputedStyle(element);\n      if (elementCss.position === \"fixed\") {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && [\"html\", \"body\"].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode);\n      if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  }\n  function getOffsetParent(element) {\n    var window2 = getWindow2(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n      return window2;\n    }\n    return offsetParent || getContainingBlock(element) || window2;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\n  function getMainAxisFromPlacement(placement) {\n    return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/within.js\n  function within(min2, value, max2) {\n    return max(min2, min(value, max2));\n  }\n  function withinMaxClamp(min2, value, max2) {\n    var v = within(min2, value, max2);\n    return v > max2 ? max2 : v;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/expandToHashMap.js\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function(hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/arrow.js\n  var toPaddingObject = function toPaddingObject2(padding, state) {\n    padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state, name2 = _ref.name, options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets2 = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? \"height\" : \"width\";\n    if (!arrowElement || !popperOffsets2) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === \"y\" ? top : left;\n    var maxProp = axis === \"y\" ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2;\n    var min2 = paddingObject[minProp];\n    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset2 = within(min2, center, max2);\n    var axisProp = axis;\n    state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);\n  }\n  function effect2(_ref2) {\n    var state = _ref2.state, options = _ref2.options;\n    var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n    if (arrowElement == null) {\n      return;\n    }\n    if (typeof arrowElement === \"string\") {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (true) {\n      if (!isHTMLElement(arrowElement)) {\n        console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"));\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      if (true) {\n        console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      }\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  }\n  var arrow_default = {\n    name: \"arrow\",\n    enabled: true,\n    phase: \"main\",\n    fn: arrow,\n    effect: effect2,\n    requires: [\"popperOffsets\"],\n    requiresIfExists: [\"preventOverflow\"]\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getVariation.js\n  function getVariation(placement) {\n    return placement.split(\"-\")[1];\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n  var unsetSides = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n  };\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x, y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n      x,\n      y\n    }) : {\n      x,\n      y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty(\"x\");\n    var hasY = offsets.hasOwnProperty(\"y\");\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper2);\n      var heightProp = \"clientHeight\";\n      var widthProp = \"clientWidth\";\n      if (offsetParent === getWindow2(popper2)) {\n        offsetParent = getDocumentElement(popper2);\n        if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n          heightProp = \"scrollHeight\";\n          widthProp = \"scrollWidth\";\n        }\n      }\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : (\n          // $FlowFixMe[prop-missing]\n          offsetParent[heightProp]\n        );\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : (\n          // $FlowFixMe[prop-missing]\n          offsetParent[widthProp]\n        );\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x,\n      y\n    }) : {\n      x,\n      y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state, options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    if (true) {\n      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || \"\";\n      if (adaptive && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(property) {\n        return transitionProperty.indexOf(property) >= 0;\n      })) {\n        console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', \"\\n\\n\", 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", \"\\n\\n\", \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n      }\n    }\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration,\n      isFixed: state.options.strategy === \"fixed\"\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive,\n        roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: \"absolute\",\n        adaptive: false,\n        roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      \"data-popper-placement\": state.placement\n    });\n  }\n  var computeStyles_default = {\n    name: \"computeStyles\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    fn: computeStyles,\n    data: {}\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n  var passive = {\n    passive: true\n  };\n  function effect3(_ref) {\n    var state = _ref.state, instance = _ref.instance, options = _ref.options;\n    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n    var window2 = getWindow2(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function(scrollParent) {\n        scrollParent.addEventListener(\"scroll\", instance.update, passive);\n      });\n    }\n    if (resize) {\n      window2.addEventListener(\"resize\", instance.update, passive);\n    }\n    return function() {\n      if (scroll) {\n        scrollParents.forEach(function(scrollParent) {\n          scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n        });\n      }\n      if (resize) {\n        window2.removeEventListener(\"resize\", instance.update, passive);\n      }\n    };\n  }\n  var eventListeners_default = {\n    name: \"eventListeners\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn() {\n    },\n    effect: effect3,\n    data: {}\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\n  var hash = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function(matched) {\n      return hash[matched];\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\n  var hash2 = {\n    start: \"end\",\n    end: \"start\"\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function(matched) {\n      return hash2[matched];\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n  function getWindowScroll(node) {\n    var win = getWindow2(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft,\n      scrollTop\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n  function getWindowScrollBarX(element) {\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n  function getViewportRect(element) {\n    var win = getWindow2(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height;\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width,\n      height,\n      x: x + getWindowScrollBarX(element),\n      y\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === \"rtl\") {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width,\n      height,\n      x,\n      y\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n  function isScrollParent(element) {\n    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n  function getScrollParent(node) {\n    if ([\"html\", \"body\", \"#document\"].indexOf(getNodeName(node)) >= 0) {\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow2(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : (\n      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n      updatedList.concat(listScrollParents(getParentNode(target)))\n    );\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/rectToClientRect.js\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  }\n  function getClippingParents(element) {\n    var clippingParents2 = listScrollParents(getParentNode(element));\n    var canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    }\n    return clippingParents2.filter(function(clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n    });\n  }\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents2[0];\n    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeOffsets.js\n  function computeOffsets(_ref) {\n    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference2.x + reference2.width / 2 - element.width / 2;\n    var commonY = reference2.y + reference2.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference2.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference2.y + reference2.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference2.x + reference2.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference2.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference2.x,\n          y: reference2.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === \"y\" ? \"height\" : \"width\";\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);\n          break;\n        default:\n      }\n    }\n    return offsets;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/detectOverflow.js\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets2 = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: \"absolute\",\n      placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset;\n    if (elementContext === popper && offsetData) {\n      var offset2 = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function(key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n        overflowOffsets[key] += offset2[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n      return getVariation(placement2) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements2.filter(function(placement2) {\n      return allowedAutoPlacements.indexOf(placement2) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements2;\n      if (true) {\n        console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \"));\n      }\n    }\n    var overflows = allowedPlacements.reduce(function(acc, placement2) {\n      acc[placement2] = detectOverflow(state, {\n        placement: placement2,\n        boundary,\n        rootBoundary,\n        padding\n      })[getBasePlacement(placement2)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function(a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/flip.js\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state, options = _ref.options, name2 = _ref.name;\n    if (state.modifiersData[name2]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n        placement: placement2,\n        boundary,\n        rootBoundary,\n        padding,\n        flipVariations,\n        allowedAutoPlacements\n      }) : placement2);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = /* @__PURE__ */ new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements2[0];\n    for (var i = 0; i < placements2.length; i++) {\n      var placement = placements2[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? \"width\" : \"height\";\n      var overflow = detectOverflow(state, {\n        placement,\n        boundary,\n        rootBoundary,\n        altBoundary,\n        padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function(check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop2(_i2) {\n        var fittingPlacement = placements2.find(function(placement2) {\n          var checks2 = checksMap.get(placement2);\n          if (checks2) {\n            return checks2.slice(0, _i2).every(function(check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\")\n          break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name2]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  }\n  var flip_default = {\n    name: \"flip\",\n    enabled: true,\n    phase: \"main\",\n    fn: flip,\n    requiresIfExists: [\"offset\"],\n    data: {\n      _skip: false\n    }\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/hide.js\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function(side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state, name2 = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: \"reference\"\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name2] = {\n      referenceClippingOffsets,\n      popperEscapeOffsets,\n      isReferenceHidden,\n      hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      \"data-popper-reference-hidden\": isReferenceHidden,\n      \"data-popper-escaped\": hasPopperEscaped\n    });\n  }\n  var hide_default = {\n    name: \"hide\",\n    enabled: true,\n    phase: \"main\",\n    requiresIfExists: [\"preventOverflow\"],\n    fn: hide\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/offset.js\n  function distanceAndSkiddingToXY(placement, rects, offset2) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset2 === \"function\" ? offset2(Object.assign({}, rects, {\n      placement\n    })) : offset2, skidding = _ref[0], distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;\n    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function(acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name2] = data;\n  }\n  var offset_default = {\n    name: \"offset\",\n    enabled: true,\n    phase: \"main\",\n    requires: [\"popperOffsets\"],\n    fn: offset\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n  function popperOffsets(_ref) {\n    var state = _ref.state, name2 = _ref.name;\n    state.modifiersData[name2] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: \"absolute\",\n      placement: state.placement\n    });\n  }\n  var popperOffsets_default = {\n    name: \"popperOffsets\",\n    enabled: true,\n    phase: \"read\",\n    fn: popperOffsets,\n    data: {}\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/getAltAxis.js\n  function getAltAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n  function preventOverflow(_ref) {\n    var state = _ref.state, options = _ref.options, name2 = _ref.name;\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary,\n      rootBoundary,\n      padding,\n      altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets2 = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets2) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === \"y\" ? top : left;\n      var altSide = mainAxis === \"y\" ? bottom : right;\n      var len = mainAxis === \"y\" ? \"height\" : \"width\";\n      var offset2 = popperOffsets2[mainAxis];\n      var min2 = offset2 + overflow[mainSide];\n      var max2 = offset2 - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide];\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset2 + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);\n      popperOffsets2[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset2;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === \"x\" ? top : left;\n      var _altSide = mainAxis === \"x\" ? bottom : right;\n      var _offset = popperOffsets2[altAxis];\n      var _len = altAxis === \"y\" ? \"height\" : \"width\";\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets2[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name2] = data;\n  }\n  var preventOverflow_default = {\n    name: \"preventOverflow\",\n    enabled: true,\n    phase: \"main\",\n    fn: preventOverflow,\n    requiresIfExists: [\"offset\"]\n  };\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n  function getNodeScroll(node) {\n    if (node === getWindow2(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  }\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/orderModifiers.js\n  function order(modifiers) {\n    var map = /* @__PURE__ */ new Map();\n    var visited = /* @__PURE__ */ new Set();\n    var result = [];\n    modifiers.forEach(function(modifier) {\n      map.set(modifier.name, modifier);\n    });\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function(dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function(modifier) {\n      if (!visited.has(modifier.name)) {\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    var orderedModifiers = order(modifiers);\n    return modifierPhases.reduce(function(acc, phase) {\n      return acc.concat(orderedModifiers.filter(function(modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/debounce.js\n  function debounce(fn2) {\n    var pending;\n    return function() {\n      if (!pending) {\n        pending = new Promise(function(resolve) {\n          Promise.resolve().then(function() {\n            pending = void 0;\n            resolve(fn2());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/format.js\n  function format(str2) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return [].concat(args).reduce(function(p, c) {\n      return p.replace(/%s/, c);\n    }, str2);\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/validateModifiers.js\n  var INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\n  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\n  var VALID_PROPERTIES = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\n  function validateModifiers(modifiers) {\n    modifiers.forEach(function(modifier) {\n      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {\n        return self2.indexOf(value) === index;\n      }).forEach(function(key) {\n        switch (key) {\n          case \"name\":\n            if (typeof modifier.name !== \"string\") {\n              console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', '\"' + String(modifier.name) + '\"'));\n            }\n            break;\n          case \"enabled\":\n            if (typeof modifier.enabled !== \"boolean\") {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', '\"' + String(modifier.enabled) + '\"'));\n            }\n            break;\n          case \"phase\":\n            if (modifierPhases.indexOf(modifier.phase) < 0) {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(modifier.phase) + '\"'));\n            }\n            break;\n          case \"fn\":\n            if (typeof modifier.fn !== \"function\") {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n            }\n            break;\n          case \"effect\":\n            if (modifier.effect != null && typeof modifier.effect !== \"function\") {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n            }\n            break;\n          case \"requires\":\n            if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', '\"' + String(modifier.requires) + '\"'));\n            }\n            break;\n          case \"requiresIfExists\":\n            if (!Array.isArray(modifier.requiresIfExists)) {\n              console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(modifier.requiresIfExists) + '\"'));\n            }\n            break;\n          case \"options\":\n          case \"data\":\n            break;\n          default:\n            console.error('PopperJS: an invalid property has been provided to the \"' + modifier.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {\n              return '\"' + s + '\"';\n            }).join(\", \") + '; but \"' + key + '\" was provided.');\n        }\n        modifier.requires && modifier.requires.forEach(function(requirement) {\n          if (modifiers.find(function(mod) {\n            return mod.name === requirement;\n          }) == null) {\n            console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n          }\n        });\n      });\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/uniqueBy.js\n  function uniqueBy(arr, fn2) {\n    var identifiers = /* @__PURE__ */ new Set();\n    return arr.filter(function(item) {\n      var identifier = fn2(item);\n      if (!identifiers.has(identifier)) {\n        identifiers.add(identifier);\n        return true;\n      }\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/utils/mergeByName.js\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function(merged2, current) {\n      var existing = merged2[current.name];\n      merged2[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged2;\n    }, {});\n    return Object.keys(merged).map(function(key) {\n      return merged[key];\n    });\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/createPopper.js\n  var INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\";\n  var INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\";\n  var DEFAULT_OPTIONS = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function(element) {\n      return !(element && typeof element.getBoundingClientRect === \"function\");\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper2(reference2, popper2, options) {\n      if (options === void 0) {\n        options = defaultOptions2;\n      }\n      var state = {\n        placement: \"bottom\",\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),\n        modifiersData: {},\n        elements: {\n          reference: reference2,\n          popper: popper2\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options2 = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions2, state.options, options2);\n          state.scrollParents = {\n            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n            popper: listScrollParents(popper2)\n          };\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));\n          state.orderedModifiers = orderedModifiers.filter(function(m) {\n            return m.enabled;\n          });\n          if (true) {\n            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {\n              var name2 = _ref.name;\n              return name2;\n            });\n            validateModifiers(modifiers);\n            if (getBasePlacement(state.options.placement) === auto) {\n              var flipModifier = state.orderedModifiers.find(function(_ref2) {\n                var name2 = _ref2.name;\n                return name2 === \"flip\";\n              });\n              if (!flipModifier) {\n                console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n              }\n            }\n            var _getComputedStyle = getComputedStyle(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;\n            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {\n              return parseFloat(margin);\n            })) {\n              console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n            }\n          }\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update  it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n          if (!areValidElements(reference3, popper3)) {\n            if (true) {\n              console.error(INVALID_ELEMENT_ERROR);\n            }\n            return;\n          }\n          state.rects = {\n            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === \"fixed\"),\n            popper: getLayoutRect(popper3)\n          };\n          state.reset = false;\n          state.placement = state.options.placement;\n          state.orderedModifiers.forEach(function(modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          var __debug_loops__ = 0;\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (true) {\n              __debug_loops__ += 1;\n              if (__debug_loops__ > 100) {\n                console.error(INFINITE_LOOP_ERROR);\n                break;\n              }\n            }\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;\n            if (typeof fn2 === \"function\") {\n              state = fn2({\n                state,\n                options: _options,\n                name: name2,\n                instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update  it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function() {\n          return new Promise(function(resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference2, popper2)) {\n        if (true) {\n          console.error(INVALID_ELEMENT_ERROR);\n        }\n        return instance;\n      }\n      instance.setOptions(options).then(function(state2) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state2);\n        }\n      });\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function(_ref3) {\n          var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect5 = _ref3.effect;\n          if (typeof effect5 === \"function\") {\n            var cleanupFn = effect5({\n              state,\n              name: name2,\n              instance,\n              options: options2\n            });\n            var noopFn = function noopFn2() {\n            };\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function(fn2) {\n          return fn2();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n\n  // node_modules/tippy.js/node_modules/@popperjs/core/lib/popper.js\n  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];\n  var createPopper = /* @__PURE__ */ popperGenerator({\n    defaultModifiers\n  });\n\n  // node_modules/tippy.js/dist/tippy.esm.js\n  var BOX_CLASS = \"tippy-box\";\n  var CONTENT_CLASS = \"tippy-content\";\n  var BACKDROP_CLASS = \"tippy-backdrop\";\n  var ARROW_CLASS = \"tippy-arrow\";\n  var SVG_ARROW_CLASS = \"tippy-svg-arrow\";\n  var TOUCH_OPTIONS = {\n    passive: true,\n    capture: true\n  };\n  var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {\n    return document.body;\n  };\n  function hasOwnProperty(obj, key) {\n    return {}.hasOwnProperty.call(obj, key);\n  }\n  function getValueAtIndexOrReturn(value, index, defaultValue) {\n    if (Array.isArray(value)) {\n      var v = value[index];\n      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n    }\n    return value;\n  }\n  function isType2(value, type) {\n    var str2 = {}.toString.call(value);\n    return str2.indexOf(\"[object\") === 0 && str2.indexOf(type + \"]\") > -1;\n  }\n  function invokeWithArgsOrReturn(value, args) {\n    return typeof value === \"function\" ? value.apply(void 0, args) : value;\n  }\n  function debounce2(fn2, ms) {\n    if (ms === 0) {\n      return fn2;\n    }\n    var timeout;\n    return function(arg) {\n      clearTimeout(timeout);\n      timeout = setTimeout(function() {\n        fn2(arg);\n      }, ms);\n    };\n  }\n  function removeProperties(obj, keys) {\n    var clone = Object.assign({}, obj);\n    keys.forEach(function(key) {\n      delete clone[key];\n    });\n    return clone;\n  }\n  function splitBySpaces(value) {\n    return value.split(/\\s+/).filter(Boolean);\n  }\n  function normalizeToArray(value) {\n    return [].concat(value);\n  }\n  function pushIfUnique(arr, value) {\n    if (arr.indexOf(value) === -1) {\n      arr.push(value);\n    }\n  }\n  function unique(arr) {\n    return arr.filter(function(item, index) {\n      return arr.indexOf(item) === index;\n    });\n  }\n  function getBasePlacement2(placement) {\n    return placement.split(\"-\")[0];\n  }\n  function arrayFrom(value) {\n    return [].slice.call(value);\n  }\n  function removeUndefinedProps(obj) {\n    return Object.keys(obj).reduce(function(acc, key) {\n      if (obj[key] !== void 0) {\n        acc[key] = obj[key];\n      }\n      return acc;\n    }, {});\n  }\n  function div() {\n    return document.createElement(\"div\");\n  }\n  function isElement2(value) {\n    return [\"Element\", \"Fragment\"].some(function(type) {\n      return isType2(value, type);\n    });\n  }\n  function isNodeList(value) {\n    return isType2(value, \"NodeList\");\n  }\n  function isMouseEvent(value) {\n    return isType2(value, \"MouseEvent\");\n  }\n  function isReferenceElement(value) {\n    return !!(value && value._tippy && value._tippy.reference === value);\n  }\n  function getArrayOfElements(value) {\n    if (isElement2(value)) {\n      return [value];\n    }\n    if (isNodeList(value)) {\n      return arrayFrom(value);\n    }\n    if (Array.isArray(value)) {\n      return value;\n    }\n    return arrayFrom(document.querySelectorAll(value));\n  }\n  function setTransitionDuration(els, value) {\n    els.forEach(function(el) {\n      if (el) {\n        el.style.transitionDuration = value + \"ms\";\n      }\n    });\n  }\n  function setVisibilityState(els, state) {\n    els.forEach(function(el) {\n      if (el) {\n        el.setAttribute(\"data-state\", state);\n      }\n    });\n  }\n  function getOwnerDocument(elementOrElements) {\n    var _element$ownerDocumen;\n    var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];\n    return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n  }\n  function isCursorOutsideInteractiveBorder(popperTreeData, event) {\n    var clientX = event.clientX, clientY = event.clientY;\n    return popperTreeData.every(function(_ref) {\n      var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;\n      var interactiveBorder = props.interactiveBorder;\n      var basePlacement = getBasePlacement2(popperState.placement);\n      var offsetData = popperState.modifiersData.offset;\n      if (!offsetData) {\n        return true;\n      }\n      var topDistance = basePlacement === \"bottom\" ? offsetData.top.y : 0;\n      var bottomDistance = basePlacement === \"top\" ? offsetData.bottom.y : 0;\n      var leftDistance = basePlacement === \"right\" ? offsetData.left.x : 0;\n      var rightDistance = basePlacement === \"left\" ? offsetData.right.x : 0;\n      var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n      var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n      var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n      var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n    });\n  }\n  function updateTransitionEndListener(box, action, listener) {\n    var method = action + \"EventListener\";\n    [\"transitionend\", \"webkitTransitionEnd\"].forEach(function(event) {\n      box[method](event, listener);\n    });\n  }\n  function actualContains(parent, child) {\n    var target = child;\n    while (target) {\n      var _target$getRootNode;\n      if (parent.contains(target)) {\n        return true;\n      }\n      target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n    }\n    return false;\n  }\n  var currentInput = {\n    isTouch: false\n  };\n  var lastMouseMoveTime = 0;\n  function onDocumentTouchStart() {\n    if (currentInput.isTouch) {\n      return;\n    }\n    currentInput.isTouch = true;\n    if (window.performance) {\n      document.addEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n  }\n  function onDocumentMouseMove() {\n    var now = performance.now();\n    if (now - lastMouseMoveTime < 20) {\n      currentInput.isTouch = false;\n      document.removeEventListener(\"mousemove\", onDocumentMouseMove);\n    }\n    lastMouseMoveTime = now;\n  }\n  function onWindowBlur() {\n    var activeElement = document.activeElement;\n    if (isReferenceElement(activeElement)) {\n      var instance = activeElement._tippy;\n      if (activeElement.blur && !instance.state.isVisible) {\n        activeElement.blur();\n      }\n    }\n  }\n  function bindGlobalEventListeners() {\n    document.addEventListener(\"touchstart\", onDocumentTouchStart, TOUCH_OPTIONS);\n    window.addEventListener(\"blur\", onWindowBlur);\n  }\n  var isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var isIE11 = isBrowser ? (\n    // @ts-ignore\n    !!window.msCrypto\n  ) : false;\n  function createMemoryLeakWarning(method) {\n    var txt = method === \"destroy\" ? \"n already-\" : \" \";\n    return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", \"indicates a potential memory leak.\"].join(\" \");\n  }\n  function clean(value) {\n    var spacesAndTabs = /[ \\t]{2,}/g;\n    var lineStartWithSpaces = /^[ \\t]*/gm;\n    return value.replace(spacesAndTabs, \" \").replace(lineStartWithSpaces, \"\").trim();\n  }\n  function getDevMessage(message) {\n    return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\u{1F477}\\u200D This is a development-only message. It will be removed in production.\\n  \");\n  }\n  function getFormattedMessage(message) {\n    return [\n      getDevMessage(message),\n      // title\n      \"color: #00C584; font-size: 1.3em; font-weight: bold;\",\n      // message\n      \"line-height: 1.5\",\n      // footer\n      \"color: #a6a095;\"\n    ];\n  }\n  var visitedMessages;\n  if (true) {\n    resetVisitedMessages();\n  }\n  function resetVisitedMessages() {\n    visitedMessages = /* @__PURE__ */ new Set();\n  }\n  function warnWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n      var _console;\n      visitedMessages.add(message);\n      (_console = console).warn.apply(_console, getFormattedMessage(message));\n    }\n  }\n  function errorWhen(condition, message) {\n    if (condition && !visitedMessages.has(message)) {\n      var _console2;\n      visitedMessages.add(message);\n      (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n    }\n  }\n  function validateTargets(targets) {\n    var didPassFalsyValue = !targets;\n    var didPassPlainObject = Object.prototype.toString.call(targets) === \"[object Object]\" && !targets.addEventListener;\n    errorWhen(didPassFalsyValue, [\"tippy() was passed\", \"`\" + String(targets) + \"`\", \"as its targets (first) argument. Valid types are: String, Element,\", \"Element[], or NodeList.\"].join(\" \"));\n    errorWhen(didPassPlainObject, [\"tippy() was passed a plain object which is not supported as an argument\", \"for virtual positioning. Use props.getReferenceClientRect instead.\"].join(\" \"));\n  }\n  var pluginProps = {\n    animateFill: false,\n    followCursor: false,\n    inlinePositioning: false,\n    sticky: false\n  };\n  var renderProps = {\n    allowHTML: false,\n    animation: \"fade\",\n    arrow: true,\n    content: \"\",\n    inertia: false,\n    maxWidth: 350,\n    role: \"tooltip\",\n    theme: \"\",\n    zIndex: 9999\n  };\n  var defaultProps = Object.assign({\n    appendTo: TIPPY_DEFAULT_APPEND_TO,\n    aria: {\n      content: \"auto\",\n      expanded: \"auto\"\n    },\n    delay: 0,\n    duration: [300, 250],\n    getReferenceClientRect: null,\n    hideOnClick: true,\n    ignoreAttributes: false,\n    interactive: false,\n    interactiveBorder: 2,\n    interactiveDebounce: 0,\n    moveTransition: \"\",\n    offset: [0, 10],\n    onAfterUpdate: function onAfterUpdate() {\n    },\n    onBeforeUpdate: function onBeforeUpdate() {\n    },\n    onCreate: function onCreate() {\n    },\n    onDestroy: function onDestroy() {\n    },\n    onHidden: function onHidden() {\n    },\n    onHide: function onHide() {\n    },\n    onMount: function onMount() {\n    },\n    onShow: function onShow() {\n    },\n    onShown: function onShown() {\n    },\n    onTrigger: function onTrigger() {\n    },\n    onUntrigger: function onUntrigger() {\n    },\n    onClickOutside: function onClickOutside() {\n    },\n    placement: \"top\",\n    plugins: [],\n    popperOptions: {},\n    render: null,\n    showOnCreate: false,\n    touch: true,\n    trigger: \"mouseenter focus\",\n    triggerTarget: null\n  }, pluginProps, renderProps);\n  var defaultKeys = Object.keys(defaultProps);\n  var setDefaultProps = function setDefaultProps2(partialProps) {\n    if (true) {\n      validateProps(partialProps, []);\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(key) {\n      defaultProps[key] = partialProps[key];\n    });\n  };\n  function getExtendedPassedProps(passedProps) {\n    var plugins = passedProps.plugins || [];\n    var pluginProps2 = plugins.reduce(function(acc, plugin) {\n      var name2 = plugin.name, defaultValue = plugin.defaultValue;\n      if (name2) {\n        var _name;\n        acc[name2] = passedProps[name2] !== void 0 ? passedProps[name2] : (_name = defaultProps[name2]) != null ? _name : defaultValue;\n      }\n      return acc;\n    }, {});\n    return Object.assign({}, passedProps, pluginProps2);\n  }\n  function getDataAttributeProps(reference2, plugins) {\n    var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n      plugins\n    }))) : defaultKeys;\n    var props = propKeys.reduce(function(acc, key) {\n      var valueAsString = (reference2.getAttribute(\"data-tippy-\" + key) || \"\").trim();\n      if (!valueAsString) {\n        return acc;\n      }\n      if (key === \"content\") {\n        acc[key] = valueAsString;\n      } else {\n        try {\n          acc[key] = JSON.parse(valueAsString);\n        } catch (e2) {\n          acc[key] = valueAsString;\n        }\n      }\n      return acc;\n    }, {});\n    return props;\n  }\n  function evaluateProps(reference2, props) {\n    var out = Object.assign({}, props, {\n      content: invokeWithArgsOrReturn(props.content, [reference2])\n    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));\n    out.aria = Object.assign({}, defaultProps.aria, out.aria);\n    out.aria = {\n      expanded: out.aria.expanded === \"auto\" ? props.interactive : out.aria.expanded,\n      content: out.aria.content === \"auto\" ? props.interactive ? null : \"describedby\" : out.aria.content\n    };\n    return out;\n  }\n  function validateProps(partialProps, plugins) {\n    if (partialProps === void 0) {\n      partialProps = {};\n    }\n    if (plugins === void 0) {\n      plugins = [];\n    }\n    var keys = Object.keys(partialProps);\n    keys.forEach(function(prop) {\n      var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n      var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);\n      if (didPassUnknownProp) {\n        didPassUnknownProp = plugins.filter(function(plugin) {\n          return plugin.name === prop;\n        }).length === 0;\n      }\n      warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", \"a plugin, forgot to pass it in an array as props.plugins.\", \"\\n\\n\", \"All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n\", \"Plugins: https://atomiks.github.io/tippyjs/v6/plugins/\"].join(\" \"));\n    });\n  }\n  var innerHTML = function innerHTML2() {\n    return \"innerHTML\";\n  };\n  function dangerouslySetInnerHTML(element, html) {\n    element[innerHTML()] = html;\n  }\n  function createArrowElement(value) {\n    var arrow2 = div();\n    if (value === true) {\n      arrow2.className = ARROW_CLASS;\n    } else {\n      arrow2.className = SVG_ARROW_CLASS;\n      if (isElement2(value)) {\n        arrow2.appendChild(value);\n      } else {\n        dangerouslySetInnerHTML(arrow2, value);\n      }\n    }\n    return arrow2;\n  }\n  function setContent(content, props) {\n    if (isElement2(props.content)) {\n      dangerouslySetInnerHTML(content, \"\");\n      content.appendChild(props.content);\n    } else if (typeof props.content !== \"function\") {\n      if (props.allowHTML) {\n        dangerouslySetInnerHTML(content, props.content);\n      } else {\n        content.textContent = props.content;\n      }\n    }\n  }\n  function getChildren(popper2) {\n    var box = popper2.firstElementChild;\n    var boxChildren = arrayFrom(box.children);\n    return {\n      box,\n      content: boxChildren.find(function(node) {\n        return node.classList.contains(CONTENT_CLASS);\n      }),\n      arrow: boxChildren.find(function(node) {\n        return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n      }),\n      backdrop: boxChildren.find(function(node) {\n        return node.classList.contains(BACKDROP_CLASS);\n      })\n    };\n  }\n  function render(instance) {\n    var popper2 = div();\n    var box = div();\n    box.className = BOX_CLASS;\n    box.setAttribute(\"data-state\", \"hidden\");\n    box.setAttribute(\"tabindex\", \"-1\");\n    var content = div();\n    content.className = CONTENT_CLASS;\n    content.setAttribute(\"data-state\", \"hidden\");\n    setContent(content, instance.props);\n    popper2.appendChild(box);\n    box.appendChild(content);\n    onUpdate(instance.props, instance.props);\n    function onUpdate(prevProps, nextProps) {\n      var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;\n      if (nextProps.theme) {\n        box2.setAttribute(\"data-theme\", nextProps.theme);\n      } else {\n        box2.removeAttribute(\"data-theme\");\n      }\n      if (typeof nextProps.animation === \"string\") {\n        box2.setAttribute(\"data-animation\", nextProps.animation);\n      } else {\n        box2.removeAttribute(\"data-animation\");\n      }\n      if (nextProps.inertia) {\n        box2.setAttribute(\"data-inertia\", \"\");\n      } else {\n        box2.removeAttribute(\"data-inertia\");\n      }\n      box2.style.maxWidth = typeof nextProps.maxWidth === \"number\" ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n      if (nextProps.role) {\n        box2.setAttribute(\"role\", nextProps.role);\n      } else {\n        box2.removeAttribute(\"role\");\n      }\n      if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n        setContent(content2, instance.props);\n      }\n      if (nextProps.arrow) {\n        if (!arrow2) {\n          box2.appendChild(createArrowElement(nextProps.arrow));\n        } else if (prevProps.arrow !== nextProps.arrow) {\n          box2.removeChild(arrow2);\n          box2.appendChild(createArrowElement(nextProps.arrow));\n        }\n      } else if (arrow2) {\n        box2.removeChild(arrow2);\n      }\n    }\n    return {\n      popper: popper2,\n      onUpdate\n    };\n  }\n  render.$$tippy = true;\n  var idCounter = 1;\n  var mouseMoveListeners = [];\n  var mountedInstances = [];\n  function createTippy(reference2, passedProps) {\n    var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));\n    var showTimeout;\n    var hideTimeout;\n    var scheduleHideAnimationFrame;\n    var isVisibleFromClick = false;\n    var didHideDueToDocumentMouseDown = false;\n    var didTouchMove = false;\n    var ignoreOnFirstUpdate = false;\n    var lastTriggerEvent;\n    var currentTransitionEndListener;\n    var onFirstUpdate;\n    var listeners = [];\n    var debouncedOnMouseMove = debounce2(onMouseMove, props.interactiveDebounce);\n    var currentTarget;\n    var id = idCounter++;\n    var popperInstance = null;\n    var plugins = unique(props.plugins);\n    var state = {\n      // Is the instance currently enabled?\n      isEnabled: true,\n      // Is the tippy currently showing and not transitioning out?\n      isVisible: false,\n      // Has the instance been destroyed?\n      isDestroyed: false,\n      // Is the tippy currently mounted to the DOM?\n      isMounted: false,\n      // Has the tippy finished transitioning in?\n      isShown: false\n    };\n    var instance = {\n      // properties\n      id,\n      reference: reference2,\n      popper: div(),\n      popperInstance,\n      props,\n      state,\n      plugins,\n      // methods\n      clearDelayTimeouts,\n      setProps,\n      setContent: setContent2,\n      show,\n      hide: hide2,\n      hideWithInteractivity,\n      enable,\n      disable,\n      unmount,\n      destroy\n    };\n    if (!props.render) {\n      if (true) {\n        errorWhen(true, \"render() function has not been supplied.\");\n      }\n      return instance;\n    }\n    var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;\n    popper2.setAttribute(\"data-tippy-root\", \"\");\n    popper2.id = \"tippy-\" + instance.id;\n    instance.popper = popper2;\n    reference2._tippy = instance;\n    popper2._tippy = instance;\n    var pluginsHooks = plugins.map(function(plugin) {\n      return plugin.fn(instance);\n    });\n    var hasAriaExpanded = reference2.hasAttribute(\"aria-expanded\");\n    addListeners();\n    handleAriaExpandedAttribute();\n    handleStyles();\n    invokeHook(\"onCreate\", [instance]);\n    if (props.showOnCreate) {\n      scheduleShow();\n    }\n    popper2.addEventListener(\"mouseenter\", function() {\n      if (instance.props.interactive && instance.state.isVisible) {\n        instance.clearDelayTimeouts();\n      }\n    });\n    popper2.addEventListener(\"mouseleave\", function() {\n      if (instance.props.interactive && instance.props.trigger.indexOf(\"mouseenter\") >= 0) {\n        getDocument2().addEventListener(\"mousemove\", debouncedOnMouseMove);\n      }\n    });\n    return instance;\n    function getNormalizedTouchSettings() {\n      var touch = instance.props.touch;\n      return Array.isArray(touch) ? touch : [touch, 0];\n    }\n    function getIsCustomTouchBehavior() {\n      return getNormalizedTouchSettings()[0] === \"hold\";\n    }\n    function getIsDefaultRenderFn() {\n      var _instance$props$rende;\n      return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n    }\n    function getCurrentTarget() {\n      return currentTarget || reference2;\n    }\n    function getDocument2() {\n      var parent = getCurrentTarget().parentNode;\n      return parent ? getOwnerDocument(parent) : document;\n    }\n    function getDefaultTemplateChildren() {\n      return getChildren(popper2);\n    }\n    function getDelay(isShow) {\n      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === \"focus\") {\n        return 0;\n      }\n      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n    }\n    function handleStyles(fromHide) {\n      if (fromHide === void 0) {\n        fromHide = false;\n      }\n      popper2.style.pointerEvents = instance.props.interactive && !fromHide ? \"\" : \"none\";\n      popper2.style.zIndex = \"\" + instance.props.zIndex;\n    }\n    function invokeHook(hook, args, shouldInvokePropsHook) {\n      if (shouldInvokePropsHook === void 0) {\n        shouldInvokePropsHook = true;\n      }\n      pluginsHooks.forEach(function(pluginHooks) {\n        if (pluginHooks[hook]) {\n          pluginHooks[hook].apply(pluginHooks, args);\n        }\n      });\n      if (shouldInvokePropsHook) {\n        var _instance$props;\n        (_instance$props = instance.props)[hook].apply(_instance$props, args);\n      }\n    }\n    function handleAriaContentAttribute() {\n      var aria = instance.props.aria;\n      if (!aria.content) {\n        return;\n      }\n      var attr = \"aria-\" + aria.content;\n      var id2 = popper2.id;\n      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n      nodes.forEach(function(node) {\n        var currentValue = node.getAttribute(attr);\n        if (instance.state.isVisible) {\n          node.setAttribute(attr, currentValue ? currentValue + \" \" + id2 : id2);\n        } else {\n          var nextValue = currentValue && currentValue.replace(id2, \"\").trim();\n          if (nextValue) {\n            node.setAttribute(attr, nextValue);\n          } else {\n            node.removeAttribute(attr);\n          }\n        }\n      });\n    }\n    function handleAriaExpandedAttribute() {\n      if (hasAriaExpanded || !instance.props.aria.expanded) {\n        return;\n      }\n      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n      nodes.forEach(function(node) {\n        if (instance.props.interactive) {\n          node.setAttribute(\"aria-expanded\", instance.state.isVisible && node === getCurrentTarget() ? \"true\" : \"false\");\n        } else {\n          node.removeAttribute(\"aria-expanded\");\n        }\n      });\n    }\n    function cleanupInteractiveMouseListeners() {\n      getDocument2().removeEventListener(\"mousemove\", debouncedOnMouseMove);\n      mouseMoveListeners = mouseMoveListeners.filter(function(listener) {\n        return listener !== debouncedOnMouseMove;\n      });\n    }\n    function onDocumentPress(event) {\n      if (currentInput.isTouch) {\n        if (didTouchMove || event.type === \"mousedown\") {\n          return;\n        }\n      }\n      var actualTarget = event.composedPath && event.composedPath()[0] || event.target;\n      if (instance.props.interactive && actualContains(popper2, actualTarget)) {\n        return;\n      }\n      if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {\n        return actualContains(el, actualTarget);\n      })) {\n        if (currentInput.isTouch) {\n          return;\n        }\n        if (instance.state.isVisible && instance.props.trigger.indexOf(\"click\") >= 0) {\n          return;\n        }\n      } else {\n        invokeHook(\"onClickOutside\", [instance, event]);\n      }\n      if (instance.props.hideOnClick === true) {\n        instance.clearDelayTimeouts();\n        instance.hide();\n        didHideDueToDocumentMouseDown = true;\n        setTimeout(function() {\n          didHideDueToDocumentMouseDown = false;\n        });\n        if (!instance.state.isMounted) {\n          removeDocumentPress();\n        }\n      }\n    }\n    function onTouchMove() {\n      didTouchMove = true;\n    }\n    function onTouchStart() {\n      didTouchMove = false;\n    }\n    function addDocumentPress() {\n      var doc = getDocument2();\n      doc.addEventListener(\"mousedown\", onDocumentPress, true);\n      doc.addEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n      doc.addEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n      doc.addEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function removeDocumentPress() {\n      var doc = getDocument2();\n      doc.removeEventListener(\"mousedown\", onDocumentPress, true);\n      doc.removeEventListener(\"touchend\", onDocumentPress, TOUCH_OPTIONS);\n      doc.removeEventListener(\"touchstart\", onTouchStart, TOUCH_OPTIONS);\n      doc.removeEventListener(\"touchmove\", onTouchMove, TOUCH_OPTIONS);\n    }\n    function onTransitionedOut(duration, callback) {\n      onTransitionEnd(duration, function() {\n        if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {\n          callback();\n        }\n      });\n    }\n    function onTransitionedIn(duration, callback) {\n      onTransitionEnd(duration, callback);\n    }\n    function onTransitionEnd(duration, callback) {\n      var box = getDefaultTemplateChildren().box;\n      function listener(event) {\n        if (event.target === box) {\n          updateTransitionEndListener(box, \"remove\", listener);\n          callback();\n        }\n      }\n      if (duration === 0) {\n        return callback();\n      }\n      updateTransitionEndListener(box, \"remove\", currentTransitionEndListener);\n      updateTransitionEndListener(box, \"add\", listener);\n      currentTransitionEndListener = listener;\n    }\n    function on2(eventType, handler, options) {\n      if (options === void 0) {\n        options = false;\n      }\n      var nodes = normalizeToArray(instance.props.triggerTarget || reference2);\n      nodes.forEach(function(node) {\n        node.addEventListener(eventType, handler, options);\n        listeners.push({\n          node,\n          eventType,\n          handler,\n          options\n        });\n      });\n    }\n    function addListeners() {\n      if (getIsCustomTouchBehavior()) {\n        on2(\"touchstart\", onTrigger2, {\n          passive: true\n        });\n        on2(\"touchend\", onMouseLeave, {\n          passive: true\n        });\n      }\n      splitBySpaces(instance.props.trigger).forEach(function(eventType) {\n        if (eventType === \"manual\") {\n          return;\n        }\n        on2(eventType, onTrigger2);\n        switch (eventType) {\n          case \"mouseenter\":\n            on2(\"mouseleave\", onMouseLeave);\n            break;\n          case \"focus\":\n            on2(isIE11 ? \"focusout\" : \"blur\", onBlurOrFocusOut);\n            break;\n          case \"focusin\":\n            on2(\"focusout\", onBlurOrFocusOut);\n            break;\n        }\n      });\n    }\n    function removeListeners() {\n      listeners.forEach(function(_ref) {\n        var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;\n        node.removeEventListener(eventType, handler, options);\n      });\n      listeners = [];\n    }\n    function onTrigger2(event) {\n      var _lastTriggerEvent;\n      var shouldScheduleClickHide = false;\n      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n        return;\n      }\n      var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === \"focus\";\n      lastTriggerEvent = event;\n      currentTarget = event.currentTarget;\n      handleAriaExpandedAttribute();\n      if (!instance.state.isVisible && isMouseEvent(event)) {\n        mouseMoveListeners.forEach(function(listener) {\n          return listener(event);\n        });\n      }\n      if (event.type === \"click\" && (instance.props.trigger.indexOf(\"mouseenter\") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n        shouldScheduleClickHide = true;\n      } else {\n        scheduleShow(event);\n      }\n      if (event.type === \"click\") {\n        isVisibleFromClick = !shouldScheduleClickHide;\n      }\n      if (shouldScheduleClickHide && !wasFocused) {\n        scheduleHide(event);\n      }\n    }\n    function onMouseMove(event) {\n      var target = event.target;\n      var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);\n      if (event.type === \"mousemove\" && isCursorOverReferenceOrPopper) {\n        return;\n      }\n      var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {\n        var _instance$popperInsta;\n        var instance2 = popper3._tippy;\n        var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n        if (state2) {\n          return {\n            popperRect: popper3.getBoundingClientRect(),\n            popperState: state2,\n            props\n          };\n        }\n        return null;\n      }).filter(Boolean);\n      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n        cleanupInteractiveMouseListeners();\n        scheduleHide(event);\n      }\n    }\n    function onMouseLeave(event) {\n      var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf(\"click\") >= 0 && isVisibleFromClick;\n      if (shouldBail) {\n        return;\n      }\n      if (instance.props.interactive) {\n        instance.hideWithInteractivity(event);\n        return;\n      }\n      scheduleHide(event);\n    }\n    function onBlurOrFocusOut(event) {\n      if (instance.props.trigger.indexOf(\"focusin\") < 0 && event.target !== getCurrentTarget()) {\n        return;\n      }\n      if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {\n        return;\n      }\n      scheduleHide(event);\n    }\n    function isEventListenerStopped(event) {\n      return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf(\"touch\") >= 0 : false;\n    }\n    function createPopperInstance() {\n      destroyPopperInstance();\n      var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;\n      var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;\n      var computedReference = getReferenceClientRect ? {\n        getBoundingClientRect: getReferenceClientRect,\n        contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n      } : reference2;\n      var tippyModifier = {\n        name: \"$$tippy\",\n        enabled: true,\n        phase: \"beforeWrite\",\n        requires: [\"computeStyles\"],\n        fn: function fn2(_ref2) {\n          var state2 = _ref2.state;\n          if (getIsDefaultRenderFn()) {\n            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;\n            [\"placement\", \"reference-hidden\", \"escaped\"].forEach(function(attr) {\n              if (attr === \"placement\") {\n                box.setAttribute(\"data-placement\", state2.placement);\n              } else {\n                if (state2.attributes.popper[\"data-popper-\" + attr]) {\n                  box.setAttribute(\"data-\" + attr, \"\");\n                } else {\n                  box.removeAttribute(\"data-\" + attr);\n                }\n              }\n            });\n            state2.attributes.popper = {};\n          }\n        }\n      };\n      var modifiers = [{\n        name: \"offset\",\n        options: {\n          offset: offset2\n        }\n      }, {\n        name: \"preventOverflow\",\n        options: {\n          padding: {\n            top: 2,\n            bottom: 2,\n            left: 5,\n            right: 5\n          }\n        }\n      }, {\n        name: \"flip\",\n        options: {\n          padding: 5\n        }\n      }, {\n        name: \"computeStyles\",\n        options: {\n          adaptive: !moveTransition\n        }\n      }, tippyModifier];\n      if (getIsDefaultRenderFn() && arrow2) {\n        modifiers.push({\n          name: \"arrow\",\n          options: {\n            element: arrow2,\n            padding: 3\n          }\n        });\n      }\n      modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n      instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {\n        placement,\n        onFirstUpdate,\n        modifiers\n      }));\n    }\n    function destroyPopperInstance() {\n      if (instance.popperInstance) {\n        instance.popperInstance.destroy();\n        instance.popperInstance = null;\n      }\n    }\n    function mount() {\n      var appendTo = instance.props.appendTo;\n      var parentNode;\n      var node = getCurrentTarget();\n      if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === \"parent\") {\n        parentNode = node.parentNode;\n      } else {\n        parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n      }\n      if (!parentNode.contains(popper2)) {\n        parentNode.appendChild(popper2);\n      }\n      instance.state.isMounted = true;\n      createPopperInstance();\n      if (true) {\n        warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, [\"Interactive tippy element may not be accessible via keyboard\", \"navigation because it is not directly after the reference element\", \"in the DOM source order.\", \"\\n\\n\", \"Using a wrapper <div> or <span> tag around the reference element\", \"solves this by creating a new parentNode context.\", \"\\n\\n\", \"Specifying `appendTo: document.body` silences this warning, but it\", \"assumes you are using a focus management solution to handle\", \"keyboard navigation.\", \"\\n\\n\", \"See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity\"].join(\" \"));\n      }\n    }\n    function getNestedPopperTree() {\n      return arrayFrom(popper2.querySelectorAll(\"[data-tippy-root]\"));\n    }\n    function scheduleShow(event) {\n      instance.clearDelayTimeouts();\n      if (event) {\n        invokeHook(\"onTrigger\", [instance, event]);\n      }\n      addDocumentPress();\n      var delay = getDelay(true);\n      var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];\n      if (currentInput.isTouch && touchValue === \"hold\" && touchDelay) {\n        delay = touchDelay;\n      }\n      if (delay) {\n        showTimeout = setTimeout(function() {\n          instance.show();\n        }, delay);\n      } else {\n        instance.show();\n      }\n    }\n    function scheduleHide(event) {\n      instance.clearDelayTimeouts();\n      invokeHook(\"onUntrigger\", [instance, event]);\n      if (!instance.state.isVisible) {\n        removeDocumentPress();\n        return;\n      }\n      if (instance.props.trigger.indexOf(\"mouseenter\") >= 0 && instance.props.trigger.indexOf(\"click\") >= 0 && [\"mouseleave\", \"mousemove\"].indexOf(event.type) >= 0 && isVisibleFromClick) {\n        return;\n      }\n      var delay = getDelay(false);\n      if (delay) {\n        hideTimeout = setTimeout(function() {\n          if (instance.state.isVisible) {\n            instance.hide();\n          }\n        }, delay);\n      } else {\n        scheduleHideAnimationFrame = requestAnimationFrame(function() {\n          instance.hide();\n        });\n      }\n    }\n    function enable() {\n      instance.state.isEnabled = true;\n    }\n    function disable() {\n      instance.hide();\n      instance.state.isEnabled = false;\n    }\n    function clearDelayTimeouts() {\n      clearTimeout(showTimeout);\n      clearTimeout(hideTimeout);\n      cancelAnimationFrame(scheduleHideAnimationFrame);\n    }\n    function setProps(partialProps) {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"setProps\"));\n      }\n      if (instance.state.isDestroyed) {\n        return;\n      }\n      invokeHook(\"onBeforeUpdate\", [instance, partialProps]);\n      removeListeners();\n      var prevProps = instance.props;\n      var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n        ignoreAttributes: true\n      }));\n      instance.props = nextProps;\n      addListeners();\n      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n        cleanupInteractiveMouseListeners();\n        debouncedOnMouseMove = debounce2(onMouseMove, nextProps.interactiveDebounce);\n      }\n      if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n        normalizeToArray(prevProps.triggerTarget).forEach(function(node) {\n          node.removeAttribute(\"aria-expanded\");\n        });\n      } else if (nextProps.triggerTarget) {\n        reference2.removeAttribute(\"aria-expanded\");\n      }\n      handleAriaExpandedAttribute();\n      handleStyles();\n      if (onUpdate) {\n        onUpdate(prevProps, nextProps);\n      }\n      if (instance.popperInstance) {\n        createPopperInstance();\n        getNestedPopperTree().forEach(function(nestedPopper) {\n          requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n        });\n      }\n      invokeHook(\"onAfterUpdate\", [instance, partialProps]);\n    }\n    function setContent2(content) {\n      instance.setProps({\n        content\n      });\n    }\n    function show() {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"show\"));\n      }\n      var isAlreadyVisible = instance.state.isVisible;\n      var isDestroyed = instance.state.isDestroyed;\n      var isDisabled = !instance.state.isEnabled;\n      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n      var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n        return;\n      }\n      if (getCurrentTarget().hasAttribute(\"disabled\")) {\n        return;\n      }\n      invokeHook(\"onShow\", [instance], false);\n      if (instance.props.onShow(instance) === false) {\n        return;\n      }\n      instance.state.isVisible = true;\n      if (getIsDefaultRenderFn()) {\n        popper2.style.visibility = \"visible\";\n      }\n      handleStyles();\n      addDocumentPress();\n      if (!instance.state.isMounted) {\n        popper2.style.transition = \"none\";\n      }\n      if (getIsDefaultRenderFn()) {\n        var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;\n        setTransitionDuration([box, content], 0);\n      }\n      onFirstUpdate = function onFirstUpdate2() {\n        var _instance$popperInsta2;\n        if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n          return;\n        }\n        ignoreOnFirstUpdate = true;\n        void popper2.offsetHeight;\n        popper2.style.transition = instance.props.moveTransition;\n        if (getIsDefaultRenderFn() && instance.props.animation) {\n          var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;\n          setTransitionDuration([_box, _content], duration);\n          setVisibilityState([_box, _content], \"visible\");\n        }\n        handleAriaContentAttribute();\n        handleAriaExpandedAttribute();\n        pushIfUnique(mountedInstances, instance);\n        (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n        invokeHook(\"onMount\", [instance]);\n        if (instance.props.animation && getIsDefaultRenderFn()) {\n          onTransitionedIn(duration, function() {\n            instance.state.isShown = true;\n            invokeHook(\"onShown\", [instance]);\n          });\n        }\n      };\n      mount();\n    }\n    function hide2() {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hide\"));\n      }\n      var isAlreadyHidden = !instance.state.isVisible;\n      var isDestroyed = instance.state.isDestroyed;\n      var isDisabled = !instance.state.isEnabled;\n      var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n      if (isAlreadyHidden || isDestroyed || isDisabled) {\n        return;\n      }\n      invokeHook(\"onHide\", [instance], false);\n      if (instance.props.onHide(instance) === false) {\n        return;\n      }\n      instance.state.isVisible = false;\n      instance.state.isShown = false;\n      ignoreOnFirstUpdate = false;\n      isVisibleFromClick = false;\n      if (getIsDefaultRenderFn()) {\n        popper2.style.visibility = \"hidden\";\n      }\n      cleanupInteractiveMouseListeners();\n      removeDocumentPress();\n      handleStyles(true);\n      if (getIsDefaultRenderFn()) {\n        var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;\n        if (instance.props.animation) {\n          setTransitionDuration([box, content], duration);\n          setVisibilityState([box, content], \"hidden\");\n        }\n      }\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      if (instance.props.animation) {\n        if (getIsDefaultRenderFn()) {\n          onTransitionedOut(duration, instance.unmount);\n        }\n      } else {\n        instance.unmount();\n      }\n    }\n    function hideWithInteractivity(event) {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"hideWithInteractivity\"));\n      }\n      getDocument2().addEventListener(\"mousemove\", debouncedOnMouseMove);\n      pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n      debouncedOnMouseMove(event);\n    }\n    function unmount() {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"unmount\"));\n      }\n      if (instance.state.isVisible) {\n        instance.hide();\n      }\n      if (!instance.state.isMounted) {\n        return;\n      }\n      destroyPopperInstance();\n      getNestedPopperTree().forEach(function(nestedPopper) {\n        nestedPopper._tippy.unmount();\n      });\n      if (popper2.parentNode) {\n        popper2.parentNode.removeChild(popper2);\n      }\n      mountedInstances = mountedInstances.filter(function(i) {\n        return i !== instance;\n      });\n      instance.state.isMounted = false;\n      invokeHook(\"onHidden\", [instance]);\n    }\n    function destroy() {\n      if (true) {\n        warnWhen(instance.state.isDestroyed, createMemoryLeakWarning(\"destroy\"));\n      }\n      if (instance.state.isDestroyed) {\n        return;\n      }\n      instance.clearDelayTimeouts();\n      instance.unmount();\n      removeListeners();\n      delete reference2._tippy;\n      instance.state.isDestroyed = true;\n      invokeHook(\"onDestroy\", [instance]);\n    }\n  }\n  function tippy(targets, optionalProps) {\n    if (optionalProps === void 0) {\n      optionalProps = {};\n    }\n    var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n    if (true) {\n      validateTargets(targets);\n      validateProps(optionalProps, plugins);\n    }\n    bindGlobalEventListeners();\n    var passedProps = Object.assign({}, optionalProps, {\n      plugins\n    });\n    var elements = getArrayOfElements(targets);\n    if (true) {\n      var isSingleContentElement = isElement2(passedProps.content);\n      var isMoreThanOneReferenceElement = elements.length > 1;\n      warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, [\"tippy() was passed an Element as the `content` prop, but more than\", \"one tippy instance was created by this invocation. This means the\", \"content element will only be appended to the last tippy instance.\", \"\\n\\n\", \"Instead, pass the .innerHTML of the element, or use a function that\", \"returns a cloned version of the element instead.\", \"\\n\\n\", \"1) content: element.innerHTML\\n\", \"2) content: () => element.cloneNode(true)\"].join(\" \"));\n    }\n    var instances = elements.reduce(function(acc, reference2) {\n      var instance = reference2 && createTippy(reference2, passedProps);\n      if (instance) {\n        acc.push(instance);\n      }\n      return acc;\n    }, []);\n    return isElement2(targets) ? instances[0] : instances;\n  }\n  tippy.defaultProps = defaultProps;\n  tippy.setDefaultProps = setDefaultProps;\n  tippy.currentInput = currentInput;\n  var applyStylesModifier = Object.assign({}, applyStyles_default, {\n    effect: function effect4(_ref) {\n      var state = _ref.state;\n      var initialStyles = {\n        popper: {\n          position: state.options.strategy,\n          left: \"0\",\n          top: \"0\",\n          margin: \"0\"\n        },\n        arrow: {\n          position: \"absolute\"\n        },\n        reference: {}\n      };\n      Object.assign(state.elements.popper.style, initialStyles.popper);\n      state.styles = initialStyles;\n      if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n      }\n    }\n  });\n  tippy.setDefaultProps({\n    render\n  });\n  var tippy_esm_default = tippy;\n\n  // node_modules/@sentry/utils/esm/is.js\n  var objectToString = Object.prototype.toString;\n  function isError(wat) {\n    switch (objectToString.call(wat)) {\n      case \"[object Error]\":\n      case \"[object Exception]\":\n      case \"[object DOMException]\":\n        return true;\n      default:\n        return isInstanceOf(wat, Error);\n    }\n  }\n  function isBuiltin(wat, className) {\n    return objectToString.call(wat) === `[object ${className}]`;\n  }\n  function isErrorEvent(wat) {\n    return isBuiltin(wat, \"ErrorEvent\");\n  }\n  function isDOMError(wat) {\n    return isBuiltin(wat, \"DOMError\");\n  }\n  function isDOMException(wat) {\n    return isBuiltin(wat, \"DOMException\");\n  }\n  function isString(wat) {\n    return isBuiltin(wat, \"String\");\n  }\n  function isParameterizedString(wat) {\n    return typeof wat === \"object\" && wat !== null && \"__sentry_template_string__\" in wat && \"__sentry_template_values__\" in wat;\n  }\n  function isPrimitive(wat) {\n    return wat === null || isParameterizedString(wat) || typeof wat !== \"object\" && typeof wat !== \"function\";\n  }\n  function isPlainObject(wat) {\n    return isBuiltin(wat, \"Object\");\n  }\n  function isEvent(wat) {\n    return typeof Event !== \"undefined\" && isInstanceOf(wat, Event);\n  }\n  function isElement3(wat) {\n    return typeof Element !== \"undefined\" && isInstanceOf(wat, Element);\n  }\n  function isRegExp(wat) {\n    return isBuiltin(wat, \"RegExp\");\n  }\n  function isThenable(wat) {\n    return Boolean(wat && wat.then && typeof wat.then === \"function\");\n  }\n  function isSyntheticEvent(wat) {\n    return isPlainObject(wat) && \"nativeEvent\" in wat && \"preventDefault\" in wat && \"stopPropagation\" in wat;\n  }\n  function isInstanceOf(wat, base) {\n    try {\n      return wat instanceof base;\n    } catch (_e) {\n      return false;\n    }\n  }\n  function isVueViewModel(wat) {\n    return !!(typeof wat === \"object\" && wat !== null && (wat.__isVue || wat._isVue));\n  }\n\n  // node_modules/@sentry/utils/esm/string.js\n  function truncate(str2, max2 = 0) {\n    if (typeof str2 !== \"string\" || max2 === 0) {\n      return str2;\n    }\n    return str2.length <= max2 ? str2 : `${str2.slice(0, max2)}...`;\n  }\n  function safeJoin(input, delimiter) {\n    if (!Array.isArray(input)) {\n      return \"\";\n    }\n    const output = [];\n    for (let i = 0; i < input.length; i++) {\n      const value = input[i];\n      try {\n        if (isVueViewModel(value)) {\n          output.push(\"[VueViewModel]\");\n        } else {\n          output.push(String(value));\n        }\n      } catch (e2) {\n        output.push(\"[value cannot be serialized]\");\n      }\n    }\n    return output.join(delimiter);\n  }\n  function isMatchingPattern(value, pattern, requireExactStringMatch = false) {\n    if (!isString(value)) {\n      return false;\n    }\n    if (isRegExp(pattern)) {\n      return pattern.test(value);\n    }\n    if (isString(pattern)) {\n      return requireExactStringMatch ? value === pattern : value.includes(pattern);\n    }\n    return false;\n  }\n  function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {\n    return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));\n  }\n\n  // node_modules/@sentry/utils/esm/aggregate-errors.js\n  function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {\n    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n      return;\n    }\n    const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;\n    if (originalException) {\n      event.exception.values = truncateAggregateExceptions(\n        aggregateExceptionsFromError(\n          exceptionFromErrorImplementation,\n          parser,\n          limit,\n          hint.originalException,\n          key,\n          event.exception.values,\n          originalException,\n          0\n        ),\n        maxValueLimit\n      );\n    }\n  }\n  function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {\n    if (prevExceptions.length >= limit + 1) {\n      return prevExceptions;\n    }\n    let newExceptions = [...prevExceptions];\n    if (isInstanceOf(error[key], Error)) {\n      applyExceptionGroupFieldsForParentException(exception, exceptionId);\n      const newException = exceptionFromErrorImplementation(parser, error[key]);\n      const newExceptionId = newExceptions.length;\n      applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);\n      newExceptions = aggregateExceptionsFromError(\n        exceptionFromErrorImplementation,\n        parser,\n        limit,\n        error[key],\n        key,\n        [newException, ...newExceptions],\n        newException,\n        newExceptionId\n      );\n    }\n    if (Array.isArray(error.errors)) {\n      error.errors.forEach((childError, i) => {\n        if (isInstanceOf(childError, Error)) {\n          applyExceptionGroupFieldsForParentException(exception, exceptionId);\n          const newException = exceptionFromErrorImplementation(parser, childError);\n          const newExceptionId = newExceptions.length;\n          applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);\n          newExceptions = aggregateExceptionsFromError(\n            exceptionFromErrorImplementation,\n            parser,\n            limit,\n            childError,\n            key,\n            [newException, ...newExceptions],\n            newException,\n            newExceptionId\n          );\n        }\n      });\n    }\n    return newExceptions;\n  }\n  function applyExceptionGroupFieldsForParentException(exception, exceptionId) {\n    exception.mechanism = exception.mechanism || { type: \"generic\", handled: true };\n    exception.mechanism = {\n      ...exception.mechanism,\n      ...exception.type === \"AggregateError\" && { is_exception_group: true },\n      exception_id: exceptionId\n    };\n  }\n  function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {\n    exception.mechanism = exception.mechanism || { type: \"generic\", handled: true };\n    exception.mechanism = {\n      ...exception.mechanism,\n      type: \"chained\",\n      source,\n      exception_id: exceptionId,\n      parent_id: parentId\n    };\n  }\n  function truncateAggregateExceptions(exceptions, maxValueLength) {\n    return exceptions.map((exception) => {\n      if (exception.value) {\n        exception.value = truncate(exception.value, maxValueLength);\n      }\n      return exception;\n    });\n  }\n\n  // node_modules/@sentry/utils/esm/version.js\n  var SDK_VERSION = \"8.11.0\";\n\n  // node_modules/@sentry/utils/esm/worldwide.js\n  var GLOBAL_OBJ = globalThis;\n  function getGlobalSingleton(name2, creator, obj) {\n    const gbl = obj || GLOBAL_OBJ;\n    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};\n    const versionedCarrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};\n    return versionedCarrier[name2] || (versionedCarrier[name2] = creator());\n  }\n\n  // node_modules/@sentry/utils/esm/browser.js\n  var WINDOW = GLOBAL_OBJ;\n  var DEFAULT_MAX_STRING_LENGTH = 80;\n  function htmlTreeAsString(elem, options = {}) {\n    if (!elem) {\n      return \"<unknown>\";\n    }\n    try {\n      let currentElem = elem;\n      const MAX_TRAVERSE_HEIGHT = 5;\n      const out = [];\n      let height = 0;\n      let len = 0;\n      const separator = \" > \";\n      const sepLength = separator.length;\n      let nextStr;\n      const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;\n      const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;\n      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n        nextStr = _htmlElementAsString(currentElem, keyAttrs);\n        if (nextStr === \"html\" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {\n          break;\n        }\n        out.push(nextStr);\n        len += nextStr.length;\n        currentElem = currentElem.parentNode;\n      }\n      return out.reverse().join(separator);\n    } catch (_oO) {\n      return \"<unknown>\";\n    }\n  }\n  function _htmlElementAsString(el, keyAttrs) {\n    const elem = el;\n    const out = [];\n    if (!elem || !elem.tagName) {\n      return \"\";\n    }\n    if (WINDOW.HTMLElement) {\n      if (elem instanceof HTMLElement && elem.dataset) {\n        if (elem.dataset[\"sentryComponent\"]) {\n          return elem.dataset[\"sentryComponent\"];\n        }\n        if (elem.dataset[\"sentryElement\"]) {\n          return elem.dataset[\"sentryElement\"];\n        }\n      }\n    }\n    out.push(elem.tagName.toLowerCase());\n    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;\n    if (keyAttrPairs && keyAttrPairs.length) {\n      keyAttrPairs.forEach((keyAttrPair) => {\n        out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n      });\n    } else {\n      if (elem.id) {\n        out.push(`#${elem.id}`);\n      }\n      const className = elem.className;\n      if (className && isString(className)) {\n        const classes = className.split(/\\s+/);\n        for (const c of classes) {\n          out.push(`.${c}`);\n        }\n      }\n    }\n    const allowedAttrs = [\"aria-label\", \"type\", \"name\", \"title\", \"alt\"];\n    for (const k of allowedAttrs) {\n      const attr = elem.getAttribute(k);\n      if (attr) {\n        out.push(`[${k}=\"${attr}\"]`);\n      }\n    }\n    return out.join(\"\");\n  }\n  function getLocationHref() {\n    try {\n      return WINDOW.document.location.href;\n    } catch (oO) {\n      return \"\";\n    }\n  }\n  function getDomElement(selector) {\n    if (WINDOW.document && WINDOW.document.querySelector) {\n      return WINDOW.document.querySelector(selector);\n    }\n    return null;\n  }\n  function getComponentName(elem) {\n    if (!WINDOW.HTMLElement) {\n      return null;\n    }\n    let currentElem = elem;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {\n      if (!currentElem) {\n        return null;\n      }\n      if (currentElem instanceof HTMLElement) {\n        if (currentElem.dataset[\"sentryComponent\"]) {\n          return currentElem.dataset[\"sentryComponent\"];\n        }\n        if (currentElem.dataset[\"sentryElement\"]) {\n          return currentElem.dataset[\"sentryElement\"];\n        }\n      }\n      currentElem = currentElem.parentNode;\n    }\n    return null;\n  }\n\n  // node_modules/@sentry/utils/esm/debug-build.js\n  var DEBUG_BUILD = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n\n  // node_modules/@sentry/utils/esm/logger.js\n  var PREFIX = \"Sentry Logger \";\n  var CONSOLE_LEVELS = [\n    \"debug\",\n    \"info\",\n    \"warn\",\n    \"error\",\n    \"log\",\n    \"assert\",\n    \"trace\"\n  ];\n  var originalConsoleMethods = {};\n  function consoleSandbox(callback) {\n    if (!(\"console\" in GLOBAL_OBJ)) {\n      return callback();\n    }\n    const console2 = GLOBAL_OBJ.console;\n    const wrappedFuncs = {};\n    const wrappedLevels = Object.keys(originalConsoleMethods);\n    wrappedLevels.forEach((level) => {\n      const originalConsoleMethod = originalConsoleMethods[level];\n      wrappedFuncs[level] = console2[level];\n      console2[level] = originalConsoleMethod;\n    });\n    try {\n      return callback();\n    } finally {\n      wrappedLevels.forEach((level) => {\n        console2[level] = wrappedFuncs[level];\n      });\n    }\n  }\n  function makeLogger() {\n    let enabled = false;\n    const logger2 = {\n      enable: () => {\n        enabled = true;\n      },\n      disable: () => {\n        enabled = false;\n      },\n      isEnabled: () => enabled\n    };\n    if (DEBUG_BUILD) {\n      CONSOLE_LEVELS.forEach((name2) => {\n        logger2[name2] = (...args) => {\n          if (enabled) {\n            consoleSandbox(() => {\n              GLOBAL_OBJ.console[name2](`${PREFIX}[${name2}]:`, ...args);\n            });\n          }\n        };\n      });\n    } else {\n      CONSOLE_LEVELS.forEach((name2) => {\n        logger2[name2] = () => void 0;\n      });\n    }\n    return logger2;\n  }\n  var logger = makeLogger();\n\n  // node_modules/@sentry/utils/esm/dsn.js\n  var DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n  function isValidProtocol(protocol) {\n    return protocol === \"http\" || protocol === \"https\";\n  }\n  function dsnToString(dsn, withPassword = false) {\n    const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n    return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : \"\"}@${host}${port ? `:${port}` : \"\"}/${path ? `${path}/` : path}${projectId}`;\n  }\n  function dsnFromString(str2) {\n    const match = DSN_REGEX.exec(str2);\n    if (!match) {\n      consoleSandbox(() => {\n        console.error(`Invalid Sentry Dsn: ${str2}`);\n      });\n      return void 0;\n    }\n    const [protocol, publicKey, pass = \"\", host = \"\", port = \"\", lastPath = \"\"] = match.slice(1);\n    let path = \"\";\n    let projectId = lastPath;\n    const split = projectId.split(\"/\");\n    if (split.length > 1) {\n      path = split.slice(0, -1).join(\"/\");\n      projectId = split.pop();\n    }\n    if (projectId) {\n      const projectMatch = projectId.match(/^\\d+/);\n      if (projectMatch) {\n        projectId = projectMatch[0];\n      }\n    }\n    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });\n  }\n  function dsnFromComponents(components) {\n    return {\n      protocol: components.protocol,\n      publicKey: components.publicKey || \"\",\n      pass: components.pass || \"\",\n      host: components.host,\n      port: components.port || \"\",\n      path: components.path || \"\",\n      projectId: components.projectId\n    };\n  }\n  function validateDsn(dsn) {\n    if (!DEBUG_BUILD) {\n      return true;\n    }\n    const { port, projectId, protocol } = dsn;\n    const requiredComponents = [\"protocol\", \"publicKey\", \"host\", \"projectId\"];\n    const hasMissingRequiredComponent = requiredComponents.find((component) => {\n      if (!dsn[component]) {\n        logger.error(`Invalid Sentry Dsn: ${component} missing`);\n        return true;\n      }\n      return false;\n    });\n    if (hasMissingRequiredComponent) {\n      return false;\n    }\n    if (!projectId.match(/^\\d+$/)) {\n      logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n      return false;\n    }\n    if (!isValidProtocol(protocol)) {\n      logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n      return false;\n    }\n    if (port && isNaN(parseInt(port, 10))) {\n      logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);\n      return false;\n    }\n    return true;\n  }\n  function makeDsn(from) {\n    const components = typeof from === \"string\" ? dsnFromString(from) : dsnFromComponents(from);\n    if (!components || !validateDsn(components)) {\n      return void 0;\n    }\n    return components;\n  }\n\n  // node_modules/@sentry/utils/esm/error.js\n  var SentryError = class extends Error {\n    /** Display name of this error instance. */\n    constructor(message, logLevel = \"warn\") {\n      super(message);\n      this.message = message;\n      this.name = new.target.prototype.constructor.name;\n      Object.setPrototypeOf(this, new.target.prototype);\n      this.logLevel = logLevel;\n    }\n  };\n\n  // node_modules/@sentry/utils/esm/object.js\n  function fill(source, name2, replacementFactory) {\n    if (!(name2 in source)) {\n      return;\n    }\n    const original = source[name2];\n    const wrapped = replacementFactory(original);\n    if (typeof wrapped === \"function\") {\n      markFunctionWrapped(wrapped, original);\n    }\n    source[name2] = wrapped;\n  }\n  function addNonEnumerableProperty(obj, name2, value) {\n    try {\n      Object.defineProperty(obj, name2, {\n        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n        value,\n        writable: true,\n        configurable: true\n      });\n    } catch (o_O) {\n      DEBUG_BUILD && logger.log(`Failed to add non-enumerable property \"${name2}\" to object`, obj);\n    }\n  }\n  function markFunctionWrapped(wrapped, original) {\n    try {\n      const proto = original.prototype || {};\n      wrapped.prototype = original.prototype = proto;\n      addNonEnumerableProperty(wrapped, \"__sentry_original__\", original);\n    } catch (o_O) {\n    }\n  }\n  function getOriginalFunction(func) {\n    return func.__sentry_original__;\n  }\n  function urlEncode2(object) {\n    return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join(\"&\");\n  }\n  function convertToPlainObject(value) {\n    if (isError(value)) {\n      return {\n        message: value.message,\n        name: value.name,\n        stack: value.stack,\n        ...getOwnProperties(value)\n      };\n    } else if (isEvent(value)) {\n      const newObj = {\n        type: value.type,\n        target: serializeEventTarget(value.target),\n        currentTarget: serializeEventTarget(value.currentTarget),\n        ...getOwnProperties(value)\n      };\n      if (typeof CustomEvent !== \"undefined\" && isInstanceOf(value, CustomEvent)) {\n        newObj.detail = value.detail;\n      }\n      return newObj;\n    } else {\n      return value;\n    }\n  }\n  function serializeEventTarget(target) {\n    try {\n      return isElement3(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n    } catch (_oO) {\n      return \"<unknown>\";\n    }\n  }\n  function getOwnProperties(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n      const extractedProps = {};\n      for (const property in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, property)) {\n          extractedProps[property] = obj[property];\n        }\n      }\n      return extractedProps;\n    } else {\n      return {};\n    }\n  }\n  function extractExceptionKeysForMessage(exception, maxLength = 40) {\n    const keys = Object.keys(convertToPlainObject(exception));\n    keys.sort();\n    const firstKey = keys[0];\n    if (!firstKey) {\n      return \"[object has no keys]\";\n    }\n    if (firstKey.length >= maxLength) {\n      return truncate(firstKey, maxLength);\n    }\n    for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n      const serialized = keys.slice(0, includedKeys).join(\", \");\n      if (serialized.length > maxLength) {\n        continue;\n      }\n      if (includedKeys === keys.length) {\n        return serialized;\n      }\n      return truncate(serialized, maxLength);\n    }\n    return \"\";\n  }\n  function dropUndefinedKeys(inputValue) {\n    const memoizationMap = /* @__PURE__ */ new Map();\n    return _dropUndefinedKeys(inputValue, memoizationMap);\n  }\n  function _dropUndefinedKeys(inputValue, memoizationMap) {\n    if (isPojo(inputValue)) {\n      const memoVal = memoizationMap.get(inputValue);\n      if (memoVal !== void 0) {\n        return memoVal;\n      }\n      const returnValue = {};\n      memoizationMap.set(inputValue, returnValue);\n      for (const key of Object.keys(inputValue)) {\n        if (typeof inputValue[key] !== \"undefined\") {\n          returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);\n        }\n      }\n      return returnValue;\n    }\n    if (Array.isArray(inputValue)) {\n      const memoVal = memoizationMap.get(inputValue);\n      if (memoVal !== void 0) {\n        return memoVal;\n      }\n      const returnValue = [];\n      memoizationMap.set(inputValue, returnValue);\n      inputValue.forEach((item) => {\n        returnValue.push(_dropUndefinedKeys(item, memoizationMap));\n      });\n      return returnValue;\n    }\n    return inputValue;\n  }\n  function isPojo(input) {\n    if (!isPlainObject(input)) {\n      return false;\n    }\n    try {\n      const name2 = Object.getPrototypeOf(input).constructor.name;\n      return !name2 || name2 === \"Object\";\n    } catch (e2) {\n      return true;\n    }\n  }\n\n  // node_modules/@sentry/utils/esm/stacktrace.js\n  var STACKTRACE_FRAME_LIMIT = 50;\n  var UNKNOWN_FUNCTION = \"?\";\n  var WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\n  var STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n  function createStackParser(...parsers) {\n    const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map((p) => p[1]);\n    return (stack, skipFirstLines = 0, framesToPop = 0) => {\n      const frames = [];\n      const lines = stack.split(\"\\n\");\n      for (let i = skipFirstLines; i < lines.length; i++) {\n        const line = lines[i];\n        if (line.length > 1024) {\n          continue;\n        }\n        const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, \"$1\") : line;\n        if (cleanedLine.match(/\\S*Error: /)) {\n          continue;\n        }\n        for (const parser of sortedParsers) {\n          const frame = parser(cleanedLine);\n          if (frame) {\n            frames.push(frame);\n            break;\n          }\n        }\n        if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n          break;\n        }\n      }\n      return stripSentryFramesAndReverse(frames.slice(framesToPop));\n    };\n  }\n  function stackParserFromStackParserOptions(stackParser) {\n    if (Array.isArray(stackParser)) {\n      return createStackParser(...stackParser);\n    }\n    return stackParser;\n  }\n  function stripSentryFramesAndReverse(stack) {\n    if (!stack.length) {\n      return [];\n    }\n    const localStack = Array.from(stack);\n    if (/sentryWrapped/.test(getLastStackFrame(localStack).function || \"\")) {\n      localStack.pop();\n    }\n    localStack.reverse();\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || \"\")) {\n      localStack.pop();\n      if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || \"\")) {\n        localStack.pop();\n      }\n    }\n    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({\n      ...frame,\n      filename: frame.filename || getLastStackFrame(localStack).filename,\n      function: frame.function || UNKNOWN_FUNCTION\n    }));\n  }\n  function getLastStackFrame(arr) {\n    return arr[arr.length - 1] || {};\n  }\n  var defaultFunctionName = \"<anonymous>\";\n  function getFunctionName(fn2) {\n    try {\n      if (!fn2 || typeof fn2 !== \"function\") {\n        return defaultFunctionName;\n      }\n      return fn2.name || defaultFunctionName;\n    } catch (e2) {\n      return defaultFunctionName;\n    }\n  }\n  function getFramesFromEvent(event) {\n    const exception = event.exception;\n    if (exception) {\n      const frames = [];\n      try {\n        exception.values.forEach((value) => {\n          if (value.stacktrace.frames) {\n            frames.push(...value.stacktrace.frames);\n          }\n        });\n        return frames;\n      } catch (_oO) {\n        return void 0;\n      }\n    }\n    return void 0;\n  }\n\n  // node_modules/@sentry/utils/esm/instrument/handlers.js\n  var handlers = {};\n  var instrumented = {};\n  function addHandler(type, handler) {\n    handlers[type] = handlers[type] || [];\n    handlers[type].push(handler);\n  }\n  function maybeInstrument(type, instrumentFn) {\n    if (!instrumented[type]) {\n      instrumentFn();\n      instrumented[type] = true;\n    }\n  }\n  function triggerHandlers(type, data) {\n    const typeHandlers = type && handlers[type];\n    if (!typeHandlers) {\n      return;\n    }\n    for (const handler of typeHandlers) {\n      try {\n        handler(data);\n      } catch (e2) {\n        DEBUG_BUILD && logger.error(\n          `Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`,\n          e2\n        );\n      }\n    }\n  }\n\n  // node_modules/@sentry/utils/esm/instrument/console.js\n  function addConsoleInstrumentationHandler(handler) {\n    const type = \"console\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentConsole);\n  }\n  function instrumentConsole() {\n    if (!(\"console\" in GLOBAL_OBJ)) {\n      return;\n    }\n    CONSOLE_LEVELS.forEach(function(level) {\n      if (!(level in GLOBAL_OBJ.console)) {\n        return;\n      }\n      fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {\n        originalConsoleMethods[level] = originalConsoleMethod;\n        return function(...args) {\n          const handlerData = { args, level };\n          triggerHandlers(\"console\", handlerData);\n          const log = originalConsoleMethods[level];\n          log && log.apply(GLOBAL_OBJ.console, args);\n        };\n      });\n    });\n  }\n\n  // node_modules/@sentry/utils/esm/supports.js\n  var WINDOW2 = GLOBAL_OBJ;\n  function supportsFetch() {\n    if (!(\"fetch\" in WINDOW2)) {\n      return false;\n    }\n    try {\n      new Headers();\n      new Request(\"http://www.example.com\");\n      new Response();\n      return true;\n    } catch (e2) {\n      return false;\n    }\n  }\n  function isNativeFunction(func) {\n    return func && /^function\\s+\\w+\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n  }\n  function supportsNativeFetch() {\n    if (typeof EdgeRuntime === \"string\") {\n      return true;\n    }\n    if (!supportsFetch()) {\n      return false;\n    }\n    if (isNativeFunction(WINDOW2.fetch)) {\n      return true;\n    }\n    let result = false;\n    const doc = WINDOW2.document;\n    if (doc && typeof doc.createElement === \"function\") {\n      try {\n        const sandbox = doc.createElement(\"iframe\");\n        sandbox.hidden = true;\n        doc.head.appendChild(sandbox);\n        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n          result = isNativeFunction(sandbox.contentWindow.fetch);\n        }\n        doc.head.removeChild(sandbox);\n      } catch (err) {\n        DEBUG_BUILD && logger.warn(\"Could not create sandbox iframe for pure fetch check, bailing to window.fetch: \", err);\n      }\n    }\n    return result;\n  }\n\n  // node_modules/@sentry/utils/esm/time.js\n  var ONE_SECOND_IN_MS = 1e3;\n  function dateTimestampInSeconds() {\n    return Date.now() / ONE_SECOND_IN_MS;\n  }\n  function createUnixTimestampInSecondsFunc() {\n    const { performance: performance2 } = GLOBAL_OBJ;\n    if (!performance2 || !performance2.now) {\n      return dateTimestampInSeconds;\n    }\n    const approxStartingTimeOrigin = Date.now() - performance2.now();\n    const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;\n    return () => {\n      return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;\n    };\n  }\n  var timestampInSeconds = createUnixTimestampInSecondsFunc();\n  var _browserPerformanceTimeOriginMode;\n  var browserPerformanceTimeOrigin = (() => {\n    const { performance: performance2 } = GLOBAL_OBJ;\n    if (!performance2 || !performance2.now) {\n      _browserPerformanceTimeOriginMode = \"none\";\n      return void 0;\n    }\n    const threshold = 3600 * 1e3;\n    const performanceNow = performance2.now();\n    const dateNow = Date.now();\n    const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;\n    const timeOriginIsReliable = timeOriginDelta < threshold;\n    const navigationStart = performance2.timing && performance2.timing.navigationStart;\n    const hasNavigationStart = typeof navigationStart === \"number\";\n    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;\n    const navigationStartIsReliable = navigationStartDelta < threshold;\n    if (timeOriginIsReliable || navigationStartIsReliable) {\n      if (timeOriginDelta <= navigationStartDelta) {\n        _browserPerformanceTimeOriginMode = \"timeOrigin\";\n        return performance2.timeOrigin;\n      } else {\n        _browserPerformanceTimeOriginMode = \"navigationStart\";\n        return navigationStart;\n      }\n    }\n    _browserPerformanceTimeOriginMode = \"dateNow\";\n    return dateNow;\n  })();\n\n  // node_modules/@sentry/utils/esm/instrument/fetch.js\n  function addFetchInstrumentationHandler(handler) {\n    const type = \"fetch\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentFetch);\n  }\n  function instrumentFetch() {\n    if (!supportsNativeFetch()) {\n      return;\n    }\n    fill(GLOBAL_OBJ, \"fetch\", function(originalFetch) {\n      return function(...args) {\n        const { method, url } = parseFetchArgs(args);\n        const handlerData = {\n          args,\n          fetchData: {\n            method,\n            url\n          },\n          startTimestamp: timestampInSeconds() * 1e3\n        };\n        triggerHandlers(\"fetch\", {\n          ...handlerData\n        });\n        const virtualStackTrace = new Error().stack;\n        return originalFetch.apply(GLOBAL_OBJ, args).then(\n          (response) => {\n            const finishedHandlerData = {\n              ...handlerData,\n              endTimestamp: timestampInSeconds() * 1e3,\n              response\n            };\n            triggerHandlers(\"fetch\", finishedHandlerData);\n            return response;\n          },\n          (error) => {\n            const erroredHandlerData = {\n              ...handlerData,\n              endTimestamp: timestampInSeconds() * 1e3,\n              error\n            };\n            triggerHandlers(\"fetch\", erroredHandlerData);\n            if (isError(error) && error.stack === void 0) {\n              error.stack = virtualStackTrace;\n              addNonEnumerableProperty(error, \"framesToPop\", 1);\n            }\n            throw error;\n          }\n        );\n      };\n    });\n  }\n  function hasProp(obj, prop) {\n    return !!obj && typeof obj === \"object\" && !!obj[prop];\n  }\n  function getUrlFromResource(resource) {\n    if (typeof resource === \"string\") {\n      return resource;\n    }\n    if (!resource) {\n      return \"\";\n    }\n    if (hasProp(resource, \"url\")) {\n      return resource.url;\n    }\n    if (resource.toString) {\n      return resource.toString();\n    }\n    return \"\";\n  }\n  function parseFetchArgs(fetchArgs) {\n    if (fetchArgs.length === 0) {\n      return { method: \"GET\", url: \"\" };\n    }\n    if (fetchArgs.length === 2) {\n      const [url, options] = fetchArgs;\n      return {\n        url: getUrlFromResource(url),\n        method: hasProp(options, \"method\") ? String(options.method).toUpperCase() : \"GET\"\n      };\n    }\n    const arg = fetchArgs[0];\n    return {\n      url: getUrlFromResource(arg),\n      method: hasProp(arg, \"method\") ? String(arg.method).toUpperCase() : \"GET\"\n    };\n  }\n\n  // node_modules/@sentry/utils/esm/instrument/globalError.js\n  var _oldOnErrorHandler = null;\n  function addGlobalErrorInstrumentationHandler(handler) {\n    const type = \"error\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentError);\n  }\n  function instrumentError() {\n    _oldOnErrorHandler = GLOBAL_OBJ.onerror;\n    GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {\n      const handlerData = {\n        column,\n        error,\n        line,\n        msg,\n        url\n      };\n      triggerHandlers(\"error\", handlerData);\n      if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {\n        return _oldOnErrorHandler.apply(this, arguments);\n      }\n      return false;\n    };\n    GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;\n  }\n\n  // node_modules/@sentry/utils/esm/instrument/globalUnhandledRejection.js\n  var _oldOnUnhandledRejectionHandler = null;\n  function addGlobalUnhandledRejectionInstrumentationHandler(handler) {\n    const type = \"unhandledrejection\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentUnhandledRejection);\n  }\n  function instrumentUnhandledRejection() {\n    _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;\n    GLOBAL_OBJ.onunhandledrejection = function(e2) {\n      const handlerData = e2;\n      triggerHandlers(\"unhandledrejection\", handlerData);\n      if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {\n        return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n      }\n      return true;\n    };\n    GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n  }\n\n  // node_modules/@sentry/utils/esm/env.js\n  function isBrowserBundle() {\n    return typeof __SENTRY_BROWSER_BUNDLE__ !== \"undefined\" && !!__SENTRY_BROWSER_BUNDLE__;\n  }\n  function getSDKSource() {\n    return \"npm\";\n  }\n\n  // node_modules/@sentry/utils/esm/node.js\n  function isNodeEnv() {\n    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== \"undefined\" ? process : 0) === \"[object process]\";\n  }\n\n  // node_modules/@sentry/utils/esm/isBrowser.js\n  function isBrowser2() {\n    return typeof window !== \"undefined\" && (!isNodeEnv() || isElectronNodeRenderer());\n  }\n  function isElectronNodeRenderer() {\n    return (\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      GLOBAL_OBJ.process !== void 0 && GLOBAL_OBJ.process.type === \"renderer\"\n    );\n  }\n\n  // node_modules/@sentry/utils/esm/memo.js\n  function memoBuilder() {\n    const hasWeakSet = typeof WeakSet === \"function\";\n    const inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];\n    function memoize(obj) {\n      if (hasWeakSet) {\n        if (inner.has(obj)) {\n          return true;\n        }\n        inner.add(obj);\n        return false;\n      }\n      for (let i = 0; i < inner.length; i++) {\n        const value = inner[i];\n        if (value === obj) {\n          return true;\n        }\n      }\n      inner.push(obj);\n      return false;\n    }\n    function unmemoize(obj) {\n      if (hasWeakSet) {\n        inner.delete(obj);\n      } else {\n        for (let i = 0; i < inner.length; i++) {\n          if (inner[i] === obj) {\n            inner.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n    return [memoize, unmemoize];\n  }\n\n  // node_modules/@sentry/utils/esm/misc.js\n  function uuid4() {\n    const gbl = GLOBAL_OBJ;\n    const crypto2 = gbl.crypto || gbl.msCrypto;\n    let getRandomByte = () => Math.random() * 16;\n    try {\n      if (crypto2 && crypto2.randomUUID) {\n        return crypto2.randomUUID().replace(/-/g, \"\");\n      }\n      if (crypto2 && crypto2.getRandomValues) {\n        getRandomByte = () => {\n          const typedArray = new Uint8Array(1);\n          crypto2.getRandomValues(typedArray);\n          return typedArray[0];\n        };\n      }\n    } catch (_) {\n    }\n    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(\n      /[018]/g,\n      (c) => (\n        // eslint-disable-next-line no-bitwise\n        (c ^ (getRandomByte() & 15) >> c / 4).toString(16)\n      )\n    );\n  }\n  function getFirstException(event) {\n    return event.exception && event.exception.values ? event.exception.values[0] : void 0;\n  }\n  function getEventDescription(event) {\n    const { message, event_id: eventId } = event;\n    if (message) {\n      return message;\n    }\n    const firstException = getFirstException(event);\n    if (firstException) {\n      if (firstException.type && firstException.value) {\n        return `${firstException.type}: ${firstException.value}`;\n      }\n      return firstException.type || firstException.value || eventId || \"<unknown>\";\n    }\n    return eventId || \"<unknown>\";\n  }\n  function addExceptionTypeValue(event, value, type) {\n    const exception = event.exception = event.exception || {};\n    const values = exception.values = exception.values || [];\n    const firstException = values[0] = values[0] || {};\n    if (!firstException.value) {\n      firstException.value = value || \"\";\n    }\n    if (!firstException.type) {\n      firstException.type = type || \"Error\";\n    }\n  }\n  function addExceptionMechanism(event, newMechanism) {\n    const firstException = getFirstException(event);\n    if (!firstException) {\n      return;\n    }\n    const defaultMechanism = { type: \"generic\", handled: true };\n    const currentMechanism = firstException.mechanism;\n    firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };\n    if (newMechanism && \"data\" in newMechanism) {\n      const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };\n      firstException.mechanism.data = mergedData;\n    }\n  }\n  function checkOrSetAlreadyCaught(exception) {\n    if (exception && exception.__sentry_captured__) {\n      return true;\n    }\n    try {\n      addNonEnumerableProperty(exception, \"__sentry_captured__\", true);\n    } catch (err) {\n    }\n    return false;\n  }\n  function arrayify(maybeArray) {\n    return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n  }\n\n  // node_modules/@sentry/utils/esm/normalize.js\n  function normalize(input, depth = 100, maxProperties = Infinity) {\n    try {\n      return visit(\"\", input, depth, maxProperties);\n    } catch (err) {\n      return { ERROR: `**non-serializable** (${err})` };\n    }\n  }\n  function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {\n    const normalized = normalize(object, depth);\n    if (jsonSize(normalized) > maxSize) {\n      return normalizeToSize(object, depth - 1, maxSize);\n    }\n    return normalized;\n  }\n  function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {\n    const [memoize, unmemoize] = memo;\n    if (value == null || // this matches null and undefined -> eqeq not eqeqeq\n    [\"number\", \"boolean\", \"string\"].includes(typeof value) && !Number.isNaN(value)) {\n      return value;\n    }\n    const stringified = stringifyValue(key, value);\n    if (!stringified.startsWith(\"[object \")) {\n      return stringified;\n    }\n    if (value[\"__sentry_skip_normalization__\"]) {\n      return value;\n    }\n    const remainingDepth = typeof value[\"__sentry_override_normalization_depth__\"] === \"number\" ? value[\"__sentry_override_normalization_depth__\"] : depth;\n    if (remainingDepth === 0) {\n      return stringified.replace(\"object \", \"\");\n    }\n    if (memoize(value)) {\n      return \"[Circular ~]\";\n    }\n    const valueWithToJSON = value;\n    if (valueWithToJSON && typeof valueWithToJSON.toJSON === \"function\") {\n      try {\n        const jsonValue = valueWithToJSON.toJSON();\n        return visit(\"\", jsonValue, remainingDepth - 1, maxProperties, memo);\n      } catch (err) {\n      }\n    }\n    const normalized = Array.isArray(value) ? [] : {};\n    let numAdded = 0;\n    const visitable = convertToPlainObject(value);\n    for (const visitKey in visitable) {\n      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n        continue;\n      }\n      if (numAdded >= maxProperties) {\n        normalized[visitKey] = \"[MaxProperties ~]\";\n        break;\n      }\n      const visitValue = visitable[visitKey];\n      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n      numAdded++;\n    }\n    unmemoize(value);\n    return normalized;\n  }\n  function stringifyValue(key, value) {\n    try {\n      if (key === \"domain\" && value && typeof value === \"object\" && value._events) {\n        return \"[Domain]\";\n      }\n      if (key === \"domainEmitter\") {\n        return \"[DomainEmitter]\";\n      }\n      if (typeof global !== \"undefined\" && value === global) {\n        return \"[Global]\";\n      }\n      if (typeof window !== \"undefined\" && value === window) {\n        return \"[Window]\";\n      }\n      if (typeof document !== \"undefined\" && value === document) {\n        return \"[Document]\";\n      }\n      if (isVueViewModel(value)) {\n        return \"[VueViewModel]\";\n      }\n      if (isSyntheticEvent(value)) {\n        return \"[SyntheticEvent]\";\n      }\n      if (typeof value === \"number\" && value !== value) {\n        return \"[NaN]\";\n      }\n      if (typeof value === \"function\") {\n        return `[Function: ${getFunctionName(value)}]`;\n      }\n      if (typeof value === \"symbol\") {\n        return `[${String(value)}]`;\n      }\n      if (typeof value === \"bigint\") {\n        return `[BigInt: ${String(value)}]`;\n      }\n      const objName = getConstructorName(value);\n      if (/^HTML(\\w*)Element$/.test(objName)) {\n        return `[HTMLElement: ${objName}]`;\n      }\n      return `[object ${objName}]`;\n    } catch (err) {\n      return `**non-serializable** (${err})`;\n    }\n  }\n  function getConstructorName(value) {\n    const prototype = Object.getPrototypeOf(value);\n    return prototype ? prototype.constructor.name : \"null prototype\";\n  }\n  function utf8Length(value) {\n    return ~-encodeURI(value).split(/%..|./).length;\n  }\n  function jsonSize(value) {\n    return utf8Length(JSON.stringify(value));\n  }\n\n  // node_modules/@sentry/utils/esm/syncpromise.js\n  var States;\n  (function(States2) {\n    const PENDING = 0;\n    States2[States2[\"PENDING\"] = PENDING] = \"PENDING\";\n    const RESOLVED = 1;\n    States2[States2[\"RESOLVED\"] = RESOLVED] = \"RESOLVED\";\n    const REJECTED = 2;\n    States2[States2[\"REJECTED\"] = REJECTED] = \"REJECTED\";\n  })(States || (States = {}));\n  function resolvedSyncPromise(value) {\n    return new SyncPromise((resolve) => {\n      resolve(value);\n    });\n  }\n  function rejectedSyncPromise(reason) {\n    return new SyncPromise((_, reject) => {\n      reject(reason);\n    });\n  }\n  var SyncPromise = class {\n    constructor(executor) {\n      SyncPromise.prototype.__init.call(this);\n      SyncPromise.prototype.__init2.call(this);\n      SyncPromise.prototype.__init3.call(this);\n      SyncPromise.prototype.__init4.call(this);\n      this._state = States.PENDING;\n      this._handlers = [];\n      try {\n        executor(this._resolve, this._reject);\n      } catch (e2) {\n        this._reject(e2);\n      }\n    }\n    /** JSDoc */\n    then(onfulfilled, onrejected) {\n      return new SyncPromise((resolve, reject) => {\n        this._handlers.push([\n          false,\n          (result) => {\n            if (!onfulfilled) {\n              resolve(result);\n            } else {\n              try {\n                resolve(onfulfilled(result));\n              } catch (e2) {\n                reject(e2);\n              }\n            }\n          },\n          (reason) => {\n            if (!onrejected) {\n              reject(reason);\n            } else {\n              try {\n                resolve(onrejected(reason));\n              } catch (e2) {\n                reject(e2);\n              }\n            }\n          }\n        ]);\n        this._executeHandlers();\n      });\n    }\n    /** JSDoc */\n    catch(onrejected) {\n      return this.then((val) => val, onrejected);\n    }\n    /** JSDoc */\n    finally(onfinally) {\n      return new SyncPromise((resolve, reject) => {\n        let val;\n        let isRejected;\n        return this.then(\n          (value) => {\n            isRejected = false;\n            val = value;\n            if (onfinally) {\n              onfinally();\n            }\n          },\n          (reason) => {\n            isRejected = true;\n            val = reason;\n            if (onfinally) {\n              onfinally();\n            }\n          }\n        ).then(() => {\n          if (isRejected) {\n            reject(val);\n            return;\n          }\n          resolve(val);\n        });\n      });\n    }\n    /** JSDoc */\n    __init() {\n      this._resolve = (value) => {\n        this._setResult(States.RESOLVED, value);\n      };\n    }\n    /** JSDoc */\n    __init2() {\n      this._reject = (reason) => {\n        this._setResult(States.REJECTED, reason);\n      };\n    }\n    /** JSDoc */\n    __init3() {\n      this._setResult = (state, value) => {\n        if (this._state !== States.PENDING) {\n          return;\n        }\n        if (isThenable(value)) {\n          void value.then(this._resolve, this._reject);\n          return;\n        }\n        this._state = state;\n        this._value = value;\n        this._executeHandlers();\n      };\n    }\n    /** JSDoc */\n    __init4() {\n      this._executeHandlers = () => {\n        if (this._state === States.PENDING) {\n          return;\n        }\n        const cachedHandlers = this._handlers.slice();\n        this._handlers = [];\n        cachedHandlers.forEach((handler) => {\n          if (handler[0]) {\n            return;\n          }\n          if (this._state === States.RESOLVED) {\n            handler[1](this._value);\n          }\n          if (this._state === States.REJECTED) {\n            handler[2](this._value);\n          }\n          handler[0] = true;\n        });\n      };\n    }\n  };\n\n  // node_modules/@sentry/utils/esm/promisebuffer.js\n  function makePromiseBuffer(limit) {\n    const buffer = [];\n    function isReady2() {\n      return limit === void 0 || buffer.length < limit;\n    }\n    function remove(task) {\n      return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(void 0);\n    }\n    function add(taskProducer) {\n      if (!isReady2()) {\n        return rejectedSyncPromise(new SentryError(\"Not adding Promise because buffer limit was reached.\"));\n      }\n      const task = taskProducer();\n      if (buffer.indexOf(task) === -1) {\n        buffer.push(task);\n      }\n      void task.then(() => remove(task)).then(\n        null,\n        () => remove(task).then(null, () => {\n        })\n      );\n      return task;\n    }\n    function drain(timeout) {\n      return new SyncPromise((resolve, reject) => {\n        let counter = buffer.length;\n        if (!counter) {\n          return resolve(true);\n        }\n        const capturedSetTimeout = setTimeout(() => {\n          if (timeout && timeout > 0) {\n            resolve(false);\n          }\n        }, timeout);\n        buffer.forEach((item) => {\n          void resolvedSyncPromise(item).then(() => {\n            if (!--counter) {\n              clearTimeout(capturedSetTimeout);\n              resolve(true);\n            }\n          }, reject);\n        });\n      });\n    }\n    return {\n      $: buffer,\n      add,\n      drain\n    };\n  }\n\n  // node_modules/@sentry/utils/esm/url.js\n  function parseUrl(url) {\n    if (!url) {\n      return {};\n    }\n    const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n    if (!match) {\n      return {};\n    }\n    const query = match[6] || \"\";\n    const fragment = match[8] || \"\";\n    return {\n      host: match[4],\n      path: match[5],\n      protocol: match[2],\n      search: query,\n      hash: fragment,\n      relative: match[5] + query + fragment\n      // everything minus origin\n    };\n  }\n\n  // node_modules/@sentry/utils/esm/severity.js\n  var validSeverityLevels = [\"fatal\", \"error\", \"warning\", \"log\", \"info\", \"debug\"];\n  function severityLevelFromString(level) {\n    return level === \"warn\" ? \"warning\" : validSeverityLevels.includes(level) ? level : \"log\";\n  }\n\n  // node_modules/@sentry/utils/esm/baggage.js\n  var BAGGAGE_HEADER_NAME = \"baggage\";\n  var SENTRY_BAGGAGE_KEY_PREFIX = \"sentry-\";\n  var SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n  var MAX_BAGGAGE_STRING_LENGTH = 8192;\n  function baggageHeaderToDynamicSamplingContext(baggageHeader) {\n    const baggageObject = parseBaggageHeader(baggageHeader);\n    if (!baggageObject) {\n      return void 0;\n    }\n    const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n      if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n        const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n        acc[nonPrefixedKey] = value;\n      }\n      return acc;\n    }, {});\n    if (Object.keys(dynamicSamplingContext).length > 0) {\n      return dynamicSamplingContext;\n    } else {\n      return void 0;\n    }\n  }\n  function dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext) {\n    if (!dynamicSamplingContext) {\n      return void 0;\n    }\n    const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n      (acc, [dscKey, dscValue]) => {\n        if (dscValue) {\n          acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n        }\n        return acc;\n      },\n      {}\n    );\n    return objectToBaggageHeader(sentryPrefixedDSC);\n  }\n  function parseBaggageHeader(baggageHeader) {\n    if (!baggageHeader || !isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n      return void 0;\n    }\n    if (Array.isArray(baggageHeader)) {\n      return baggageHeader.reduce((acc, curr) => {\n        const currBaggageObject = baggageHeaderToObject(curr);\n        Object.entries(currBaggageObject).forEach(([key, value]) => {\n          acc[key] = value;\n        });\n        return acc;\n      }, {});\n    }\n    return baggageHeaderToObject(baggageHeader);\n  }\n  function baggageHeaderToObject(baggageHeader) {\n    return baggageHeader.split(\",\").map((baggageEntry) => baggageEntry.split(\"=\").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {\n      if (key && value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {});\n  }\n  function objectToBaggageHeader(object) {\n    if (Object.keys(object).length === 0) {\n      return void 0;\n    }\n    return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n      const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n      const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n      if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n        DEBUG_BUILD && logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`\n        );\n        return baggageHeader;\n      } else {\n        return newBaggageHeader;\n      }\n    }, \"\");\n  }\n\n  // node_modules/@sentry/utils/esm/tracing.js\n  var TRACEPARENT_REGEXP = new RegExp(\n    \"^[ \\\\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\\\t]*$\"\n    // whitespace\n  );\n  function extractTraceparentData(traceparent) {\n    if (!traceparent) {\n      return void 0;\n    }\n    const matches2 = traceparent.match(TRACEPARENT_REGEXP);\n    if (!matches2) {\n      return void 0;\n    }\n    let parentSampled;\n    if (matches2[3] === \"1\") {\n      parentSampled = true;\n    } else if (matches2[3] === \"0\") {\n      parentSampled = false;\n    }\n    return {\n      traceId: matches2[1],\n      parentSampled,\n      parentSpanId: matches2[2]\n    };\n  }\n  function propagationContextFromHeaders(sentryTrace, baggage) {\n    const traceparentData = extractTraceparentData(sentryTrace);\n    const dynamicSamplingContext = baggageHeaderToDynamicSamplingContext(baggage);\n    const { traceId, parentSpanId, parentSampled } = traceparentData || {};\n    if (!traceparentData) {\n      return {\n        traceId: traceId || uuid4(),\n        spanId: uuid4().substring(16)\n      };\n    } else {\n      return {\n        traceId: traceId || uuid4(),\n        parentSpanId: parentSpanId || uuid4().substring(16),\n        spanId: uuid4().substring(16),\n        sampled: parentSampled,\n        dsc: dynamicSamplingContext || {}\n        // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it\n      };\n    }\n  }\n  function generateSentryTraceHeader(traceId = uuid4(), spanId = uuid4().substring(16), sampled) {\n    let sampledString = \"\";\n    if (sampled !== void 0) {\n      sampledString = sampled ? \"-1\" : \"-0\";\n    }\n    return `${traceId}-${spanId}${sampledString}`;\n  }\n\n  // node_modules/@sentry/utils/esm/envelope.js\n  function createEnvelope(headers, items = []) {\n    return [headers, items];\n  }\n  function addItemToEnvelope(envelope, newItem) {\n    const [headers, items] = envelope;\n    return [headers, [...items, newItem]];\n  }\n  function forEachEnvelopeItem(envelope, callback) {\n    const envelopeItems = envelope[1];\n    for (const envelopeItem of envelopeItems) {\n      const envelopeItemType = envelopeItem[0].type;\n      const result = callback(envelopeItem, envelopeItemType);\n      if (result) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function encodeUTF8(input) {\n    return GLOBAL_OBJ.__SENTRY__ && GLOBAL_OBJ.__SENTRY__.encodePolyfill ? GLOBAL_OBJ.__SENTRY__.encodePolyfill(input) : new TextEncoder().encode(input);\n  }\n  function serializeEnvelope(envelope) {\n    const [envHeaders, items] = envelope;\n    let parts = JSON.stringify(envHeaders);\n    function append(next) {\n      if (typeof parts === \"string\") {\n        parts = typeof next === \"string\" ? parts + next : [encodeUTF8(parts), next];\n      } else {\n        parts.push(typeof next === \"string\" ? encodeUTF8(next) : next);\n      }\n    }\n    for (const item of items) {\n      const [itemHeaders, payload] = item;\n      append(`\n${JSON.stringify(itemHeaders)}\n`);\n      if (typeof payload === \"string\" || payload instanceof Uint8Array) {\n        append(payload);\n      } else {\n        let stringifiedPayload;\n        try {\n          stringifiedPayload = JSON.stringify(payload);\n        } catch (e2) {\n          stringifiedPayload = JSON.stringify(normalize(payload));\n        }\n        append(stringifiedPayload);\n      }\n    }\n    return typeof parts === \"string\" ? parts : concatBuffers(parts);\n  }\n  function concatBuffers(buffers) {\n    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n    const merged = new Uint8Array(totalLength);\n    let offset2 = 0;\n    for (const buffer of buffers) {\n      merged.set(buffer, offset2);\n      offset2 += buffer.length;\n    }\n    return merged;\n  }\n  function createSpanEnvelopeItem(spanJson) {\n    const spanHeaders = {\n      type: \"span\"\n    };\n    return [spanHeaders, spanJson];\n  }\n  function createAttachmentEnvelopeItem(attachment) {\n    const buffer = typeof attachment.data === \"string\" ? encodeUTF8(attachment.data) : attachment.data;\n    return [\n      dropUndefinedKeys({\n        type: \"attachment\",\n        length: buffer.length,\n        filename: attachment.filename,\n        content_type: attachment.contentType,\n        attachment_type: attachment.attachmentType\n      }),\n      buffer\n    ];\n  }\n  var ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n    session: \"session\",\n    sessions: \"session\",\n    attachment: \"attachment\",\n    transaction: \"transaction\",\n    event: \"error\",\n    client_report: \"internal\",\n    user_report: \"default\",\n    profile: \"profile\",\n    profile_chunk: \"profile\",\n    replay_event: \"replay\",\n    replay_recording: \"replay\",\n    check_in: \"monitor\",\n    feedback: \"feedback\",\n    span: \"span\",\n    statsd: \"metric_bucket\"\n  };\n  function envelopeItemTypeToDataCategory(type) {\n    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n  }\n  function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {\n    if (!metadataOrEvent || !metadataOrEvent.sdk) {\n      return;\n    }\n    const { name: name2, version } = metadataOrEvent.sdk;\n    return { name: name2, version };\n  }\n  function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {\n    const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n    return {\n      event_id: event.event_id,\n      sent_at: (/* @__PURE__ */ new Date()).toISOString(),\n      ...sdkInfo && { sdk: sdkInfo },\n      ...!!tunnel && dsn && { dsn: dsnToString(dsn) },\n      ...dynamicSamplingContext && {\n        trace: dropUndefinedKeys({ ...dynamicSamplingContext })\n      }\n    };\n  }\n\n  // node_modules/@sentry/utils/esm/clientreport.js\n  function createClientReportEnvelope(discarded_events, dsn, timestamp) {\n    const clientReportItem = [\n      { type: \"client_report\" },\n      {\n        timestamp: timestamp || dateTimestampInSeconds(),\n        discarded_events\n      }\n    ];\n    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);\n  }\n\n  // node_modules/@sentry/utils/esm/ratelimit.js\n  var DEFAULT_RETRY_AFTER = 60 * 1e3;\n  function parseRetryAfterHeader(header, now = Date.now()) {\n    const headerDelay = parseInt(`${header}`, 10);\n    if (!isNaN(headerDelay)) {\n      return headerDelay * 1e3;\n    }\n    const headerDate = Date.parse(`${header}`);\n    if (!isNaN(headerDate)) {\n      return headerDate - now;\n    }\n    return DEFAULT_RETRY_AFTER;\n  }\n  function disabledUntil(limits, dataCategory) {\n    return limits[dataCategory] || limits.all || 0;\n  }\n  function isRateLimited(limits, dataCategory, now = Date.now()) {\n    return disabledUntil(limits, dataCategory) > now;\n  }\n  function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {\n    const updatedRateLimits = {\n      ...limits\n    };\n    const rateLimitHeader = headers && headers[\"x-sentry-rate-limits\"];\n    const retryAfterHeader = headers && headers[\"retry-after\"];\n    if (rateLimitHeader) {\n      for (const limit of rateLimitHeader.trim().split(\",\")) {\n        const [retryAfter, categories, , , namespaces] = limit.split(\":\", 5);\n        const headerDelay = parseInt(retryAfter, 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;\n        if (!categories) {\n          updatedRateLimits.all = now + delay;\n        } else {\n          for (const category of categories.split(\";\")) {\n            if (category === \"metric_bucket\") {\n              if (!namespaces || namespaces.split(\";\").includes(\"custom\")) {\n                updatedRateLimits[category] = now + delay;\n              }\n            } else {\n              updatedRateLimits[category] = now + delay;\n            }\n          }\n        }\n      }\n    } else if (retryAfterHeader) {\n      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n    } else if (statusCode === 429) {\n      updatedRateLimits.all = now + 60 * 1e3;\n    }\n    return updatedRateLimits;\n  }\n\n  // node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js\n  function _nullishCoalesce(lhs, rhsFn) {\n    return lhs != null ? lhs : rhsFn();\n  }\n\n  // node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js\n  function _optionalChain(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n\n  // node_modules/@sentry/utils/esm/propagationContext.js\n  function generatePropagationContext() {\n    return {\n      traceId: uuid4(),\n      spanId: uuid4().substring(16)\n    };\n  }\n\n  // node_modules/@sentry/utils/esm/vendor/supportsHistory.js\n  var WINDOW3 = GLOBAL_OBJ;\n  function supportsHistory() {\n    const chromeVar = WINDOW3.chrome;\n    const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;\n    const hasHistoryApi = \"history\" in WINDOW3 && !!WINDOW3.history.pushState && !!WINDOW3.history.replaceState;\n    return !isChromePackagedApp && hasHistoryApi;\n  }\n\n  // node_modules/@sentry/core/esm/debug-build.js\n  var DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n\n  // node_modules/@sentry/core/esm/carrier.js\n  function getMainCarrier() {\n    getSentryCarrier(GLOBAL_OBJ);\n    return GLOBAL_OBJ;\n  }\n  function getSentryCarrier(carrier) {\n    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};\n    __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n    return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};\n  }\n\n  // node_modules/@sentry/core/esm/session.js\n  function makeSession(context) {\n    const startingTime = timestampInSeconds();\n    const session = {\n      sid: uuid4(),\n      init: true,\n      timestamp: startingTime,\n      started: startingTime,\n      duration: 0,\n      status: \"ok\",\n      errors: 0,\n      ignoreDuration: false,\n      toJSON: () => sessionToJSON(session)\n    };\n    if (context) {\n      updateSession(session, context);\n    }\n    return session;\n  }\n  function updateSession(session, context = {}) {\n    if (context.user) {\n      if (!session.ipAddress && context.user.ip_address) {\n        session.ipAddress = context.user.ip_address;\n      }\n      if (!session.did && !context.did) {\n        session.did = context.user.id || context.user.email || context.user.username;\n      }\n    }\n    session.timestamp = context.timestamp || timestampInSeconds();\n    if (context.abnormal_mechanism) {\n      session.abnormal_mechanism = context.abnormal_mechanism;\n    }\n    if (context.ignoreDuration) {\n      session.ignoreDuration = context.ignoreDuration;\n    }\n    if (context.sid) {\n      session.sid = context.sid.length === 32 ? context.sid : uuid4();\n    }\n    if (context.init !== void 0) {\n      session.init = context.init;\n    }\n    if (!session.did && context.did) {\n      session.did = `${context.did}`;\n    }\n    if (typeof context.started === \"number\") {\n      session.started = context.started;\n    }\n    if (session.ignoreDuration) {\n      session.duration = void 0;\n    } else if (typeof context.duration === \"number\") {\n      session.duration = context.duration;\n    } else {\n      const duration = session.timestamp - session.started;\n      session.duration = duration >= 0 ? duration : 0;\n    }\n    if (context.release) {\n      session.release = context.release;\n    }\n    if (context.environment) {\n      session.environment = context.environment;\n    }\n    if (!session.ipAddress && context.ipAddress) {\n      session.ipAddress = context.ipAddress;\n    }\n    if (!session.userAgent && context.userAgent) {\n      session.userAgent = context.userAgent;\n    }\n    if (typeof context.errors === \"number\") {\n      session.errors = context.errors;\n    }\n    if (context.status) {\n      session.status = context.status;\n    }\n  }\n  function closeSession(session, status) {\n    let context = {};\n    if (status) {\n      context = { status };\n    } else if (session.status === \"ok\") {\n      context = { status: \"exited\" };\n    }\n    updateSession(session, context);\n  }\n  function sessionToJSON(session) {\n    return dropUndefinedKeys({\n      sid: `${session.sid}`,\n      init: session.init,\n      // Make sure that sec is converted to ms for date constructor\n      started: new Date(session.started * 1e3).toISOString(),\n      timestamp: new Date(session.timestamp * 1e3).toISOString(),\n      status: session.status,\n      errors: session.errors,\n      did: typeof session.did === \"number\" || typeof session.did === \"string\" ? `${session.did}` : void 0,\n      duration: session.duration,\n      abnormal_mechanism: session.abnormal_mechanism,\n      attrs: {\n        release: session.release,\n        environment: session.environment,\n        ip_address: session.ipAddress,\n        user_agent: session.userAgent\n      }\n    });\n  }\n\n  // node_modules/@sentry/core/esm/utils/spanOnScope.js\n  var SCOPE_SPAN_FIELD = \"_sentrySpan\";\n  function _setSpanForScope(scope, span) {\n    if (span) {\n      addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);\n    } else {\n      delete scope[SCOPE_SPAN_FIELD];\n    }\n  }\n  function _getSpanForScope(scope) {\n    return scope[SCOPE_SPAN_FIELD];\n  }\n\n  // node_modules/@sentry/core/esm/scope.js\n  var DEFAULT_MAX_BREADCRUMBS = 100;\n  var ScopeClass = class {\n    /** Flag if notifying is happening. */\n    /** Callback for client to receive scope changes. */\n    /** Callback list that will be called during event processing. */\n    /** Array of breadcrumbs. */\n    /** User */\n    /** Tags */\n    /** Extra */\n    /** Contexts */\n    /** Attachments */\n    /** Propagation Context for distributed tracing */\n    /**\n     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n     * sent to Sentry\n     */\n    /** Fingerprint */\n    /** Severity */\n    /**\n     * Transaction Name\n     *\n     * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n     * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n     */\n    /** Session */\n    /** Request Mode Session Status */\n    /** The client on this scope */\n    /** Contains the last event id of a captured event.  */\n    // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n    constructor() {\n      this._notifyingListeners = false;\n      this._scopeListeners = [];\n      this._eventProcessors = [];\n      this._breadcrumbs = [];\n      this._attachments = [];\n      this._user = {};\n      this._tags = {};\n      this._extra = {};\n      this._contexts = {};\n      this._sdkProcessingMetadata = {};\n      this._propagationContext = generatePropagationContext();\n    }\n    /**\n     * @inheritDoc\n     */\n    clone() {\n      const newScope = new ScopeClass();\n      newScope._breadcrumbs = [...this._breadcrumbs];\n      newScope._tags = { ...this._tags };\n      newScope._extra = { ...this._extra };\n      newScope._contexts = { ...this._contexts };\n      newScope._user = this._user;\n      newScope._level = this._level;\n      newScope._session = this._session;\n      newScope._transactionName = this._transactionName;\n      newScope._fingerprint = this._fingerprint;\n      newScope._eventProcessors = [...this._eventProcessors];\n      newScope._requestSession = this._requestSession;\n      newScope._attachments = [...this._attachments];\n      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n      newScope._propagationContext = { ...this._propagationContext };\n      newScope._client = this._client;\n      newScope._lastEventId = this._lastEventId;\n      _setSpanForScope(newScope, _getSpanForScope(this));\n      return newScope;\n    }\n    /**\n     * @inheritDoc\n     */\n    setClient(client) {\n      this._client = client;\n    }\n    /**\n     * @inheritDoc\n     */\n    setLastEventId(lastEventId2) {\n      this._lastEventId = lastEventId2;\n    }\n    /**\n     * @inheritDoc\n     */\n    getClient() {\n      return this._client;\n    }\n    /**\n     * @inheritDoc\n     */\n    lastEventId() {\n      return this._lastEventId;\n    }\n    /**\n     * @inheritDoc\n     */\n    addScopeListener(callback) {\n      this._scopeListeners.push(callback);\n    }\n    /**\n     * @inheritDoc\n     */\n    addEventProcessor(callback) {\n      this._eventProcessors.push(callback);\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setUser(user) {\n      this._user = user || {\n        email: void 0,\n        id: void 0,\n        ip_address: void 0,\n        username: void 0\n      };\n      if (this._session) {\n        updateSession(this._session, { user });\n      }\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    getUser() {\n      return this._user;\n    }\n    /**\n     * @inheritDoc\n     */\n    getRequestSession() {\n      return this._requestSession;\n    }\n    /**\n     * @inheritDoc\n     */\n    setRequestSession(requestSession) {\n      this._requestSession = requestSession;\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setTags(tags) {\n      this._tags = {\n        ...this._tags,\n        ...tags\n      };\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setTag(key, value) {\n      this._tags = { ...this._tags, [key]: value };\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setExtras(extras) {\n      this._extra = {\n        ...this._extra,\n        ...extras\n      };\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setExtra(key, extra) {\n      this._extra = { ...this._extra, [key]: extra };\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setFingerprint(fingerprint) {\n      this._fingerprint = fingerprint;\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setLevel(level) {\n      this._level = level;\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setTransactionName(name2) {\n      this._transactionName = name2;\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setContext(key, context) {\n      if (context === null) {\n        delete this._contexts[key];\n      } else {\n        this._contexts[key] = context;\n      }\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setSession(session) {\n      if (!session) {\n        delete this._session;\n      } else {\n        this._session = session;\n      }\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    getSession() {\n      return this._session;\n    }\n    /**\n     * @inheritDoc\n     */\n    update(captureContext) {\n      if (!captureContext) {\n        return this;\n      }\n      const scopeToMerge = typeof captureContext === \"function\" ? captureContext(this) : captureContext;\n      const [scopeInstance, requestSession] = scopeToMerge instanceof Scope ? [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()] : isPlainObject(scopeToMerge) ? [captureContext, captureContext.requestSession] : [];\n      const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n      this._tags = { ...this._tags, ...tags };\n      this._extra = { ...this._extra, ...extra };\n      this._contexts = { ...this._contexts, ...contexts };\n      if (user && Object.keys(user).length) {\n        this._user = user;\n      }\n      if (level) {\n        this._level = level;\n      }\n      if (fingerprint.length) {\n        this._fingerprint = fingerprint;\n      }\n      if (propagationContext) {\n        this._propagationContext = propagationContext;\n      }\n      if (requestSession) {\n        this._requestSession = requestSession;\n      }\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    clear() {\n      this._breadcrumbs = [];\n      this._tags = {};\n      this._extra = {};\n      this._user = {};\n      this._contexts = {};\n      this._level = void 0;\n      this._transactionName = void 0;\n      this._fingerprint = void 0;\n      this._requestSession = void 0;\n      this._session = void 0;\n      _setSpanForScope(this, void 0);\n      this._attachments = [];\n      this._propagationContext = generatePropagationContext();\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    addBreadcrumb(breadcrumb, maxBreadcrumbs) {\n      const maxCrumbs = typeof maxBreadcrumbs === \"number\" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n      if (maxCrumbs <= 0) {\n        return this;\n      }\n      const mergedBreadcrumb = {\n        timestamp: dateTimestampInSeconds(),\n        ...breadcrumb\n      };\n      const breadcrumbs = this._breadcrumbs;\n      breadcrumbs.push(mergedBreadcrumb);\n      this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    getLastBreadcrumb() {\n      return this._breadcrumbs[this._breadcrumbs.length - 1];\n    }\n    /**\n     * @inheritDoc\n     */\n    clearBreadcrumbs() {\n      this._breadcrumbs = [];\n      this._notifyScopeListeners();\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    addAttachment(attachment) {\n      this._attachments.push(attachment);\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    clearAttachments() {\n      this._attachments = [];\n      return this;\n    }\n    /** @inheritDoc */\n    getScopeData() {\n      return {\n        breadcrumbs: this._breadcrumbs,\n        attachments: this._attachments,\n        contexts: this._contexts,\n        tags: this._tags,\n        extra: this._extra,\n        user: this._user,\n        level: this._level,\n        fingerprint: this._fingerprint || [],\n        eventProcessors: this._eventProcessors,\n        propagationContext: this._propagationContext,\n        sdkProcessingMetadata: this._sdkProcessingMetadata,\n        transactionName: this._transactionName,\n        span: _getSpanForScope(this)\n      };\n    }\n    /**\n     * @inheritDoc\n     */\n    setSDKProcessingMetadata(newData) {\n      this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    setPropagationContext(context) {\n      this._propagationContext = context;\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    getPropagationContext() {\n      return this._propagationContext;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureException(exception, hint) {\n      const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n      if (!this._client) {\n        logger.warn(\"No client configured on scope - will not capture exception!\");\n        return eventId;\n      }\n      const syntheticException = new Error(\"Sentry syntheticException\");\n      this._client.captureException(\n        exception,\n        {\n          originalException: exception,\n          syntheticException,\n          ...hint,\n          event_id: eventId\n        },\n        this\n      );\n      return eventId;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureMessage(message, level, hint) {\n      const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n      if (!this._client) {\n        logger.warn(\"No client configured on scope - will not capture message!\");\n        return eventId;\n      }\n      const syntheticException = new Error(message);\n      this._client.captureMessage(\n        message,\n        level,\n        {\n          originalException: message,\n          syntheticException,\n          ...hint,\n          event_id: eventId\n        },\n        this\n      );\n      return eventId;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureEvent(event, hint) {\n      const eventId = hint && hint.event_id ? hint.event_id : uuid4();\n      if (!this._client) {\n        logger.warn(\"No client configured on scope - will not capture event!\");\n        return eventId;\n      }\n      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n      return eventId;\n    }\n    /**\n     * This will be called on every set call.\n     */\n    _notifyScopeListeners() {\n      if (!this._notifyingListeners) {\n        this._notifyingListeners = true;\n        this._scopeListeners.forEach((callback) => {\n          callback(this);\n        });\n        this._notifyingListeners = false;\n      }\n    }\n  };\n  var Scope = ScopeClass;\n\n  // node_modules/@sentry/core/esm/defaultScopes.js\n  function getDefaultCurrentScope() {\n    return getGlobalSingleton(\"defaultCurrentScope\", () => new Scope());\n  }\n  function getDefaultIsolationScope() {\n    return getGlobalSingleton(\"defaultIsolationScope\", () => new Scope());\n  }\n\n  // node_modules/@sentry/core/esm/asyncContext/stackStrategy.js\n  var AsyncContextStack = class {\n    constructor(scope, isolationScope) {\n      let assignedScope;\n      if (!scope) {\n        assignedScope = new Scope();\n      } else {\n        assignedScope = scope;\n      }\n      let assignedIsolationScope;\n      if (!isolationScope) {\n        assignedIsolationScope = new Scope();\n      } else {\n        assignedIsolationScope = isolationScope;\n      }\n      this._stack = [{ scope: assignedScope }];\n      this._isolationScope = assignedIsolationScope;\n    }\n    /**\n     * Fork a scope for the stack.\n     */\n    withScope(callback) {\n      const scope = this._pushScope();\n      let maybePromiseResult;\n      try {\n        maybePromiseResult = callback(scope);\n      } catch (e2) {\n        this._popScope();\n        throw e2;\n      }\n      if (isThenable(maybePromiseResult)) {\n        return maybePromiseResult.then(\n          (res) => {\n            this._popScope();\n            return res;\n          },\n          (e2) => {\n            this._popScope();\n            throw e2;\n          }\n        );\n      }\n      this._popScope();\n      return maybePromiseResult;\n    }\n    /**\n     * Get the client of the stack.\n     */\n    getClient() {\n      return this.getStackTop().client;\n    }\n    /**\n     * Returns the scope of the top stack.\n     */\n    getScope() {\n      return this.getStackTop().scope;\n    }\n    /**\n     * Get the isolation scope for the stack.\n     */\n    getIsolationScope() {\n      return this._isolationScope;\n    }\n    /**\n     * Returns the scope stack for domains or the process.\n     */\n    getStack() {\n      return this._stack;\n    }\n    /**\n     * Returns the topmost scope layer in the order domain > local > process.\n     */\n    getStackTop() {\n      return this._stack[this._stack.length - 1];\n    }\n    /**\n     * Push a scope to the stack.\n     */\n    _pushScope() {\n      const scope = this.getScope().clone();\n      this.getStack().push({\n        client: this.getClient(),\n        scope\n      });\n      return scope;\n    }\n    /**\n     * Pop a scope from the stack.\n     */\n    _popScope() {\n      if (this.getStack().length <= 1)\n        return false;\n      return !!this.getStack().pop();\n    }\n  };\n  function getAsyncContextStack() {\n    const registry = getMainCarrier();\n    const sentry = getSentryCarrier(registry);\n    return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());\n  }\n  function withScope(callback) {\n    return getAsyncContextStack().withScope(callback);\n  }\n  function withSetScope(scope, callback) {\n    const stack = getAsyncContextStack();\n    return stack.withScope(() => {\n      stack.getStackTop().scope = scope;\n      return callback(scope);\n    });\n  }\n  function withIsolationScope(callback) {\n    return getAsyncContextStack().withScope(() => {\n      return callback(getAsyncContextStack().getIsolationScope());\n    });\n  }\n  function getStackAsyncContextStrategy() {\n    return {\n      withIsolationScope,\n      withScope,\n      withSetScope,\n      withSetIsolationScope: (_isolationScope, callback) => {\n        return withIsolationScope(callback);\n      },\n      getCurrentScope: () => getAsyncContextStack().getScope(),\n      getIsolationScope: () => getAsyncContextStack().getIsolationScope()\n    };\n  }\n\n  // node_modules/@sentry/core/esm/asyncContext/index.js\n  function getAsyncContextStrategy(carrier) {\n    const sentry = getSentryCarrier(carrier);\n    if (sentry.acs) {\n      return sentry.acs;\n    }\n    return getStackAsyncContextStrategy();\n  }\n\n  // node_modules/@sentry/core/esm/currentScopes.js\n  function getCurrentScope() {\n    const carrier = getMainCarrier();\n    const acs = getAsyncContextStrategy(carrier);\n    return acs.getCurrentScope();\n  }\n  function getIsolationScope() {\n    const carrier = getMainCarrier();\n    const acs = getAsyncContextStrategy(carrier);\n    return acs.getIsolationScope();\n  }\n  function getGlobalScope() {\n    return getGlobalSingleton(\"globalScope\", () => new Scope());\n  }\n  function withScope2(...rest) {\n    const carrier = getMainCarrier();\n    const acs = getAsyncContextStrategy(carrier);\n    if (rest.length === 2) {\n      const [scope, callback] = rest;\n      if (!scope) {\n        return acs.withScope(callback);\n      }\n      return acs.withSetScope(scope, callback);\n    }\n    return acs.withScope(rest[0]);\n  }\n  function getClient() {\n    return getCurrentScope().getClient();\n  }\n\n  // node_modules/@sentry/core/esm/metrics/metric-summary.js\n  var METRICS_SPAN_FIELD = \"_sentryMetrics\";\n  function getMetricSummaryJsonForSpan(span) {\n    const storage = span[METRICS_SPAN_FIELD];\n    if (!storage) {\n      return void 0;\n    }\n    const output = {};\n    for (const [, [exportKey, summary]] of storage) {\n      const arr = output[exportKey] || (output[exportKey] = []);\n      arr.push(dropUndefinedKeys(summary));\n    }\n    return output;\n  }\n\n  // node_modules/@sentry/core/esm/semanticAttributes.js\n  var SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = \"sentry.source\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = \"sentry.sample_rate\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_OP = \"sentry.op\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = \"sentry.origin\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = \"sentry.idle_span_finish_reason\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = \"sentry.measurement_unit\";\n  var SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = \"sentry.measurement_value\";\n  var SEMANTIC_ATTRIBUTE_PROFILE_ID = \"sentry.profile_id\";\n  var SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = \"sentry.exclusive_time\";\n\n  // node_modules/@sentry/core/esm/tracing/spanstatus.js\n  var SPAN_STATUS_UNSET = 0;\n  var SPAN_STATUS_OK = 1;\n  var SPAN_STATUS_ERROR = 2;\n  function getSpanStatusFromHttpCode(httpStatus) {\n    if (httpStatus < 400 && httpStatus >= 100) {\n      return { code: SPAN_STATUS_OK };\n    }\n    if (httpStatus >= 400 && httpStatus < 500) {\n      switch (httpStatus) {\n        case 401:\n          return { code: SPAN_STATUS_ERROR, message: \"unauthenticated\" };\n        case 403:\n          return { code: SPAN_STATUS_ERROR, message: \"permission_denied\" };\n        case 404:\n          return { code: SPAN_STATUS_ERROR, message: \"not_found\" };\n        case 409:\n          return { code: SPAN_STATUS_ERROR, message: \"already_exists\" };\n        case 413:\n          return { code: SPAN_STATUS_ERROR, message: \"failed_precondition\" };\n        case 429:\n          return { code: SPAN_STATUS_ERROR, message: \"resource_exhausted\" };\n        case 499:\n          return { code: SPAN_STATUS_ERROR, message: \"cancelled\" };\n        default:\n          return { code: SPAN_STATUS_ERROR, message: \"invalid_argument\" };\n      }\n    }\n    if (httpStatus >= 500 && httpStatus < 600) {\n      switch (httpStatus) {\n        case 501:\n          return { code: SPAN_STATUS_ERROR, message: \"unimplemented\" };\n        case 503:\n          return { code: SPAN_STATUS_ERROR, message: \"unavailable\" };\n        case 504:\n          return { code: SPAN_STATUS_ERROR, message: \"deadline_exceeded\" };\n        default:\n          return { code: SPAN_STATUS_ERROR, message: \"internal_error\" };\n      }\n    }\n    return { code: SPAN_STATUS_ERROR, message: \"unknown_error\" };\n  }\n  function setHttpStatus(span, httpStatus) {\n    span.setAttribute(\"http.response.status_code\", httpStatus);\n    const spanStatus = getSpanStatusFromHttpCode(httpStatus);\n    if (spanStatus.message !== \"unknown_error\") {\n      span.setStatus(spanStatus);\n    }\n  }\n\n  // node_modules/@sentry/core/esm/utils/spanUtils.js\n  var TRACE_FLAG_NONE = 0;\n  var TRACE_FLAG_SAMPLED = 1;\n  function spanToTransactionTraceContext(span) {\n    const { spanId: span_id, traceId: trace_id } = span.spanContext();\n    const { data, op, parent_span_id, status, origin } = spanToJSON(span);\n    return dropUndefinedKeys({\n      parent_span_id,\n      span_id,\n      trace_id,\n      data,\n      op,\n      status,\n      origin\n    });\n  }\n  function spanToTraceContext(span) {\n    const { spanId: span_id, traceId: trace_id } = span.spanContext();\n    const { parent_span_id } = spanToJSON(span);\n    return dropUndefinedKeys({ parent_span_id, span_id, trace_id });\n  }\n  function spanToTraceHeader(span) {\n    const { traceId, spanId } = span.spanContext();\n    const sampled = spanIsSampled(span);\n    return generateSentryTraceHeader(traceId, spanId, sampled);\n  }\n  function spanTimeInputToSeconds(input) {\n    if (typeof input === \"number\") {\n      return ensureTimestampInSeconds(input);\n    }\n    if (Array.isArray(input)) {\n      return input[0] + input[1] / 1e9;\n    }\n    if (input instanceof Date) {\n      return ensureTimestampInSeconds(input.getTime());\n    }\n    return timestampInSeconds();\n  }\n  function ensureTimestampInSeconds(timestamp) {\n    const isMs = timestamp > 9999999999;\n    return isMs ? timestamp / 1e3 : timestamp;\n  }\n  function spanToJSON(span) {\n    if (spanIsSentrySpan(span)) {\n      return span.getSpanJSON();\n    }\n    try {\n      const { spanId: span_id, traceId: trace_id } = span.spanContext();\n      if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {\n        const { attributes, startTime, name: name2, endTime, parentSpanId, status } = span;\n        return dropUndefinedKeys({\n          span_id,\n          trace_id,\n          data: attributes,\n          description: name2,\n          parent_span_id: parentSpanId,\n          start_timestamp: spanTimeInputToSeconds(startTime),\n          // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n          timestamp: spanTimeInputToSeconds(endTime) || void 0,\n          status: getStatusMessage(status),\n          op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n          origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],\n          _metrics_summary: getMetricSummaryJsonForSpan(span)\n        });\n      }\n      return {\n        span_id,\n        trace_id\n      };\n    } catch (e2) {\n      return {};\n    }\n  }\n  function spanIsOpenTelemetrySdkTraceBaseSpan(span) {\n    const castSpan = span;\n    return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;\n  }\n  function spanIsSentrySpan(span) {\n    return typeof span.getSpanJSON === \"function\";\n  }\n  function spanIsSampled(span) {\n    const { traceFlags } = span.spanContext();\n    return traceFlags === TRACE_FLAG_SAMPLED;\n  }\n  function getStatusMessage(status) {\n    if (!status || status.code === SPAN_STATUS_UNSET) {\n      return void 0;\n    }\n    if (status.code === SPAN_STATUS_OK) {\n      return \"ok\";\n    }\n    return status.message || \"unknown_error\";\n  }\n  var CHILD_SPANS_FIELD = \"_sentryChildSpans\";\n  var ROOT_SPAN_FIELD = \"_sentryRootSpan\";\n  function addChildSpanToSpan(span, childSpan) {\n    const rootSpan = span[ROOT_SPAN_FIELD] || span;\n    addNonEnumerableProperty(childSpan, ROOT_SPAN_FIELD, rootSpan);\n    if (span[CHILD_SPANS_FIELD]) {\n      span[CHILD_SPANS_FIELD].add(childSpan);\n    } else {\n      addNonEnumerableProperty(span, CHILD_SPANS_FIELD, /* @__PURE__ */ new Set([childSpan]));\n    }\n  }\n  function removeChildSpanFromSpan(span, childSpan) {\n    if (span[CHILD_SPANS_FIELD]) {\n      span[CHILD_SPANS_FIELD].delete(childSpan);\n    }\n  }\n  function getSpanDescendants(span) {\n    const resultSet = /* @__PURE__ */ new Set();\n    function addSpanChildren(span2) {\n      if (resultSet.has(span2)) {\n        return;\n      } else if (spanIsSampled(span2)) {\n        resultSet.add(span2);\n        const childSpans = span2[CHILD_SPANS_FIELD] ? Array.from(span2[CHILD_SPANS_FIELD]) : [];\n        for (const childSpan of childSpans) {\n          addSpanChildren(childSpan);\n        }\n      }\n    }\n    addSpanChildren(span);\n    return Array.from(resultSet);\n  }\n  function getRootSpan(span) {\n    return span[ROOT_SPAN_FIELD] || span;\n  }\n  function getActiveSpan() {\n    const carrier = getMainCarrier();\n    const acs = getAsyncContextStrategy(carrier);\n    if (acs.getActiveSpan) {\n      return acs.getActiveSpan();\n    }\n    return _getSpanForScope(getCurrentScope());\n  }\n\n  // node_modules/@sentry/core/esm/tracing/errors.js\n  var errorsInstrumented = false;\n  function registerSpanErrorInstrumentation() {\n    if (errorsInstrumented) {\n      return;\n    }\n    errorsInstrumented = true;\n    addGlobalErrorInstrumentationHandler(errorCallback);\n    addGlobalUnhandledRejectionInstrumentationHandler(errorCallback);\n  }\n  function errorCallback() {\n    const activeSpan = getActiveSpan();\n    const rootSpan = activeSpan && getRootSpan(activeSpan);\n    if (rootSpan) {\n      const message = \"internal_error\";\n      DEBUG_BUILD2 && logger.log(`[Tracing] Root span: ${message} -> Global error occured`);\n      rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message });\n    }\n  }\n  errorCallback.tag = \"sentry_tracingErrorCallback\";\n\n  // node_modules/@sentry/core/esm/tracing/utils.js\n  var SCOPE_ON_START_SPAN_FIELD = \"_sentryScope\";\n  var ISOLATION_SCOPE_ON_START_SPAN_FIELD = \"_sentryIsolationScope\";\n  function setCapturedScopesOnSpan(span, scope, isolationScope) {\n    if (span) {\n      addNonEnumerableProperty(span, ISOLATION_SCOPE_ON_START_SPAN_FIELD, isolationScope);\n      addNonEnumerableProperty(span, SCOPE_ON_START_SPAN_FIELD, scope);\n    }\n  }\n  function getCapturedScopesOnSpan(span) {\n    return {\n      scope: span[SCOPE_ON_START_SPAN_FIELD],\n      isolationScope: span[ISOLATION_SCOPE_ON_START_SPAN_FIELD]\n    };\n  }\n\n  // node_modules/@sentry/core/esm/utils/hasTracingEnabled.js\n  function hasTracingEnabled(maybeOptions) {\n    if (typeof __SENTRY_TRACING__ === \"boolean\" && !__SENTRY_TRACING__) {\n      return false;\n    }\n    const options = maybeOptions || getClientOptions();\n    return !!options && (options.enableTracing || \"tracesSampleRate\" in options || \"tracesSampler\" in options);\n  }\n  function getClientOptions() {\n    const client = getClient();\n    return client && client.getOptions();\n  }\n\n  // node_modules/@sentry/core/esm/tracing/sentryNonRecordingSpan.js\n  var SentryNonRecordingSpan = class {\n    constructor(spanContext = {}) {\n      this._traceId = spanContext.traceId || uuid4();\n      this._spanId = spanContext.spanId || uuid4().substring(16);\n    }\n    /** @inheritdoc */\n    spanContext() {\n      return {\n        spanId: this._spanId,\n        traceId: this._traceId,\n        traceFlags: TRACE_FLAG_NONE\n      };\n    }\n    /** @inheritdoc */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    end(_timestamp) {\n    }\n    /** @inheritdoc */\n    setAttribute(_key, _value) {\n      return this;\n    }\n    /** @inheritdoc */\n    setAttributes(_values) {\n      return this;\n    }\n    /** @inheritdoc */\n    setStatus(_status) {\n      return this;\n    }\n    /** @inheritdoc */\n    updateName(_name) {\n      return this;\n    }\n    /** @inheritdoc */\n    isRecording() {\n      return false;\n    }\n    /** @inheritdoc */\n    addEvent(_name, _attributesOrStartTime, _startTime) {\n      return this;\n    }\n  };\n\n  // node_modules/@sentry/core/esm/constants.js\n  var DEFAULT_ENVIRONMENT = \"production\";\n\n  // node_modules/@sentry/core/esm/tracing/dynamicSamplingContext.js\n  var FROZEN_DSC_FIELD = \"_frozenDsc\";\n  function freezeDscOnSpan(span, dsc) {\n    const spanWithMaybeDsc = span;\n    addNonEnumerableProperty(spanWithMaybeDsc, FROZEN_DSC_FIELD, dsc);\n  }\n  function getDynamicSamplingContextFromClient(trace_id, client) {\n    const options = client.getOptions();\n    const { publicKey: public_key } = client.getDsn() || {};\n    const dsc = dropUndefinedKeys({\n      environment: options.environment || DEFAULT_ENVIRONMENT,\n      release: options.release,\n      public_key,\n      trace_id\n    });\n    client.emit(\"createDsc\", dsc);\n    return dsc;\n  }\n  function getDynamicSamplingContextFromSpan(span) {\n    const client = getClient();\n    if (!client) {\n      return {};\n    }\n    const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || \"\", client);\n    const rootSpan = getRootSpan(span);\n    const frozenDsc = rootSpan[FROZEN_DSC_FIELD];\n    if (frozenDsc) {\n      return frozenDsc;\n    }\n    const traceState = rootSpan.spanContext().traceState;\n    const traceStateDsc = traceState && traceState.get(\"sentry.dsc\");\n    const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);\n    if (dscOnTraceState) {\n      return dscOnTraceState;\n    }\n    const jsonSpan = spanToJSON(rootSpan);\n    const attributes = jsonSpan.data || {};\n    const maybeSampleRate = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n    if (maybeSampleRate != null) {\n      dsc.sample_rate = `${maybeSampleRate}`;\n    }\n    const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n    const name2 = jsonSpan.description;\n    if (source !== \"url\" && name2) {\n      dsc.transaction = name2;\n    }\n    dsc.sampled = String(spanIsSampled(rootSpan));\n    client.emit(\"createDsc\", dsc, rootSpan);\n    return dsc;\n  }\n\n  // node_modules/@sentry/core/esm/tracing/logSpans.js\n  function logSpanStart(span) {\n    if (!DEBUG_BUILD2)\n      return;\n    const { description = \"< unknown name >\", op = \"< unknown op >\", parent_span_id: parentSpanId } = spanToJSON(span);\n    const { spanId } = span.spanContext();\n    const sampled = spanIsSampled(span);\n    const rootSpan = getRootSpan(span);\n    const isRootSpan = rootSpan === span;\n    const header = `[Tracing] Starting ${sampled ? \"sampled\" : \"unsampled\"} ${isRootSpan ? \"root \" : \"\"}span`;\n    const infoParts = [`op: ${op}`, `name: ${description}`, `ID: ${spanId}`];\n    if (parentSpanId) {\n      infoParts.push(`parent ID: ${parentSpanId}`);\n    }\n    if (!isRootSpan) {\n      const { op: op2, description: description2 } = spanToJSON(rootSpan);\n      infoParts.push(`root ID: ${rootSpan.spanContext().spanId}`);\n      if (op2) {\n        infoParts.push(`root op: ${op2}`);\n      }\n      if (description2) {\n        infoParts.push(`root description: ${description2}`);\n      }\n    }\n    logger.log(`${header}\n  ${infoParts.join(\"\\n  \")}`);\n  }\n  function logSpanEnd(span) {\n    if (!DEBUG_BUILD2)\n      return;\n    const { description = \"< unknown name >\", op = \"< unknown op >\" } = spanToJSON(span);\n    const { spanId } = span.spanContext();\n    const rootSpan = getRootSpan(span);\n    const isRootSpan = rootSpan === span;\n    const msg = `[Tracing] Finishing \"${op}\" ${isRootSpan ? \"root \" : \"\"}span \"${description}\" with ID ${spanId}`;\n    logger.log(msg);\n  }\n\n  // node_modules/@sentry/core/esm/utils/parseSampleRate.js\n  function parseSampleRate(sampleRate) {\n    if (typeof sampleRate === \"boolean\") {\n      return Number(sampleRate);\n    }\n    const rate = typeof sampleRate === \"string\" ? parseFloat(sampleRate) : sampleRate;\n    if (typeof rate !== \"number\" || isNaN(rate) || rate < 0 || rate > 1) {\n      DEBUG_BUILD2 && logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          sampleRate\n        )} of type ${JSON.stringify(typeof sampleRate)}.`\n      );\n      return void 0;\n    }\n    return rate;\n  }\n\n  // node_modules/@sentry/core/esm/tracing/sampling.js\n  function sampleSpan(options, samplingContext) {\n    if (!hasTracingEnabled(options)) {\n      return [false];\n    }\n    let sampleRate;\n    if (typeof options.tracesSampler === \"function\") {\n      sampleRate = options.tracesSampler(samplingContext);\n    } else if (samplingContext.parentSampled !== void 0) {\n      sampleRate = samplingContext.parentSampled;\n    } else if (typeof options.tracesSampleRate !== \"undefined\") {\n      sampleRate = options.tracesSampleRate;\n    } else {\n      sampleRate = 1;\n    }\n    const parsedSampleRate = parseSampleRate(sampleRate);\n    if (parsedSampleRate === void 0) {\n      DEBUG_BUILD2 && logger.warn(\"[Tracing] Discarding transaction because of invalid sample rate.\");\n      return [false];\n    }\n    if (!parsedSampleRate) {\n      DEBUG_BUILD2 && logger.log(\n        `[Tracing] Discarding transaction because ${typeof options.tracesSampler === \"function\" ? \"tracesSampler returned 0 or false\" : \"a negative sampling decision was inherited or tracesSampleRate is set to 0\"}`\n      );\n      return [false, parsedSampleRate];\n    }\n    const shouldSample = Math.random() < parsedSampleRate;\n    if (!shouldSample) {\n      DEBUG_BUILD2 && logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate\n        )})`\n      );\n      return [false, parsedSampleRate];\n    }\n    return [true, parsedSampleRate];\n  }\n\n  // node_modules/@sentry/core/esm/envelope.js\n  function enhanceEventWithSdkInfo(event, sdkInfo) {\n    if (!sdkInfo) {\n      return event;\n    }\n    event.sdk = event.sdk || {};\n    event.sdk.name = event.sdk.name || sdkInfo.name;\n    event.sdk.version = event.sdk.version || sdkInfo.version;\n    event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];\n    event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];\n    return event;\n  }\n  function createSessionEnvelope(session, dsn, metadata, tunnel) {\n    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n    const envelopeHeaders = {\n      sent_at: (/* @__PURE__ */ new Date()).toISOString(),\n      ...sdkInfo && { sdk: sdkInfo },\n      ...!!tunnel && dsn && { dsn: dsnToString(dsn) }\n    };\n    const envelopeItem = \"aggregates\" in session ? [{ type: \"sessions\" }, session] : [{ type: \"session\" }, session.toJSON()];\n    return createEnvelope(envelopeHeaders, [envelopeItem]);\n  }\n  function createEventEnvelope(event, dsn, metadata, tunnel) {\n    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n    const eventType = event.type && event.type !== \"replay_event\" ? event.type : \"event\";\n    enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n    const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n    delete event.sdkProcessingMetadata;\n    const eventItem = [{ type: eventType }, event];\n    return createEnvelope(envelopeHeaders, [eventItem]);\n  }\n  function createSpanEnvelope(spans, client) {\n    function dscHasRequiredProps(dsc2) {\n      return !!dsc2.trace_id && !!dsc2.public_key;\n    }\n    const dsc = getDynamicSamplingContextFromSpan(spans[0]);\n    const dsn = client && client.getDsn();\n    const tunnel = client && client.getOptions().tunnel;\n    const headers = {\n      sent_at: (/* @__PURE__ */ new Date()).toISOString(),\n      ...dscHasRequiredProps(dsc) && { trace: dsc },\n      ...!!tunnel && dsn && { dsn: dsnToString(dsn) }\n    };\n    const beforeSendSpan = client && client.getOptions().beforeSendSpan;\n    const convertToSpanJSON = beforeSendSpan ? (span) => beforeSendSpan(spanToJSON(span)) : (span) => spanToJSON(span);\n    const items = [];\n    for (const span of spans) {\n      const spanJson = convertToSpanJSON(span);\n      if (spanJson) {\n        items.push(createSpanEnvelopeItem(spanJson));\n      }\n    }\n    return createEnvelope(headers, items);\n  }\n\n  // node_modules/@sentry/core/esm/tracing/measurement.js\n  function setMeasurement(name2, value, unit) {\n    const activeSpan = getActiveSpan();\n    const rootSpan = activeSpan && getRootSpan(activeSpan);\n    if (rootSpan) {\n      rootSpan.addEvent(name2, {\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: value,\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: unit\n      });\n    }\n  }\n  function timedEventsToMeasurements(events) {\n    if (!events || events.length === 0) {\n      return void 0;\n    }\n    const measurements = {};\n    events.forEach((event) => {\n      const attributes = event.attributes || {};\n      const unit = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT];\n      const value = attributes[SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];\n      if (typeof unit === \"string\" && typeof value === \"number\") {\n        measurements[event.name] = { value, unit };\n      }\n    });\n    return measurements;\n  }\n\n  // node_modules/@sentry/core/esm/tracing/sentrySpan.js\n  var MAX_SPAN_COUNT = 1e3;\n  var SentrySpan = class {\n    /** Epoch timestamp in seconds when the span started. */\n    /** Epoch timestamp in seconds when the span ended. */\n    /** Internal keeper of the status */\n    /** The timed events added to this span. */\n    /** if true, treat span as a standalone span (not part of a transaction) */\n    /**\n     * You should never call the constructor manually, always use `Sentry.startSpan()`\n     * or other span methods.\n     * @internal\n     * @hideconstructor\n     * @hidden\n     */\n    constructor(spanContext = {}) {\n      this._traceId = spanContext.traceId || uuid4();\n      this._spanId = spanContext.spanId || uuid4().substring(16);\n      this._startTime = spanContext.startTimestamp || timestampInSeconds();\n      this._attributes = {};\n      this.setAttributes({\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"manual\",\n        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: spanContext.op,\n        ...spanContext.attributes\n      });\n      this._name = spanContext.name;\n      if (spanContext.parentSpanId) {\n        this._parentSpanId = spanContext.parentSpanId;\n      }\n      if (\"sampled\" in spanContext) {\n        this._sampled = spanContext.sampled;\n      }\n      if (spanContext.endTimestamp) {\n        this._endTime = spanContext.endTimestamp;\n      }\n      this._events = [];\n      this._isStandaloneSpan = spanContext.isStandalone;\n      if (this._endTime) {\n        this._onSpanEnded();\n      }\n    }\n    /** @inheritdoc */\n    spanContext() {\n      const { _spanId: spanId, _traceId: traceId, _sampled: sampled } = this;\n      return {\n        spanId,\n        traceId,\n        traceFlags: sampled ? TRACE_FLAG_SAMPLED : TRACE_FLAG_NONE\n      };\n    }\n    /** @inheritdoc */\n    setAttribute(key, value) {\n      if (value === void 0) {\n        delete this._attributes[key];\n      } else {\n        this._attributes[key] = value;\n      }\n    }\n    /** @inheritdoc */\n    setAttributes(attributes) {\n      Object.keys(attributes).forEach((key) => this.setAttribute(key, attributes[key]));\n    }\n    /**\n     * This should generally not be used,\n     * but we need it for browser tracing where we want to adjust the start time afterwards.\n     * USE THIS WITH CAUTION!\n     *\n     * @hidden\n     * @internal\n     */\n    updateStartTime(timeInput) {\n      this._startTime = spanTimeInputToSeconds(timeInput);\n    }\n    /**\n     * @inheritDoc\n     */\n    setStatus(value) {\n      this._status = value;\n      return this;\n    }\n    /**\n     * @inheritDoc\n     */\n    updateName(name2) {\n      this._name = name2;\n      return this;\n    }\n    /** @inheritdoc */\n    end(endTimestamp) {\n      if (this._endTime) {\n        return;\n      }\n      this._endTime = spanTimeInputToSeconds(endTimestamp);\n      logSpanEnd(this);\n      this._onSpanEnded();\n    }\n    /**\n     * Get JSON representation of this span.\n     *\n     * @hidden\n     * @internal This method is purely for internal purposes and should not be used outside\n     * of SDK code. If you need to get a JSON representation of a span,\n     * use `spanToJSON(span)` instead.\n     */\n    getSpanJSON() {\n      return dropUndefinedKeys({\n        data: this._attributes,\n        description: this._name,\n        op: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],\n        parent_span_id: this._parentSpanId,\n        span_id: this._spanId,\n        start_timestamp: this._startTime,\n        status: getStatusMessage(this._status),\n        timestamp: this._endTime,\n        trace_id: this._traceId,\n        origin: this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],\n        _metrics_summary: getMetricSummaryJsonForSpan(this),\n        profile_id: this._attributes[SEMANTIC_ATTRIBUTE_PROFILE_ID],\n        exclusive_time: this._attributes[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],\n        measurements: timedEventsToMeasurements(this._events),\n        is_segment: this._isStandaloneSpan && getRootSpan(this) === this || void 0,\n        segment_id: this._isStandaloneSpan ? getRootSpan(this).spanContext().spanId : void 0\n      });\n    }\n    /** @inheritdoc */\n    isRecording() {\n      return !this._endTime && !!this._sampled;\n    }\n    /**\n     * @inheritdoc\n     */\n    addEvent(name2, attributesOrStartTime, startTime) {\n      DEBUG_BUILD2 && logger.log(\"[Tracing] Adding an event to span:\", name2);\n      const time = isSpanTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime || timestampInSeconds();\n      const attributes = isSpanTimeInput(attributesOrStartTime) ? {} : attributesOrStartTime || {};\n      const event = {\n        name: name2,\n        time: spanTimeInputToSeconds(time),\n        attributes\n      };\n      this._events.push(event);\n      return this;\n    }\n    /**\n     * This method should generally not be used,\n     * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.\n     * USE THIS WITH CAUTION!\n     * @internal\n     * @hidden\n     * @experimental\n     */\n    isStandaloneSpan() {\n      return !!this._isStandaloneSpan;\n    }\n    /** Emit `spanEnd` when the span is ended. */\n    _onSpanEnded() {\n      const client = getClient();\n      if (client) {\n        client.emit(\"spanEnd\", this);\n      }\n      const isSegmentSpan = this._isStandaloneSpan || this === getRootSpan(this);\n      if (!isSegmentSpan) {\n        return;\n      }\n      if (this._isStandaloneSpan) {\n        if (this._sampled) {\n          sendSpanEnvelope(createSpanEnvelope([this], client));\n        } else {\n          DEBUG_BUILD2 && logger.log(\"[Tracing] Discarding standalone span because its trace was not chosen to be sampled.\");\n          if (client) {\n            client.recordDroppedEvent(\"sample_rate\", \"span\");\n          }\n        }\n        return;\n      }\n      const transactionEvent = this._convertSpanToTransaction();\n      if (transactionEvent) {\n        const scope = getCapturedScopesOnSpan(this).scope || getCurrentScope();\n        scope.captureEvent(transactionEvent);\n      }\n    }\n    /**\n     * Finish the transaction & prepare the event to send to Sentry.\n     */\n    _convertSpanToTransaction() {\n      if (!isFullFinishedSpan(spanToJSON(this))) {\n        return void 0;\n      }\n      if (!this._name) {\n        DEBUG_BUILD2 && logger.warn(\"Transaction has no name, falling back to `<unlabeled transaction>`.\");\n        this._name = \"<unlabeled transaction>\";\n      }\n      const { scope: capturedSpanScope, isolationScope: capturedSpanIsolationScope } = getCapturedScopesOnSpan(this);\n      const scope = capturedSpanScope || getCurrentScope();\n      const client = scope.getClient() || getClient();\n      if (this._sampled !== true) {\n        DEBUG_BUILD2 && logger.log(\"[Tracing] Discarding transaction because its trace was not chosen to be sampled.\");\n        if (client) {\n          client.recordDroppedEvent(\"sample_rate\", \"transaction\");\n        }\n        return void 0;\n      }\n      const finishedSpans = getSpanDescendants(this).filter((span) => span !== this && !isStandaloneSpan(span));\n      const spans = finishedSpans.map((span) => spanToJSON(span)).filter(isFullFinishedSpan);\n      const source = this._attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n      const transaction = {\n        contexts: {\n          trace: spanToTransactionTraceContext(this)\n        },\n        spans: (\n          // spans.sort() mutates the array, but `spans` is already a copy so we can safely do this here\n          // we do not use spans anymore after this point\n          spans.length > MAX_SPAN_COUNT ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT) : spans\n        ),\n        start_timestamp: this._startTime,\n        timestamp: this._endTime,\n        transaction: this._name,\n        type: \"transaction\",\n        sdkProcessingMetadata: {\n          capturedSpanScope,\n          capturedSpanIsolationScope,\n          ...dropUndefinedKeys({\n            dynamicSamplingContext: getDynamicSamplingContextFromSpan(this)\n          })\n        },\n        _metrics_summary: getMetricSummaryJsonForSpan(this),\n        ...source && {\n          transaction_info: {\n            source\n          }\n        }\n      };\n      const measurements = timedEventsToMeasurements(this._events);\n      const hasMeasurements = measurements && Object.keys(measurements).length;\n      if (hasMeasurements) {\n        DEBUG_BUILD2 && logger.log(\n          \"[Measurements] Adding measurements to transaction event\",\n          JSON.stringify(measurements, void 0, 2)\n        );\n        transaction.measurements = measurements;\n      }\n      return transaction;\n    }\n  };\n  function isSpanTimeInput(value) {\n    return value && typeof value === \"number\" || value instanceof Date || Array.isArray(value);\n  }\n  function isFullFinishedSpan(input) {\n    return !!input.start_timestamp && !!input.timestamp && !!input.span_id && !!input.trace_id;\n  }\n  function isStandaloneSpan(span) {\n    return span instanceof SentrySpan && span.isStandaloneSpan();\n  }\n  function sendSpanEnvelope(envelope) {\n    const client = getClient();\n    if (!client) {\n      return;\n    }\n    const spanItems = envelope[1];\n    if (!spanItems || spanItems.length === 0) {\n      client.recordDroppedEvent(\"before_send\", \"span\");\n      return;\n    }\n    const transport = client.getTransport();\n    if (transport) {\n      transport.send(envelope).then(null, (reason) => {\n        DEBUG_BUILD2 && logger.error(\"Error while sending span:\", reason);\n      });\n    }\n  }\n\n  // node_modules/@sentry/core/esm/tracing/trace.js\n  var SUPPRESS_TRACING_KEY = \"__SENTRY_SUPPRESS_TRACING__\";\n  function startInactiveSpan(options) {\n    const acs = getAcs();\n    if (acs.startInactiveSpan) {\n      return acs.startInactiveSpan(options);\n    }\n    const spanArguments = parseSentrySpanArguments(options);\n    const { forceTransaction, parentSpan: customParentSpan } = options;\n    const wrapper = options.scope ? (callback) => withScope2(options.scope, callback) : customParentSpan ? (callback) => withActiveSpan(customParentSpan, callback) : (callback) => callback();\n    return wrapper(() => {\n      const scope = getCurrentScope();\n      const parentSpan = getParentSpan(scope);\n      const shouldSkipSpan = options.onlyIfParent && !parentSpan;\n      if (shouldSkipSpan) {\n        return new SentryNonRecordingSpan();\n      }\n      return createChildOrRootSpan({\n        parentSpan,\n        spanArguments,\n        forceTransaction,\n        scope\n      });\n    });\n  }\n  function withActiveSpan(span, callback) {\n    const acs = getAcs();\n    if (acs.withActiveSpan) {\n      return acs.withActiveSpan(span, callback);\n    }\n    return withScope2((scope) => {\n      _setSpanForScope(scope, span || void 0);\n      return callback(scope);\n    });\n  }\n  function createChildOrRootSpan({\n    parentSpan,\n    spanArguments,\n    forceTransaction,\n    scope\n  }) {\n    if (!hasTracingEnabled()) {\n      return new SentryNonRecordingSpan();\n    }\n    const isolationScope = getIsolationScope();\n    let span;\n    if (parentSpan && !forceTransaction) {\n      span = _startChildSpan(parentSpan, scope, spanArguments);\n      addChildSpanToSpan(parentSpan, span);\n    } else if (parentSpan) {\n      const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n      const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n      const parentSampled = spanIsSampled(parentSpan);\n      span = _startRootSpan(\n        {\n          traceId,\n          parentSpanId,\n          ...spanArguments\n        },\n        scope,\n        parentSampled\n      );\n      freezeDscOnSpan(span, dsc);\n    } else {\n      const {\n        traceId,\n        dsc,\n        parentSpanId,\n        sampled: parentSampled\n      } = {\n        ...isolationScope.getPropagationContext(),\n        ...scope.getPropagationContext()\n      };\n      span = _startRootSpan(\n        {\n          traceId,\n          parentSpanId,\n          ...spanArguments\n        },\n        scope,\n        parentSampled\n      );\n      if (dsc) {\n        freezeDscOnSpan(span, dsc);\n      }\n    }\n    logSpanStart(span);\n    setCapturedScopesOnSpan(span, scope, isolationScope);\n    return span;\n  }\n  function parseSentrySpanArguments(options) {\n    const exp = options.experimental || {};\n    const initialCtx = {\n      isStandalone: exp.standalone,\n      ...options\n    };\n    if (options.startTime) {\n      const ctx = { ...initialCtx };\n      ctx.startTimestamp = spanTimeInputToSeconds(options.startTime);\n      delete ctx.startTime;\n      return ctx;\n    }\n    return initialCtx;\n  }\n  function getAcs() {\n    const carrier = getMainCarrier();\n    return getAsyncContextStrategy(carrier);\n  }\n  function _startRootSpan(spanArguments, scope, parentSampled) {\n    const client = getClient();\n    const options = client && client.getOptions() || {};\n    const { name: name2 = \"\", attributes } = spanArguments;\n    const [sampled, sampleRate] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? [false] : sampleSpan(options, {\n      name: name2,\n      parentSampled,\n      attributes,\n      transactionContext: {\n        name: name2,\n        parentSampled\n      }\n    });\n    const rootSpan = new SentrySpan({\n      ...spanArguments,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: \"custom\",\n        ...spanArguments.attributes\n      },\n      sampled\n    });\n    if (sampleRate !== void 0) {\n      rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);\n    }\n    if (client) {\n      client.emit(\"spanStart\", rootSpan);\n    }\n    return rootSpan;\n  }\n  function _startChildSpan(parentSpan, scope, spanArguments) {\n    const { spanId, traceId } = parentSpan.spanContext();\n    const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);\n    const childSpan = sampled ? new SentrySpan({\n      ...spanArguments,\n      parentSpanId: spanId,\n      traceId,\n      sampled\n    }) : new SentryNonRecordingSpan({ traceId });\n    addChildSpanToSpan(parentSpan, childSpan);\n    const client = getClient();\n    if (client) {\n      client.emit(\"spanStart\", childSpan);\n      if (spanArguments.endTimestamp) {\n        client.emit(\"spanEnd\", childSpan);\n      }\n    }\n    return childSpan;\n  }\n  function getParentSpan(scope) {\n    const span = _getSpanForScope(scope);\n    if (!span) {\n      return void 0;\n    }\n    const client = getClient();\n    const options = client ? client.getOptions() : {};\n    if (options.parentSpanIsAlwaysRootSpan) {\n      return getRootSpan(span);\n    }\n    return span;\n  }\n\n  // node_modules/@sentry/core/esm/tracing/idleSpan.js\n  var TRACING_DEFAULTS = {\n    idleTimeout: 1e3,\n    finalTimeout: 3e4,\n    childSpanTimeout: 15e3\n  };\n  var FINISH_REASON_HEARTBEAT_FAILED = \"heartbeatFailed\";\n  var FINISH_REASON_IDLE_TIMEOUT = \"idleTimeout\";\n  var FINISH_REASON_FINAL_TIMEOUT = \"finalTimeout\";\n  var FINISH_REASON_EXTERNAL_FINISH = \"externalFinish\";\n  function startIdleSpan(startSpanOptions, options = {}) {\n    const activities = /* @__PURE__ */ new Map();\n    let _finished = false;\n    let _idleTimeoutID;\n    let _finishReason = FINISH_REASON_EXTERNAL_FINISH;\n    let _autoFinishAllowed = !options.disableAutoFinish;\n    const {\n      idleTimeout = TRACING_DEFAULTS.idleTimeout,\n      finalTimeout = TRACING_DEFAULTS.finalTimeout,\n      childSpanTimeout = TRACING_DEFAULTS.childSpanTimeout,\n      beforeSpanEnd\n    } = options;\n    const client = getClient();\n    if (!client || !hasTracingEnabled()) {\n      return new SentryNonRecordingSpan();\n    }\n    const scope = getCurrentScope();\n    const previousActiveSpan = getActiveSpan();\n    const span = _startIdleSpan(startSpanOptions);\n    span.end = new Proxy(span.end, {\n      apply(target, thisArg, args) {\n        if (beforeSpanEnd) {\n          beforeSpanEnd(span);\n        }\n        const [definedEndTimestamp, ...rest] = args;\n        const timestamp = definedEndTimestamp || timestampInSeconds();\n        const spanEndTimestamp = spanTimeInputToSeconds(timestamp);\n        const spans = getSpanDescendants(span).filter((child) => child !== span);\n        if (!spans.length) {\n          onIdleSpanEnded(spanEndTimestamp);\n          return Reflect.apply(target, thisArg, [spanEndTimestamp, ...rest]);\n        }\n        const childEndTimestamps = spans.map((span2) => spanToJSON(span2).timestamp).filter((timestamp2) => !!timestamp2);\n        const latestSpanEndTimestamp = childEndTimestamps.length ? Math.max(...childEndTimestamps) : void 0;\n        const spanStartTimestamp = spanToJSON(span).start_timestamp;\n        const endTimestamp = Math.min(\n          spanStartTimestamp ? spanStartTimestamp + finalTimeout / 1e3 : Infinity,\n          Math.max(spanStartTimestamp || -Infinity, Math.min(spanEndTimestamp, latestSpanEndTimestamp || Infinity))\n        );\n        onIdleSpanEnded(endTimestamp);\n        return Reflect.apply(target, thisArg, [endTimestamp, ...rest]);\n      }\n    });\n    function _cancelIdleTimeout() {\n      if (_idleTimeoutID) {\n        clearTimeout(_idleTimeoutID);\n        _idleTimeoutID = void 0;\n      }\n    }\n    function _restartIdleTimeout(endTimestamp) {\n      _cancelIdleTimeout();\n      _idleTimeoutID = setTimeout(() => {\n        if (!_finished && activities.size === 0 && _autoFinishAllowed) {\n          _finishReason = FINISH_REASON_IDLE_TIMEOUT;\n          span.end(endTimestamp);\n        }\n      }, idleTimeout);\n    }\n    function _restartChildSpanTimeout(endTimestamp) {\n      _idleTimeoutID = setTimeout(() => {\n        if (!_finished && _autoFinishAllowed) {\n          _finishReason = FINISH_REASON_HEARTBEAT_FAILED;\n          span.end(endTimestamp);\n        }\n      }, childSpanTimeout);\n    }\n    function _pushActivity(spanId) {\n      _cancelIdleTimeout();\n      activities.set(spanId, true);\n      const endTimestamp = timestampInSeconds();\n      _restartChildSpanTimeout(endTimestamp + childSpanTimeout / 1e3);\n    }\n    function _popActivity(spanId) {\n      if (activities.has(spanId)) {\n        activities.delete(spanId);\n      }\n      if (activities.size === 0) {\n        const endTimestamp = timestampInSeconds();\n        _restartIdleTimeout(endTimestamp + idleTimeout / 1e3);\n      }\n    }\n    function onIdleSpanEnded(endTimestamp) {\n      _finished = true;\n      activities.clear();\n      _setSpanForScope(scope, previousActiveSpan);\n      const spanJSON = spanToJSON(span);\n      const { start_timestamp: startTimestamp } = spanJSON;\n      if (!startTimestamp) {\n        return;\n      }\n      const attributes = spanJSON.data || {};\n      if (!attributes[SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON]) {\n        span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, _finishReason);\n      }\n      logger.log(`[Tracing] Idle span \"${spanJSON.op}\" finished`);\n      const childSpans = getSpanDescendants(span).filter((child) => child !== span);\n      let discardedSpans = 0;\n      childSpans.forEach((childSpan) => {\n        if (childSpan.isRecording()) {\n          childSpan.setStatus({ code: SPAN_STATUS_ERROR, message: \"cancelled\" });\n          childSpan.end(endTimestamp);\n          DEBUG_BUILD2 && logger.log(\"[Tracing] Cancelling span since span ended early\", JSON.stringify(childSpan, void 0, 2));\n        }\n        const childSpanJSON = spanToJSON(childSpan);\n        const { timestamp: childEndTimestamp = 0, start_timestamp: childStartTimestamp = 0 } = childSpanJSON;\n        const spanStartedBeforeIdleSpanEnd = childStartTimestamp <= endTimestamp;\n        const timeoutWithMarginOfError = (finalTimeout + idleTimeout) / 1e3;\n        const spanEndedBeforeFinalTimeout = childEndTimestamp - childStartTimestamp <= timeoutWithMarginOfError;\n        if (DEBUG_BUILD2) {\n          const stringifiedSpan = JSON.stringify(childSpan, void 0, 2);\n          if (!spanStartedBeforeIdleSpanEnd) {\n            logger.log(\"[Tracing] Discarding span since it happened after idle span was finished\", stringifiedSpan);\n          } else if (!spanEndedBeforeFinalTimeout) {\n            logger.log(\"[Tracing] Discarding span since it finished after idle span final timeout\", stringifiedSpan);\n          }\n        }\n        if (!spanEndedBeforeFinalTimeout || !spanStartedBeforeIdleSpanEnd) {\n          removeChildSpanFromSpan(span, childSpan);\n          discardedSpans++;\n        }\n      });\n      if (discardedSpans > 0) {\n        span.setAttribute(\"sentry.idle_span_discarded_spans\", discardedSpans);\n      }\n    }\n    client.on(\"spanStart\", (startedSpan) => {\n      if (_finished || startedSpan === span || !!spanToJSON(startedSpan).timestamp) {\n        return;\n      }\n      const allSpans = getSpanDescendants(span);\n      if (allSpans.includes(startedSpan)) {\n        _pushActivity(startedSpan.spanContext().spanId);\n      }\n    });\n    client.on(\"spanEnd\", (endedSpan) => {\n      if (_finished) {\n        return;\n      }\n      _popActivity(endedSpan.spanContext().spanId);\n    });\n    client.on(\"idleSpanEnableAutoFinish\", (spanToAllowAutoFinish) => {\n      if (spanToAllowAutoFinish === span) {\n        _autoFinishAllowed = true;\n        _restartIdleTimeout();\n        if (activities.size) {\n          _restartChildSpanTimeout();\n        }\n      }\n    });\n    if (!options.disableAutoFinish) {\n      _restartIdleTimeout();\n    }\n    setTimeout(() => {\n      if (!_finished) {\n        span.setStatus({ code: SPAN_STATUS_ERROR, message: \"deadline_exceeded\" });\n        _finishReason = FINISH_REASON_FINAL_TIMEOUT;\n        span.end();\n      }\n    }, finalTimeout);\n    return span;\n  }\n  function _startIdleSpan(options) {\n    const span = startInactiveSpan(options);\n    _setSpanForScope(getCurrentScope(), span);\n    DEBUG_BUILD2 && logger.log(\"[Tracing] Started span is an idle span\");\n    return span;\n  }\n\n  // node_modules/@sentry/core/esm/eventProcessors.js\n  function notifyEventProcessors(processors, event, hint, index = 0) {\n    return new SyncPromise((resolve, reject) => {\n      const processor = processors[index];\n      if (event === null || typeof processor !== \"function\") {\n        resolve(event);\n      } else {\n        const result = processor({ ...event }, hint);\n        DEBUG_BUILD2 && processor.id && result === null && logger.log(`Event processor \"${processor.id}\" dropped event`);\n        if (isThenable(result)) {\n          void result.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject);\n        } else {\n          void notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);\n        }\n      }\n    });\n  }\n\n  // node_modules/@sentry/core/esm/utils/applyScopeDataToEvent.js\n  function applyScopeDataToEvent(event, data) {\n    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;\n    applyDataToEvent(event, data);\n    if (span) {\n      applySpanToEvent(event, span);\n    }\n    applyFingerprintToEvent(event, fingerprint);\n    applyBreadcrumbsToEvent(event, breadcrumbs);\n    applySdkMetadataToEvent(event, sdkProcessingMetadata);\n  }\n  function mergeScopeData(data, mergeData) {\n    const {\n      extra,\n      tags,\n      user,\n      contexts,\n      level,\n      sdkProcessingMetadata,\n      breadcrumbs,\n      fingerprint,\n      eventProcessors,\n      attachments,\n      propagationContext,\n      transactionName,\n      span\n    } = mergeData;\n    mergeAndOverwriteScopeData(data, \"extra\", extra);\n    mergeAndOverwriteScopeData(data, \"tags\", tags);\n    mergeAndOverwriteScopeData(data, \"user\", user);\n    mergeAndOverwriteScopeData(data, \"contexts\", contexts);\n    mergeAndOverwriteScopeData(data, \"sdkProcessingMetadata\", sdkProcessingMetadata);\n    if (level) {\n      data.level = level;\n    }\n    if (transactionName) {\n      data.transactionName = transactionName;\n    }\n    if (span) {\n      data.span = span;\n    }\n    if (breadcrumbs.length) {\n      data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];\n    }\n    if (fingerprint.length) {\n      data.fingerprint = [...data.fingerprint, ...fingerprint];\n    }\n    if (eventProcessors.length) {\n      data.eventProcessors = [...data.eventProcessors, ...eventProcessors];\n    }\n    if (attachments.length) {\n      data.attachments = [...data.attachments, ...attachments];\n    }\n    data.propagationContext = { ...data.propagationContext, ...propagationContext };\n  }\n  function mergeAndOverwriteScopeData(data, prop, mergeVal) {\n    if (mergeVal && Object.keys(mergeVal).length) {\n      data[prop] = { ...data[prop] };\n      for (const key in mergeVal) {\n        if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {\n          data[prop][key] = mergeVal[key];\n        }\n      }\n    }\n  }\n  function applyDataToEvent(event, data) {\n    const { extra, tags, user, contexts, level, transactionName } = data;\n    const cleanedExtra = dropUndefinedKeys(extra);\n    if (cleanedExtra && Object.keys(cleanedExtra).length) {\n      event.extra = { ...cleanedExtra, ...event.extra };\n    }\n    const cleanedTags = dropUndefinedKeys(tags);\n    if (cleanedTags && Object.keys(cleanedTags).length) {\n      event.tags = { ...cleanedTags, ...event.tags };\n    }\n    const cleanedUser = dropUndefinedKeys(user);\n    if (cleanedUser && Object.keys(cleanedUser).length) {\n      event.user = { ...cleanedUser, ...event.user };\n    }\n    const cleanedContexts = dropUndefinedKeys(contexts);\n    if (cleanedContexts && Object.keys(cleanedContexts).length) {\n      event.contexts = { ...cleanedContexts, ...event.contexts };\n    }\n    if (level) {\n      event.level = level;\n    }\n    if (transactionName && event.type !== \"transaction\") {\n      event.transaction = transactionName;\n    }\n  }\n  function applyBreadcrumbsToEvent(event, breadcrumbs) {\n    const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];\n    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;\n  }\n  function applySdkMetadataToEvent(event, sdkProcessingMetadata) {\n    event.sdkProcessingMetadata = {\n      ...event.sdkProcessingMetadata,\n      ...sdkProcessingMetadata\n    };\n  }\n  function applySpanToEvent(event, span) {\n    event.contexts = {\n      trace: spanToTraceContext(span),\n      ...event.contexts\n    };\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),\n      ...event.sdkProcessingMetadata\n    };\n    const rootSpan = getRootSpan(span);\n    const transactionName = spanToJSON(rootSpan).description;\n    if (transactionName && !event.transaction && event.type === \"transaction\") {\n      event.transaction = transactionName;\n    }\n  }\n  function applyFingerprintToEvent(event, fingerprint) {\n    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];\n    if (fingerprint) {\n      event.fingerprint = event.fingerprint.concat(fingerprint);\n    }\n    if (event.fingerprint && !event.fingerprint.length) {\n      delete event.fingerprint;\n    }\n  }\n\n  // node_modules/@sentry/core/esm/utils/prepareEvent.js\n  function prepareEvent(options, event, hint, scope, client, isolationScope) {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;\n    const prepared = {\n      ...event,\n      event_id: event.event_id || hint.event_id || uuid4(),\n      timestamp: event.timestamp || dateTimestampInSeconds()\n    };\n    const integrations = hint.integrations || options.integrations.map((i) => i.name);\n    applyClientOptions(prepared, options);\n    applyIntegrationsMetadata(prepared, integrations);\n    if (event.type === void 0) {\n      applyDebugIds(prepared, options.stackParser);\n    }\n    const finalScope = getFinalScope(scope, hint.captureContext);\n    if (hint.mechanism) {\n      addExceptionMechanism(prepared, hint.mechanism);\n    }\n    const clientEventProcessors = client ? client.getEventProcessors() : [];\n    const data = getGlobalScope().getScopeData();\n    if (isolationScope) {\n      const isolationData = isolationScope.getScopeData();\n      mergeScopeData(data, isolationData);\n    }\n    if (finalScope) {\n      const finalScopeData = finalScope.getScopeData();\n      mergeScopeData(data, finalScopeData);\n    }\n    const attachments = [...hint.attachments || [], ...data.attachments];\n    if (attachments.length) {\n      hint.attachments = attachments;\n    }\n    applyScopeDataToEvent(prepared, data);\n    const eventProcessors = [\n      ...clientEventProcessors,\n      // Run scope event processors _after_ all other processors\n      ...data.eventProcessors\n    ];\n    const result = notifyEventProcessors(eventProcessors, prepared, hint);\n    return result.then((evt) => {\n      if (evt) {\n        applyDebugMeta(evt);\n      }\n      if (typeof normalizeDepth === \"number\" && normalizeDepth > 0) {\n        return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n  function applyClientOptions(event, options) {\n    const { environment, release, dist, maxValueLength = 250 } = options;\n    if (!(\"environment\" in event)) {\n      event.environment = \"environment\" in options ? environment : DEFAULT_ENVIRONMENT;\n    }\n    if (event.release === void 0 && release !== void 0) {\n      event.release = release;\n    }\n    if (event.dist === void 0 && dist !== void 0) {\n      event.dist = dist;\n    }\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n  var debugIdStackParserCache = /* @__PURE__ */ new WeakMap();\n  function applyDebugIds(event, stackParser) {\n    const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n    if (!debugIdMap) {\n      return;\n    }\n    let debugIdStackFramesCache;\n    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);\n    if (cachedDebugIdStackFrameCache) {\n      debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n    } else {\n      debugIdStackFramesCache = /* @__PURE__ */ new Map();\n      debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);\n    }\n    const filenameDebugIdMap = Object.entries(debugIdMap).reduce(\n      (acc, [debugIdStackTrace, debugIdValue]) => {\n        let parsedStack;\n        const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n        if (cachedParsedStack) {\n          parsedStack = cachedParsedStack;\n        } else {\n          parsedStack = stackParser(debugIdStackTrace);\n          debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n        }\n        for (let i = parsedStack.length - 1; i >= 0; i--) {\n          const stackFrame = parsedStack[i];\n          if (stackFrame.filename) {\n            acc[stackFrame.filename] = debugIdValue;\n            break;\n          }\n        }\n        return acc;\n      },\n      {}\n    );\n    try {\n      event.exception.values.forEach((exception) => {\n        exception.stacktrace.frames.forEach((frame) => {\n          if (frame.filename) {\n            frame.debug_id = filenameDebugIdMap[frame.filename];\n          }\n        });\n      });\n    } catch (e2) {\n    }\n  }\n  function applyDebugMeta(event) {\n    const filenameDebugIdMap = {};\n    try {\n      event.exception.values.forEach((exception) => {\n        exception.stacktrace.frames.forEach((frame) => {\n          if (frame.debug_id) {\n            if (frame.abs_path) {\n              filenameDebugIdMap[frame.abs_path] = frame.debug_id;\n            } else if (frame.filename) {\n              filenameDebugIdMap[frame.filename] = frame.debug_id;\n            }\n            delete frame.debug_id;\n          }\n        });\n      });\n    } catch (e2) {\n    }\n    if (Object.keys(filenameDebugIdMap).length === 0) {\n      return;\n    }\n    event.debug_meta = event.debug_meta || {};\n    event.debug_meta.images = event.debug_meta.images || [];\n    const images = event.debug_meta.images;\n    Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {\n      images.push({\n        type: \"sourcemap\",\n        code_file: filename,\n        debug_id\n      });\n    });\n  }\n  function applyIntegrationsMetadata(event, integrationNames) {\n    if (integrationNames.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];\n    }\n  }\n  function normalizeEvent(event, depth, maxBreadth) {\n    if (!event) {\n      return null;\n    }\n    const normalized = {\n      ...event,\n      ...event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map((b) => ({\n          ...b,\n          ...b.data && {\n            data: normalize(b.data, depth, maxBreadth)\n          }\n        }))\n      },\n      ...event.user && {\n        user: normalize(event.user, depth, maxBreadth)\n      },\n      ...event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth)\n      },\n      ...event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth)\n      }\n    };\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n      normalized.contexts.trace = event.contexts.trace;\n      if (event.contexts.trace.data) {\n        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n      }\n    }\n    if (event.spans) {\n      normalized.spans = event.spans.map((span) => {\n        return {\n          ...span,\n          ...span.data && {\n            data: normalize(span.data, depth, maxBreadth)\n          }\n        };\n      });\n    }\n    return normalized;\n  }\n  function getFinalScope(scope, captureContext) {\n    if (!captureContext) {\n      return scope;\n    }\n    const finalScope = scope ? scope.clone() : new Scope();\n    finalScope.update(captureContext);\n    return finalScope;\n  }\n  function parseEventHintOrCaptureContext(hint) {\n    if (!hint) {\n      return void 0;\n    }\n    if (hintIsScopeOrFunction(hint)) {\n      return { captureContext: hint };\n    }\n    if (hintIsScopeContext(hint)) {\n      return {\n        captureContext: hint\n      };\n    }\n    return hint;\n  }\n  function hintIsScopeOrFunction(hint) {\n    return hint instanceof Scope || typeof hint === \"function\";\n  }\n  var captureContextKeys = [\n    \"user\",\n    \"level\",\n    \"extra\",\n    \"contexts\",\n    \"tags\",\n    \"fingerprint\",\n    \"requestSession\",\n    \"propagationContext\"\n  ];\n  function hintIsScopeContext(hint) {\n    return Object.keys(hint).some((key) => captureContextKeys.includes(key));\n  }\n\n  // node_modules/@sentry/core/esm/exports.js\n  function captureException(exception, hint) {\n    return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n  }\n  function captureEvent(event, hint) {\n    return getCurrentScope().captureEvent(event, hint);\n  }\n  function setContext(name2, context) {\n    getIsolationScope().setContext(name2, context);\n  }\n  function setUser(user) {\n    getIsolationScope().setUser(user);\n  }\n  function addEventProcessor(callback) {\n    getIsolationScope().addEventProcessor(callback);\n  }\n  function startSession(context) {\n    const client = getClient();\n    const isolationScope = getIsolationScope();\n    const currentScope = getCurrentScope();\n    const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};\n    const { userAgent } = GLOBAL_OBJ.navigator || {};\n    const session = makeSession({\n      release,\n      environment,\n      user: currentScope.getUser() || isolationScope.getUser(),\n      ...userAgent && { userAgent },\n      ...context\n    });\n    const currentSession = isolationScope.getSession();\n    if (currentSession && currentSession.status === \"ok\") {\n      updateSession(currentSession, { status: \"exited\" });\n    }\n    endSession();\n    isolationScope.setSession(session);\n    currentScope.setSession(session);\n    return session;\n  }\n  function endSession() {\n    const isolationScope = getIsolationScope();\n    const currentScope = getCurrentScope();\n    const session = currentScope.getSession() || isolationScope.getSession();\n    if (session) {\n      closeSession(session);\n    }\n    _sendSessionUpdate();\n    isolationScope.setSession();\n    currentScope.setSession();\n  }\n  function _sendSessionUpdate() {\n    const isolationScope = getIsolationScope();\n    const currentScope = getCurrentScope();\n    const client = getClient();\n    const session = currentScope.getSession() || isolationScope.getSession();\n    if (session && client) {\n      client.captureSession(session);\n    }\n  }\n  function captureSession(end2 = false) {\n    if (end2) {\n      endSession();\n      return;\n    }\n    _sendSessionUpdate();\n  }\n\n  // node_modules/@sentry/core/esm/api.js\n  var SENTRY_API_VERSION = \"7\";\n  function getBaseApiEndpoint(dsn) {\n    const protocol = dsn.protocol ? `${dsn.protocol}:` : \"\";\n    const port = dsn.port ? `:${dsn.port}` : \"\";\n    return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : \"\"}/api/`;\n  }\n  function _getIngestEndpoint(dsn) {\n    return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n  }\n  function _encodedAuth(dsn, sdkInfo) {\n    return urlEncode2({\n      // We send only the minimum set of required information. See\n      // https://github.com/getsentry/sentry-javascript/issues/2572.\n      sentry_key: dsn.publicKey,\n      sentry_version: SENTRY_API_VERSION,\n      ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }\n    });\n  }\n  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {\n    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n  }\n\n  // node_modules/@sentry/core/esm/integration.js\n  var installedIntegrations = [];\n  function filterDuplicates(integrations) {\n    const integrationsByName = {};\n    integrations.forEach((currentInstance) => {\n      const { name: name2 } = currentInstance;\n      const existingInstance = integrationsByName[name2];\n      if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n        return;\n      }\n      integrationsByName[name2] = currentInstance;\n    });\n    return Object.values(integrationsByName);\n  }\n  function getIntegrationsToSetup(options) {\n    const defaultIntegrations = options.defaultIntegrations || [];\n    const userIntegrations = options.integrations;\n    defaultIntegrations.forEach((integration) => {\n      integration.isDefaultInstance = true;\n    });\n    let integrations;\n    if (Array.isArray(userIntegrations)) {\n      integrations = [...defaultIntegrations, ...userIntegrations];\n    } else if (typeof userIntegrations === \"function\") {\n      integrations = arrayify(userIntegrations(defaultIntegrations));\n    } else {\n      integrations = defaultIntegrations;\n    }\n    const finalIntegrations = filterDuplicates(integrations);\n    const debugIndex = finalIntegrations.findIndex((integration) => integration.name === \"Debug\");\n    if (debugIndex > -1) {\n      const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n      finalIntegrations.push(debugInstance);\n    }\n    return finalIntegrations;\n  }\n  function setupIntegrations(client, integrations) {\n    const integrationIndex = {};\n    integrations.forEach((integration) => {\n      if (integration) {\n        setupIntegration(client, integration, integrationIndex);\n      }\n    });\n    return integrationIndex;\n  }\n  function afterSetupIntegrations(client, integrations) {\n    for (const integration of integrations) {\n      if (integration && integration.afterAllSetup) {\n        integration.afterAllSetup(client);\n      }\n    }\n  }\n  function setupIntegration(client, integration, integrationIndex) {\n    if (integrationIndex[integration.name]) {\n      DEBUG_BUILD2 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);\n      return;\n    }\n    integrationIndex[integration.name] = integration;\n    if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === \"function\") {\n      integration.setupOnce();\n      installedIntegrations.push(integration.name);\n    }\n    if (integration.setup && typeof integration.setup === \"function\") {\n      integration.setup(client);\n    }\n    if (typeof integration.preprocessEvent === \"function\") {\n      const callback = integration.preprocessEvent.bind(integration);\n      client.on(\"preprocessEvent\", (event, hint) => callback(event, hint, client));\n    }\n    if (typeof integration.processEvent === \"function\") {\n      const callback = integration.processEvent.bind(integration);\n      const processor = Object.assign((event, hint) => callback(event, hint, client), {\n        id: integration.name\n      });\n      client.addEventProcessor(processor);\n    }\n    DEBUG_BUILD2 && logger.log(`Integration installed: ${integration.name}`);\n  }\n  function defineIntegration(fn2) {\n    return fn2;\n  }\n\n  // node_modules/@sentry/core/esm/baseclient.js\n  var ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n  var BaseClient = class {\n    /** Options passed to the SDK. */\n    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n    /** Array of set up integrations. */\n    /** Number of calls being processed */\n    /** Holds flushable  */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    /**\n     * Initializes this client instance.\n     *\n     * @param options Options for the client.\n     */\n    constructor(options) {\n      this._options = options;\n      this._integrations = {};\n      this._numProcessing = 0;\n      this._outcomes = {};\n      this._hooks = {};\n      this._eventProcessors = [];\n      if (options.dsn) {\n        this._dsn = makeDsn(options.dsn);\n      } else {\n        DEBUG_BUILD2 && logger.warn(\"No DSN provided, client will not send events.\");\n      }\n      if (this._dsn) {\n        const url = getEnvelopeEndpointWithUrlEncodedAuth(\n          this._dsn,\n          options.tunnel,\n          options._metadata ? options._metadata.sdk : void 0\n        );\n        this._transport = options.transport({\n          tunnel: this._options.tunnel,\n          recordDroppedEvent: this.recordDroppedEvent.bind(this),\n          ...options.transportOptions,\n          url\n        });\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    captureException(exception, hint, scope) {\n      const eventId = uuid4();\n      if (checkOrSetAlreadyCaught(exception)) {\n        DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);\n        return eventId;\n      }\n      const hintWithEventId = {\n        event_id: eventId,\n        ...hint\n      };\n      this._process(\n        this.eventFromException(exception, hintWithEventId).then(\n          (event) => this._captureEvent(event, hintWithEventId, scope)\n        )\n      );\n      return hintWithEventId.event_id;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureMessage(message, level, hint, currentScope) {\n      const hintWithEventId = {\n        event_id: uuid4(),\n        ...hint\n      };\n      const eventMessage = isParameterizedString(message) ? message : String(message);\n      const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);\n      this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));\n      return hintWithEventId.event_id;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureEvent(event, hint, currentScope) {\n      const eventId = uuid4();\n      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n        DEBUG_BUILD2 && logger.log(ALREADY_SEEN_ERROR);\n        return eventId;\n      }\n      const hintWithEventId = {\n        event_id: eventId,\n        ...hint\n      };\n      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n      const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;\n      this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope));\n      return hintWithEventId.event_id;\n    }\n    /**\n     * @inheritDoc\n     */\n    captureSession(session) {\n      if (!(typeof session.release === \"string\")) {\n        DEBUG_BUILD2 && logger.warn(\"Discarded session because of missing or non-string release\");\n      } else {\n        this.sendSession(session);\n        updateSession(session, { init: false });\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    getDsn() {\n      return this._dsn;\n    }\n    /**\n     * @inheritDoc\n     */\n    getOptions() {\n      return this._options;\n    }\n    /**\n     * @see SdkMetadata in @sentry/types\n     *\n     * @return The metadata of the SDK\n     */\n    getSdkMetadata() {\n      return this._options._metadata;\n    }\n    /**\n     * @inheritDoc\n     */\n    getTransport() {\n      return this._transport;\n    }\n    /**\n     * @inheritDoc\n     */\n    flush(timeout) {\n      const transport = this._transport;\n      if (transport) {\n        this.emit(\"flush\");\n        return this._isClientDoneProcessing(timeout).then((clientFinished) => {\n          return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);\n        });\n      } else {\n        return resolvedSyncPromise(true);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    close(timeout) {\n      return this.flush(timeout).then((result) => {\n        this.getOptions().enabled = false;\n        this.emit(\"close\");\n        return result;\n      });\n    }\n    /** Get all installed event processors. */\n    getEventProcessors() {\n      return this._eventProcessors;\n    }\n    /** @inheritDoc */\n    addEventProcessor(eventProcessor) {\n      this._eventProcessors.push(eventProcessor);\n    }\n    /** @inheritdoc */\n    init() {\n      if (this._isEnabled()) {\n        this._setupIntegrations();\n      }\n    }\n    /**\n     * Gets an installed integration by its name.\n     *\n     * @returns The installed integration or `undefined` if no integration with that `name` was installed.\n     */\n    getIntegrationByName(integrationName) {\n      return this._integrations[integrationName];\n    }\n    /**\n     * @inheritDoc\n     */\n    addIntegration(integration) {\n      const isAlreadyInstalled = this._integrations[integration.name];\n      setupIntegration(this, integration, this._integrations);\n      if (!isAlreadyInstalled) {\n        afterSetupIntegrations(this, [integration]);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    sendEvent(event, hint = {}) {\n      this.emit(\"beforeSendEvent\", event, hint);\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));\n      }\n      const promise = this.sendEnvelope(env);\n      if (promise) {\n        promise.then((sendResponse) => this.emit(\"afterSendEvent\", event, sendResponse), null);\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    sendSession(session) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this.sendEnvelope(env);\n    }\n    /**\n     * @inheritDoc\n     */\n    recordDroppedEvent(reason, category, _event) {\n      if (this._options.sendClientReports) {\n        const key = `${reason}:${category}`;\n        DEBUG_BUILD2 && logger.log(`Adding outcome: \"${key}\"`);\n        this._outcomes[key] = (this._outcomes[key] || 0) + 1;\n      }\n    }\n    // Keep on() & emit() signatures in sync with types' client.ts interface\n    /* eslint-disable @typescript-eslint/unified-signatures */\n    /** @inheritdoc */\n    /** @inheritdoc */\n    on(hook, callback) {\n      if (!this._hooks[hook]) {\n        this._hooks[hook] = [];\n      }\n      this._hooks[hook].push(callback);\n    }\n    /** @inheritdoc */\n    /** @inheritdoc */\n    emit(hook, ...rest) {\n      const callbacks = this._hooks[hook];\n      if (callbacks) {\n        callbacks.forEach((callback) => callback(...rest));\n      }\n    }\n    /**\n     * @inheritdoc\n     */\n    sendEnvelope(envelope) {\n      this.emit(\"beforeEnvelope\", envelope);\n      if (this._isEnabled() && this._transport) {\n        return this._transport.send(envelope).then(null, (reason) => {\n          DEBUG_BUILD2 && logger.error(\"Error while sending event:\", reason);\n          return reason;\n        });\n      }\n      DEBUG_BUILD2 && logger.error(\"Transport disabled\");\n      return resolvedSyncPromise({});\n    }\n    /* eslint-enable @typescript-eslint/unified-signatures */\n    /** Setup integrations for this client. */\n    _setupIntegrations() {\n      const { integrations } = this._options;\n      this._integrations = setupIntegrations(this, integrations);\n      afterSetupIntegrations(this, integrations);\n    }\n    /** Updates existing session based on the provided event */\n    _updateSessionFromEvent(session, event) {\n      let crashed = false;\n      let errored = false;\n      const exceptions = event.exception && event.exception.values;\n      if (exceptions) {\n        errored = true;\n        for (const ex of exceptions) {\n          const mechanism = ex.mechanism;\n          if (mechanism && mechanism.handled === false) {\n            crashed = true;\n            break;\n          }\n        }\n      }\n      const sessionNonTerminal = session.status === \"ok\";\n      const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n      if (shouldUpdateAndSend) {\n        updateSession(session, {\n          ...crashed && { status: \"crashed\" },\n          errors: session.errors || Number(errored || crashed)\n        });\n        this.captureSession(session);\n      }\n    }\n    /**\n     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n     * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n     * `false` otherwise\n     */\n    _isClientDoneProcessing(timeout) {\n      return new SyncPromise((resolve) => {\n        let ticked = 0;\n        const tick = 1;\n        const interval = setInterval(() => {\n          if (this._numProcessing == 0) {\n            clearInterval(interval);\n            resolve(true);\n          } else {\n            ticked += tick;\n            if (timeout && ticked >= timeout) {\n              clearInterval(interval);\n              resolve(false);\n            }\n          }\n        }, tick);\n      });\n    }\n    /** Determines whether this SDK is enabled and a transport is present. */\n    _isEnabled() {\n      return this.getOptions().enabled !== false && this._transport !== void 0;\n    }\n    /**\n     * Adds common information to events.\n     *\n     * The information includes release and environment from `options`,\n     * breadcrumbs and context (extra, tags and user) from the scope.\n     *\n     * Information that is already present in the event is never overwritten. For\n     * nested objects, such as the context, keys are merged.\n     *\n     * @param event The original event.\n     * @param hint May contain additional information about the original exception.\n     * @param currentScope A scope containing event metadata.\n     * @returns A new event with more information.\n     */\n    _prepareEvent(event, hint, currentScope, isolationScope = getIsolationScope()) {\n      const options = this.getOptions();\n      const integrations = Object.keys(this._integrations);\n      if (!hint.integrations && integrations.length > 0) {\n        hint.integrations = integrations;\n      }\n      this.emit(\"preprocessEvent\", event, hint);\n      if (!event.type) {\n        isolationScope.setLastEventId(event.event_id || hint.event_id);\n      }\n      return prepareEvent(options, event, hint, currentScope, this, isolationScope).then((evt) => {\n        if (evt === null) {\n          return evt;\n        }\n        const propagationContext = {\n          ...isolationScope.getPropagationContext(),\n          ...currentScope ? currentScope.getPropagationContext() : void 0\n        };\n        const trace = evt.contexts && evt.contexts.trace;\n        if (!trace && propagationContext) {\n          const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;\n          evt.contexts = {\n            trace: dropUndefinedKeys({\n              trace_id,\n              span_id: spanId,\n              parent_span_id: parentSpanId\n            }),\n            ...evt.contexts\n          };\n          const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this);\n          evt.sdkProcessingMetadata = {\n            dynamicSamplingContext,\n            ...evt.sdkProcessingMetadata\n          };\n        }\n        return evt;\n      });\n    }\n    /**\n     * Processes the event and logs an error in case of rejection\n     * @param event\n     * @param hint\n     * @param scope\n     */\n    _captureEvent(event, hint = {}, scope) {\n      return this._processEvent(event, hint, scope).then(\n        (finalEvent) => {\n          return finalEvent.event_id;\n        },\n        (reason) => {\n          if (DEBUG_BUILD2) {\n            const sentryError = reason;\n            if (sentryError.logLevel === \"log\") {\n              logger.log(sentryError.message);\n            } else {\n              logger.warn(sentryError);\n            }\n          }\n          return void 0;\n        }\n      );\n    }\n    /**\n     * Processes an event (either error or message) and sends it to Sentry.\n     *\n     * This also adds breadcrumbs and context information to the event. However,\n     * platform specific meta data (such as the User's IP address) must be added\n     * by the SDK implementor.\n     *\n     *\n     * @param event The event to send to Sentry.\n     * @param hint May contain additional information about the original exception.\n     * @param currentScope A scope containing event metadata.\n     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n     */\n    _processEvent(event, hint, currentScope) {\n      const options = this.getOptions();\n      const { sampleRate } = options;\n      const isTransaction = isTransactionEvent(event);\n      const isError2 = isErrorEvent2(event);\n      const eventType = event.type || \"error\";\n      const beforeSendLabel = `before send for type \\`${eventType}\\``;\n      const parsedSampleRate = typeof sampleRate === \"undefined\" ? void 0 : parseSampleRate(sampleRate);\n      if (isError2 && typeof parsedSampleRate === \"number\" && Math.random() > parsedSampleRate) {\n        this.recordDroppedEvent(\"sample_rate\", \"error\", event);\n        return rejectedSyncPromise(\n          new SentryError(\n            `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n            \"log\"\n          )\n        );\n      }\n      const dataCategory = eventType === \"replay_event\" ? \"replay\" : eventType;\n      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n      const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;\n      return this._prepareEvent(event, hint, currentScope, capturedSpanIsolationScope).then((prepared) => {\n        if (prepared === null) {\n          this.recordDroppedEvent(\"event_processor\", dataCategory, event);\n          throw new SentryError(\"An event processor returned `null`, will not send event.\", \"log\");\n        }\n        const isInternalException = hint.data && hint.data.__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n        const result = processBeforeSend(options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      }).then((processedEvent) => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent(\"before_send\", dataCategory, event);\n          throw new SentryError(`${beforeSendLabel} returned \\`null\\`, will not send event.`, \"log\");\n        }\n        const session = currentScope && currentScope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = \"custom\";\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source\n          };\n        }\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      }).then(null, (reason) => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n        this.captureException(reason, {\n          data: {\n            __sentry__: true\n          },\n          originalException: reason\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`\n        );\n      });\n    }\n    /**\n     * Occupies the client with processing and event\n     */\n    _process(promise) {\n      this._numProcessing++;\n      void promise.then(\n        (value) => {\n          this._numProcessing--;\n          return value;\n        },\n        (reason) => {\n          this._numProcessing--;\n          return reason;\n        }\n      );\n    }\n    /**\n     * Clears outcomes on this client and returns them.\n     */\n    _clearOutcomes() {\n      const outcomes = this._outcomes;\n      this._outcomes = {};\n      return Object.entries(outcomes).map(([key, quantity]) => {\n        const [reason, category] = key.split(\":\");\n        return {\n          reason,\n          category,\n          quantity\n        };\n      });\n    }\n    /**\n     * @inheritDoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  };\n  function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {\n    const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n    if (isThenable(beforeSendResult)) {\n      return beforeSendResult.then(\n        (event) => {\n          if (!isPlainObject(event) && event !== null) {\n            throw new SentryError(invalidValueError);\n          }\n          return event;\n        },\n        (e2) => {\n          throw new SentryError(`${beforeSendLabel} rejected with ${e2}`);\n        }\n      );\n    } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n      throw new SentryError(invalidValueError);\n    }\n    return beforeSendResult;\n  }\n  function processBeforeSend(options, event, hint) {\n    const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;\n    if (isErrorEvent2(event) && beforeSend) {\n      return beforeSend(event, hint);\n    }\n    if (isTransactionEvent(event)) {\n      if (event.spans && beforeSendSpan) {\n        const processedSpans = [];\n        for (const span of event.spans) {\n          const processedSpan = beforeSendSpan(span);\n          if (processedSpan) {\n            processedSpans.push(processedSpan);\n          }\n        }\n        event.spans = processedSpans;\n      }\n      if (beforeSendTransaction) {\n        return beforeSendTransaction(event, hint);\n      }\n    }\n    return event;\n  }\n  function isErrorEvent2(event) {\n    return event.type === void 0;\n  }\n  function isTransactionEvent(event) {\n    return event.type === \"transaction\";\n  }\n\n  // node_modules/@sentry/core/esm/sdk.js\n  function initAndBind(clientClass, options) {\n    if (options.debug === true) {\n      if (DEBUG_BUILD2) {\n        logger.enable();\n      } else {\n        consoleSandbox(() => {\n          console.warn(\"[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.\");\n        });\n      }\n    }\n    const scope = getCurrentScope();\n    scope.update(options.initialScope);\n    const client = new clientClass(options);\n    setCurrentClient(client);\n    client.init();\n  }\n  function setCurrentClient(client) {\n    getCurrentScope().setClient(client);\n  }\n\n  // node_modules/@sentry/core/esm/transports/base.js\n  var DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n  function createTransport(options, makeRequest, buffer = makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE\n  )) {\n    let rateLimits = {};\n    const flush2 = (timeout) => buffer.drain(timeout);\n    function send(envelope) {\n      const filteredEnvelopeItems = [];\n      forEachEnvelopeItem(envelope, (item, type) => {\n        const dataCategory = envelopeItemTypeToDataCategory(type);\n        if (isRateLimited(rateLimits, dataCategory)) {\n          const event = getEventForEnvelopeItem(item, type);\n          options.recordDroppedEvent(\"ratelimit_backoff\", dataCategory, event);\n        } else {\n          filteredEnvelopeItems.push(item);\n        }\n      });\n      if (filteredEnvelopeItems.length === 0) {\n        return resolvedSyncPromise({});\n      }\n      const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);\n      const recordEnvelopeLoss = (reason) => {\n        forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n          const event = getEventForEnvelopeItem(item, type);\n          options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);\n        });\n      };\n      const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(\n        (response) => {\n          if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {\n            DEBUG_BUILD2 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n          rateLimits = updateRateLimits(rateLimits, response);\n          return response;\n        },\n        (error) => {\n          recordEnvelopeLoss(\"network_error\");\n          throw error;\n        }\n      );\n      return buffer.add(requestTask).then(\n        (result) => result,\n        (error) => {\n          if (error instanceof SentryError) {\n            DEBUG_BUILD2 && logger.error(\"Skipped sending event because buffer is full.\");\n            recordEnvelopeLoss(\"queue_overflow\");\n            return resolvedSyncPromise({});\n          } else {\n            throw error;\n          }\n        }\n      );\n    }\n    return {\n      send,\n      flush: flush2\n    };\n  }\n  function getEventForEnvelopeItem(item, type) {\n    if (type !== \"event\" && type !== \"transaction\") {\n      return void 0;\n    }\n    return Array.isArray(item) ? item[1] : void 0;\n  }\n\n  // node_modules/@sentry/core/esm/utils/isSentryRequestUrl.js\n  function isSentryRequestUrl(url, client) {\n    const dsn = client && client.getDsn();\n    const tunnel = client && client.getOptions().tunnel;\n    return checkDsn(url, dsn) || checkTunnel(url, tunnel);\n  }\n  function checkTunnel(url, tunnel) {\n    if (!tunnel) {\n      return false;\n    }\n    return removeTrailingSlash(url) === removeTrailingSlash(tunnel);\n  }\n  function checkDsn(url, dsn) {\n    return dsn ? url.includes(dsn.host) : false;\n  }\n  function removeTrailingSlash(str2) {\n    return str2[str2.length - 1] === \"/\" ? str2.slice(0, -1) : str2;\n  }\n\n  // node_modules/@sentry/core/esm/utils/sdkMetadata.js\n  function applySdkMetadata(options, name2, names = [name2], source = \"npm\") {\n    const metadata = options._metadata || {};\n    if (!metadata.sdk) {\n      metadata.sdk = {\n        name: `sentry.javascript.${name2}`,\n        packages: names.map((name3) => ({\n          name: `${source}:@sentry/${name3}`,\n          version: SDK_VERSION\n        })),\n        version: SDK_VERSION\n      };\n    }\n    options._metadata = metadata;\n  }\n\n  // node_modules/@sentry/core/esm/breadcrumbs.js\n  var DEFAULT_BREADCRUMBS = 100;\n  function addBreadcrumb(breadcrumb, hint) {\n    const client = getClient();\n    const isolationScope = getIsolationScope();\n    if (!client)\n      return;\n    const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();\n    if (maxBreadcrumbs <= 0)\n      return;\n    const timestamp = dateTimestampInSeconds();\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;\n    if (finalBreadcrumb === null)\n      return;\n    if (client.emit) {\n      client.emit(\"beforeAddBreadcrumb\", finalBreadcrumb, hint);\n    }\n    isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n  }\n\n  // node_modules/@sentry/core/esm/integrations/functiontostring.js\n  var originalFunctionToString;\n  var INTEGRATION_NAME = \"FunctionToString\";\n  var SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();\n  var _functionToStringIntegration = () => {\n    return {\n      name: INTEGRATION_NAME,\n      setupOnce() {\n        originalFunctionToString = Function.prototype.toString;\n        try {\n          Function.prototype.toString = function(...args) {\n            const originalFunction = getOriginalFunction(this);\n            const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;\n            return originalFunctionToString.apply(context, args);\n          };\n        } catch (e2) {\n        }\n      },\n      setup(client) {\n        SETUP_CLIENTS.set(client, true);\n      }\n    };\n  };\n  var functionToStringIntegration = defineIntegration(_functionToStringIntegration);\n\n  // node_modules/@sentry/core/esm/integrations/inboundfilters.js\n  var DEFAULT_IGNORE_ERRORS = [\n    /^Script error\\.?$/,\n    /^Javascript error: Script error\\.? on line 0$/,\n    /^ResizeObserver loop completed with undelivered notifications.$/,\n    // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.\n    /^Cannot redefine property: googletag$/,\n    // This is thrown when google tag manager is used in combination with an ad blocker\n    \"undefined is not an object (evaluating 'a.L')\",\n    // Random error that happens but not actionable or noticeable to end-users.\n    `can't redefine non-configurable property \"solana\"`,\n    // Probably a browser extension or custom browser (Brave) throwing this error\n    \"vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)\",\n    // Error thrown by GTM, seemingly not affecting end-users\n    \"Can't find variable: _AutofillCallbackHandler\"\n    // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/\n  ];\n  var INTEGRATION_NAME2 = \"InboundFilters\";\n  var _inboundFiltersIntegration = (options = {}) => {\n    return {\n      name: INTEGRATION_NAME2,\n      processEvent(event, _hint, client) {\n        const clientOptions = client.getOptions();\n        const mergedOptions = _mergeOptions(options, clientOptions);\n        return _shouldDropEvent(event, mergedOptions) ? null : event;\n      }\n    };\n  };\n  var inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);\n  function _mergeOptions(internalOptions = {}, clientOptions = {}) {\n    return {\n      allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],\n      denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],\n      ignoreErrors: [\n        ...internalOptions.ignoreErrors || [],\n        ...clientOptions.ignoreErrors || [],\n        ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS\n      ],\n      ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []],\n      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true\n    };\n  }\n  function _shouldDropEvent(event, options) {\n    if (options.ignoreInternal && _isSentryError(event)) {\n      DEBUG_BUILD2 && logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(event)}`);\n      return true;\n    }\n    if (_isIgnoredError(event, options.ignoreErrors)) {\n      DEBUG_BUILD2 && logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\nEvent: ${getEventDescription(event)}`\n      );\n      return true;\n    }\n    if (_isUselessError(event)) {\n      DEBUG_BUILD2 && logger.warn(\n        `Event dropped due to not having an error message, error type or stacktrace.\nEvent: ${getEventDescription(\n          event\n        )}`\n      );\n      return true;\n    }\n    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {\n      DEBUG_BUILD2 && logger.warn(\n        `Event dropped due to being matched by \\`ignoreTransactions\\` option.\nEvent: ${getEventDescription(event)}`\n      );\n      return true;\n    }\n    if (_isDeniedUrl(event, options.denyUrls)) {\n      DEBUG_BUILD2 && logger.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\nEvent: ${getEventDescription(\n          event\n        )}.\nUrl: ${_getEventFilterUrl(event)}`\n      );\n      return true;\n    }\n    if (!_isAllowedUrl(event, options.allowUrls)) {\n      DEBUG_BUILD2 && logger.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\nEvent: ${getEventDescription(\n          event\n        )}.\nUrl: ${_getEventFilterUrl(event)}`\n      );\n      return true;\n    }\n    return false;\n  }\n  function _isIgnoredError(event, ignoreErrors) {\n    if (event.type || !ignoreErrors || !ignoreErrors.length) {\n      return false;\n    }\n    return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));\n  }\n  function _isIgnoredTransaction(event, ignoreTransactions) {\n    if (event.type !== \"transaction\" || !ignoreTransactions || !ignoreTransactions.length) {\n      return false;\n    }\n    const name2 = event.transaction;\n    return name2 ? stringMatchesSomePattern(name2, ignoreTransactions) : false;\n  }\n  function _isDeniedUrl(event, denyUrls) {\n    if (!denyUrls || !denyUrls.length) {\n      return false;\n    }\n    const url = _getEventFilterUrl(event);\n    return !url ? false : stringMatchesSomePattern(url, denyUrls);\n  }\n  function _isAllowedUrl(event, allowUrls) {\n    if (!allowUrls || !allowUrls.length) {\n      return true;\n    }\n    const url = _getEventFilterUrl(event);\n    return !url ? true : stringMatchesSomePattern(url, allowUrls);\n  }\n  function _getPossibleEventMessages(event) {\n    const possibleMessages = [];\n    if (event.message) {\n      possibleMessages.push(event.message);\n    }\n    let lastException;\n    try {\n      lastException = event.exception.values[event.exception.values.length - 1];\n    } catch (e2) {\n    }\n    if (lastException) {\n      if (lastException.value) {\n        possibleMessages.push(lastException.value);\n        if (lastException.type) {\n          possibleMessages.push(`${lastException.type}: ${lastException.value}`);\n        }\n      }\n    }\n    return possibleMessages;\n  }\n  function _isSentryError(event) {\n    try {\n      return event.exception.values[0].type === \"SentryError\";\n    } catch (e2) {\n    }\n    return false;\n  }\n  function _getLastValidUrl(frames = []) {\n    for (let i = frames.length - 1; i >= 0; i--) {\n      const frame = frames[i];\n      if (frame && frame.filename !== \"<anonymous>\" && frame.filename !== \"[native code]\") {\n        return frame.filename || null;\n      }\n    }\n    return null;\n  }\n  function _getEventFilterUrl(event) {\n    try {\n      let frames;\n      try {\n        frames = event.exception.values[0].stacktrace.frames;\n      } catch (e2) {\n      }\n      return frames ? _getLastValidUrl(frames) : null;\n    } catch (oO) {\n      DEBUG_BUILD2 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n      return null;\n    }\n  }\n  function _isUselessError(event) {\n    if (event.type) {\n      return false;\n    }\n    if (!event.exception || !event.exception.values || event.exception.values.length === 0) {\n      return false;\n    }\n    return (\n      // No top-level message\n      !event.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value\n      !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== \"Error\" || value.value)\n    );\n  }\n\n  // node_modules/@sentry/core/esm/integrations/dedupe.js\n  var INTEGRATION_NAME3 = \"Dedupe\";\n  var _dedupeIntegration = () => {\n    let previousEvent;\n    return {\n      name: INTEGRATION_NAME3,\n      processEvent(currentEvent) {\n        if (currentEvent.type) {\n          return currentEvent;\n        }\n        try {\n          if (_shouldDropEvent2(currentEvent, previousEvent)) {\n            DEBUG_BUILD2 && logger.warn(\"Event dropped due to being a duplicate of previously captured event.\");\n            return null;\n          }\n        } catch (_oO) {\n        }\n        return previousEvent = currentEvent;\n      }\n    };\n  };\n  var dedupeIntegration = defineIntegration(_dedupeIntegration);\n  function _shouldDropEvent2(currentEvent, previousEvent) {\n    if (!previousEvent) {\n      return false;\n    }\n    if (_isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n    if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n    return false;\n  }\n  function _isSameMessageEvent(currentEvent, previousEvent) {\n    const currentMessage = currentEvent.message;\n    const previousMessage = previousEvent.message;\n    if (!currentMessage && !previousMessage) {\n      return false;\n    }\n    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n      return false;\n    }\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n    if (!_isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n    if (!_isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n    return true;\n  }\n  function _isSameExceptionEvent(currentEvent, previousEvent) {\n    const previousException = _getExceptionFromEvent(previousEvent);\n    const currentException = _getExceptionFromEvent(currentEvent);\n    if (!previousException || !currentException) {\n      return false;\n    }\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n    if (!_isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n    if (!_isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n    return true;\n  }\n  function _isSameStacktrace(currentEvent, previousEvent) {\n    let currentFrames = getFramesFromEvent(currentEvent);\n    let previousFrames = getFramesFromEvent(previousEvent);\n    if (!currentFrames && !previousFrames) {\n      return true;\n    }\n    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n      return false;\n    }\n    currentFrames = currentFrames;\n    previousFrames = previousFrames;\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    }\n    for (let i = 0; i < previousFrames.length; i++) {\n      const frameA = previousFrames[i];\n      const frameB = currentFrames[i];\n      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function _isSameFingerprint(currentEvent, previousEvent) {\n    let currentFingerprint = currentEvent.fingerprint;\n    let previousFingerprint = previousEvent.fingerprint;\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    }\n    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n      return false;\n    }\n    currentFingerprint = currentFingerprint;\n    previousFingerprint = previousFingerprint;\n    try {\n      return !!(currentFingerprint.join(\"\") === previousFingerprint.join(\"\"));\n    } catch (_oO) {\n      return false;\n    }\n  }\n  function _getExceptionFromEvent(event) {\n    return event.exception && event.exception.values && event.exception.values[0];\n  }\n\n  // node_modules/@sentry/core/esm/fetch.js\n  function instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans, spanOrigin = \"auto.http.browser\") {\n    if (!handlerData.fetchData) {\n      return void 0;\n    }\n    const shouldCreateSpanResult = hasTracingEnabled() && shouldCreateSpan(handlerData.fetchData.url);\n    if (handlerData.endTimestamp && shouldCreateSpanResult) {\n      const spanId = handlerData.fetchData.__span;\n      if (!spanId)\n        return;\n      const span2 = spans[spanId];\n      if (span2) {\n        endSpan(span2, handlerData);\n        delete spans[spanId];\n      }\n      return void 0;\n    }\n    const scope = getCurrentScope();\n    const client = getClient();\n    const { method, url } = handlerData.fetchData;\n    const fullUrl = getFullURL(url);\n    const host = fullUrl ? parseUrl(fullUrl).host : void 0;\n    const hasParent = !!getActiveSpan();\n    const span = shouldCreateSpanResult && hasParent ? startInactiveSpan({\n      name: `${method} ${url}`,\n      attributes: {\n        url,\n        type: \"fetch\",\n        \"http.method\": method,\n        \"http.url\": fullUrl,\n        \"server.address\": host,\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: spanOrigin,\n        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: \"http.client\"\n      }\n    }) : new SentryNonRecordingSpan();\n    handlerData.fetchData.__span = span.spanContext().spanId;\n    spans[span.spanContext().spanId] = span;\n    if (shouldAttachHeaders2(handlerData.fetchData.url) && client) {\n      const request = handlerData.args[0];\n      handlerData.args[1] = handlerData.args[1] || {};\n      const options = handlerData.args[1];\n      options.headers = addTracingHeadersToFetchRequest(\n        request,\n        client,\n        scope,\n        options,\n        // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n        // we do not want to use the span as base for the trace headers,\n        // which means that the headers will be generated from the scope and the sampling decision is deferred\n        hasTracingEnabled() && hasParent ? span : void 0\n      );\n    }\n    return span;\n  }\n  function addTracingHeadersToFetchRequest(request, client, scope, options, span) {\n    const isolationScope = getIsolationScope();\n    const { traceId, spanId, sampled, dsc } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n    const sentryTraceHeader = span ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n      dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client))\n    );\n    const headers = options.headers || (typeof Request !== \"undefined\" && isInstanceOf(request, Request) ? request.headers : void 0);\n    if (!headers) {\n      return { \"sentry-trace\": sentryTraceHeader, baggage: sentryBaggageHeader };\n    } else if (typeof Headers !== \"undefined\" && isInstanceOf(headers, Headers)) {\n      const newHeaders = new Headers(headers);\n      newHeaders.append(\"sentry-trace\", sentryTraceHeader);\n      if (sentryBaggageHeader) {\n        newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n      }\n      return newHeaders;\n    } else if (Array.isArray(headers)) {\n      const newHeaders = [...headers, [\"sentry-trace\", sentryTraceHeader]];\n      if (sentryBaggageHeader) {\n        newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n      }\n      return newHeaders;\n    } else {\n      const existingBaggageHeader = \"baggage\" in headers ? headers.baggage : void 0;\n      const newBaggageHeaders = [];\n      if (Array.isArray(existingBaggageHeader)) {\n        newBaggageHeaders.push(...existingBaggageHeader);\n      } else if (existingBaggageHeader) {\n        newBaggageHeaders.push(existingBaggageHeader);\n      }\n      if (sentryBaggageHeader) {\n        newBaggageHeaders.push(sentryBaggageHeader);\n      }\n      return {\n        ...headers,\n        \"sentry-trace\": sentryTraceHeader,\n        baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(\",\") : void 0\n      };\n    }\n  }\n  function getFullURL(url) {\n    try {\n      const parsed = new URL(url);\n      return parsed.href;\n    } catch (e2) {\n      return void 0;\n    }\n  }\n  function endSpan(span, handlerData) {\n    if (handlerData.response) {\n      setHttpStatus(span, handlerData.response.status);\n      const contentLength = handlerData.response && handlerData.response.headers && handlerData.response.headers.get(\"content-length\");\n      if (contentLength) {\n        const contentLengthNum = parseInt(contentLength);\n        if (contentLengthNum > 0) {\n          span.setAttribute(\"http.response_content_length\", contentLengthNum);\n        }\n      }\n    } else if (handlerData.error) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: \"internal_error\" });\n    }\n    span.end();\n  }\n\n  // node_modules/@sentry/browser/esm/helpers.js\n  var WINDOW4 = GLOBAL_OBJ;\n  var ignoreOnError = 0;\n  function shouldIgnoreOnError() {\n    return ignoreOnError > 0;\n  }\n  function ignoreNextOnError() {\n    ignoreOnError++;\n    setTimeout(() => {\n      ignoreOnError--;\n    });\n  }\n  function wrap(fn2, options = {}, before) {\n    if (typeof fn2 !== \"function\") {\n      return fn2;\n    }\n    try {\n      const wrapper = fn2.__sentry_wrapped__;\n      if (wrapper) {\n        return wrapper;\n      }\n      if (getOriginalFunction(fn2)) {\n        return fn2;\n      }\n    } catch (e2) {\n      return fn2;\n    }\n    const sentryWrapped = function() {\n      const args = Array.prototype.slice.call(arguments);\n      try {\n        if (before && typeof before === \"function\") {\n          before.apply(this, arguments);\n        }\n        const wrappedArguments = args.map((arg) => wrap(arg, options));\n        return fn2.apply(this, wrappedArguments);\n      } catch (ex) {\n        ignoreNextOnError();\n        withScope2((scope) => {\n          scope.addEventProcessor((event) => {\n            if (options.mechanism) {\n              addExceptionTypeValue(event, void 0, void 0);\n              addExceptionMechanism(event, options.mechanism);\n            }\n            event.extra = {\n              ...event.extra,\n              arguments: args\n            };\n            return event;\n          });\n          captureException(ex);\n        });\n        throw ex;\n      }\n    };\n    try {\n      for (const property in fn2) {\n        if (Object.prototype.hasOwnProperty.call(fn2, property)) {\n          sentryWrapped[property] = fn2[property];\n        }\n      }\n    } catch (_oO) {\n    }\n    markFunctionWrapped(sentryWrapped, fn2);\n    addNonEnumerableProperty(fn2, \"__sentry_wrapped__\", sentryWrapped);\n    try {\n      const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, \"name\");\n      if (descriptor.configurable) {\n        Object.defineProperty(sentryWrapped, \"name\", {\n          get() {\n            return fn2.name;\n          }\n        });\n      }\n    } catch (_oO) {\n    }\n    return sentryWrapped;\n  }\n\n  // node_modules/@sentry/browser/esm/debug-build.js\n  var DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n\n  // node_modules/@sentry/browser/esm/eventbuilder.js\n  function exceptionFromError(stackParser, ex) {\n    const frames = parseStackFrames(stackParser, ex);\n    const exception = {\n      type: ex && ex.name,\n      value: extractMessage(ex)\n    };\n    if (frames.length) {\n      exception.stacktrace = { frames };\n    }\n    if (exception.type === void 0 && exception.value === \"\") {\n      exception.value = \"Unrecoverable error caught\";\n    }\n    return exception;\n  }\n  function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {\n    const client = getClient();\n    const normalizeDepth = client && client.getOptions().normalizeDepth;\n    const errorFromProp = getErrorPropertyFromObject(exception);\n    const extra = {\n      __serialized__: normalizeToSize(exception, normalizeDepth)\n    };\n    if (errorFromProp) {\n      return {\n        exception: {\n          values: [exceptionFromError(stackParser, errorFromProp)]\n        },\n        extra\n      };\n    }\n    const event = {\n      exception: {\n        values: [\n          {\n            type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? \"UnhandledRejection\" : \"Error\",\n            value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })\n          }\n        ]\n      },\n      extra\n    };\n    if (syntheticException) {\n      const frames = parseStackFrames(stackParser, syntheticException);\n      if (frames.length) {\n        event.exception.values[0].stacktrace = { frames };\n      }\n    }\n    return event;\n  }\n  function eventFromError(stackParser, ex) {\n    return {\n      exception: {\n        values: [exceptionFromError(stackParser, ex)]\n      }\n    };\n  }\n  function parseStackFrames(stackParser, ex) {\n    const stacktrace = ex.stacktrace || ex.stack || \"\";\n    const skipLines = getSkipFirstStackStringLines(ex);\n    const framesToPop = getPopFirstTopFrames(ex);\n    try {\n      return stackParser(stacktrace, skipLines, framesToPop);\n    } catch (e2) {\n    }\n    return [];\n  }\n  var reactMinifiedRegexp = /Minified React error #\\d+;/i;\n  function getSkipFirstStackStringLines(ex) {\n    if (ex && reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n    return 0;\n  }\n  function getPopFirstTopFrames(ex) {\n    if (typeof ex.framesToPop === \"number\") {\n      return ex.framesToPop;\n    }\n    return 0;\n  }\n  function extractMessage(ex) {\n    const message = ex && ex.message;\n    if (!message) {\n      return \"No error message\";\n    }\n    if (message.error && typeof message.error.message === \"string\") {\n      return message.error.message;\n    }\n    return message;\n  }\n  function eventFromException(stackParser, exception, hint, attachStacktrace) {\n    const syntheticException = hint && hint.syntheticException || void 0;\n    const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n    addExceptionMechanism(event);\n    event.level = \"error\";\n    if (hint && hint.event_id) {\n      event.event_id = hint.event_id;\n    }\n    return resolvedSyncPromise(event);\n  }\n  function eventFromMessage(stackParser, message, level = \"info\", hint, attachStacktrace) {\n    const syntheticException = hint && hint.syntheticException || void 0;\n    const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n    event.level = level;\n    if (hint && hint.event_id) {\n      event.event_id = hint.event_id;\n    }\n    return resolvedSyncPromise(event);\n  }\n  function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {\n    let event;\n    if (isErrorEvent(exception) && exception.error) {\n      const errorEvent = exception;\n      return eventFromError(stackParser, errorEvent.error);\n    }\n    if (isDOMError(exception) || isDOMException(exception)) {\n      const domException = exception;\n      if (\"stack\" in exception) {\n        event = eventFromError(stackParser, exception);\n      } else {\n        const name2 = domException.name || (isDOMError(domException) ? \"DOMError\" : \"DOMException\");\n        const message = domException.message ? `${name2}: ${domException.message}` : name2;\n        event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n        addExceptionTypeValue(event, message);\n      }\n      if (\"code\" in domException) {\n        event.tags = { ...event.tags, \"DOMException.code\": `${domException.code}` };\n      }\n      return event;\n    }\n    if (isError(exception)) {\n      return eventFromError(stackParser, exception);\n    }\n    if (isPlainObject(exception) || isEvent(exception)) {\n      const objectException = exception;\n      event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n      addExceptionMechanism(event, {\n        synthetic: true\n      });\n      return event;\n    }\n    event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);\n    addExceptionTypeValue(event, `${exception}`, void 0);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  }\n  function eventFromString(stackParser, message, syntheticException, attachStacktrace) {\n    const event = {};\n    if (attachStacktrace && syntheticException) {\n      const frames = parseStackFrames(stackParser, syntheticException);\n      if (frames.length) {\n        event.exception = {\n          values: [{ value: message, stacktrace: { frames } }]\n        };\n      }\n    }\n    if (isParameterizedString(message)) {\n      const { __sentry_template_string__, __sentry_template_values__ } = message;\n      event.logentry = {\n        message: __sentry_template_string__,\n        params: __sentry_template_values__\n      };\n      return event;\n    }\n    event.message = message;\n    return event;\n  }\n  function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {\n    const keys = extractExceptionKeysForMessage(exception);\n    const captureType = isUnhandledRejection ? \"promise rejection\" : \"exception\";\n    if (isErrorEvent(exception)) {\n      return `Event \\`ErrorEvent\\` captured as ${captureType} with message \\`${exception.message}\\``;\n    }\n    if (isEvent(exception)) {\n      const className = getObjectClassName(exception);\n      return `Event \\`${className}\\` (type=${exception.type}) captured as ${captureType}`;\n    }\n    return `Object captured as ${captureType} with keys: ${keys}`;\n  }\n  function getObjectClassName(obj) {\n    try {\n      const prototype = Object.getPrototypeOf(obj);\n      return prototype ? prototype.constructor.name : void 0;\n    } catch (e2) {\n    }\n  }\n  function getErrorPropertyFromObject(obj) {\n    for (const prop in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n        const value = obj[prop];\n        if (value instanceof Error) {\n          return value;\n        }\n      }\n    }\n    return void 0;\n  }\n\n  // node_modules/@sentry/browser/esm/userfeedback.js\n  function createUserFeedbackEnvelope(feedback, {\n    metadata,\n    tunnel,\n    dsn\n  }) {\n    const headers = {\n      event_id: feedback.event_id,\n      sent_at: (/* @__PURE__ */ new Date()).toISOString(),\n      ...metadata && metadata.sdk && {\n        sdk: {\n          name: metadata.sdk.name,\n          version: metadata.sdk.version\n        }\n      },\n      ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }\n    };\n    const item = createUserFeedbackEnvelopeItem(feedback);\n    return createEnvelope(headers, [item]);\n  }\n  function createUserFeedbackEnvelopeItem(feedback) {\n    const feedbackHeaders = {\n      type: \"user_report\"\n    };\n    return [feedbackHeaders, feedback];\n  }\n\n  // node_modules/@sentry/browser/esm/client.js\n  var BrowserClient = class extends BaseClient {\n    /**\n     * Creates a new Browser SDK instance.\n     *\n     * @param options Configuration options for this SDK.\n     */\n    constructor(options) {\n      const opts = {\n        // We default this to true, as it is the safer scenario\n        parentSpanIsAlwaysRootSpan: true,\n        ...options\n      };\n      const sdkSource = WINDOW4.SENTRY_SDK_SOURCE || getSDKSource();\n      applySdkMetadata(opts, \"browser\", [\"browser\"], sdkSource);\n      super(opts);\n      if (opts.sendClientReports && WINDOW4.document) {\n        WINDOW4.document.addEventListener(\"visibilitychange\", () => {\n          if (WINDOW4.document.visibilityState === \"hidden\") {\n            this._flushOutcomes();\n          }\n        });\n      }\n    }\n    /**\n     * @inheritDoc\n     */\n    eventFromException(exception, hint) {\n      return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);\n    }\n    /**\n     * @inheritDoc\n     */\n    eventFromMessage(message, level = \"info\", hint) {\n      return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);\n    }\n    /**\n     * Sends user feedback to Sentry.\n     *\n     * @deprecated Use `captureFeedback` instead.\n     */\n    captureUserFeedback(feedback) {\n      if (!this._isEnabled()) {\n        DEBUG_BUILD3 && logger.warn(\"SDK not enabled, will not capture user feedback.\");\n        return;\n      }\n      const envelope = createUserFeedbackEnvelope(feedback, {\n        metadata: this.getSdkMetadata(),\n        dsn: this.getDsn(),\n        tunnel: this.getOptions().tunnel\n      });\n      this.sendEnvelope(envelope);\n    }\n    /**\n     * @inheritDoc\n     */\n    _prepareEvent(event, hint, scope) {\n      event.platform = event.platform || \"javascript\";\n      return super._prepareEvent(event, hint, scope);\n    }\n    /**\n     * Sends client reports as an envelope.\n     */\n    _flushOutcomes() {\n      const outcomes = this._clearOutcomes();\n      if (outcomes.length === 0) {\n        DEBUG_BUILD3 && logger.log(\"No outcomes to send\");\n        return;\n      }\n      if (!this._dsn) {\n        DEBUG_BUILD3 && logger.log(\"No dsn provided, will not send outcomes\");\n        return;\n      }\n      DEBUG_BUILD3 && logger.log(\"Sending outcomes:\", outcomes);\n      const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n      this.sendEnvelope(envelope);\n    }\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/debug-build.js\n  var DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/bindReporter.js\n  var getRating = (value, thresholds) => {\n    if (value > thresholds[1]) {\n      return \"poor\";\n    }\n    if (value > thresholds[0]) {\n      return \"needs-improvement\";\n    }\n    return \"good\";\n  };\n  var bindReporter = (callback, metric, thresholds, reportAllChanges) => {\n    let prevValue;\n    let delta;\n    return (forceReport) => {\n      if (metric.value >= 0) {\n        if (forceReport || reportAllChanges) {\n          delta = metric.value - (prevValue || 0);\n          if (delta || prevValue === void 0) {\n            prevValue = metric.value;\n            metric.delta = delta;\n            metric.rating = getRating(metric.value, thresholds);\n            callback(metric);\n          }\n        }\n      }\n    };\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/types.js\n  var WINDOW5 = GLOBAL_OBJ;\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/generateUniqueID.js\n  var generateUniqueID = () => {\n    return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/getNavigationEntry.js\n  var getNavigationEntry = () => {\n    return WINDOW5.performance && performance.getEntriesByType && performance.getEntriesByType(\"navigation\")[0];\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/getActivationStart.js\n  var getActivationStart = () => {\n    const navEntry = getNavigationEntry();\n    return navEntry && navEntry.activationStart || 0;\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/initMetric.js\n  var initMetric = (name2, value) => {\n    const navEntry = getNavigationEntry();\n    let navigationType = \"navigate\";\n    if (navEntry) {\n      if (WINDOW5.document && WINDOW5.document.prerendering || getActivationStart() > 0) {\n        navigationType = \"prerender\";\n      } else if (WINDOW5.document && WINDOW5.document.wasDiscarded) {\n        navigationType = \"restore\";\n      } else if (navEntry.type) {\n        navigationType = navEntry.type.replace(/_/g, \"-\");\n      }\n    }\n    const entries = [];\n    return {\n      name: name2,\n      value: typeof value === \"undefined\" ? -1 : value,\n      rating: \"good\",\n      // If needed, will be updated when reported. `const` to keep the type from widening to `string`.\n      delta: 0,\n      entries,\n      id: generateUniqueID(),\n      navigationType\n    };\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/observe.js\n  var observe = (type, callback, opts) => {\n    try {\n      if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n        const po2 = new PerformanceObserver((list) => {\n          Promise.resolve().then(() => {\n            callback(list.getEntries());\n          });\n        });\n        po2.observe(\n          Object.assign(\n            {\n              type,\n              buffered: true\n            },\n            opts || {}\n          )\n        );\n        return po2;\n      }\n    } catch (e2) {\n    }\n    return;\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/onHidden.js\n  var onHidden2 = (cb) => {\n    const onHiddenOrPageHide = (event) => {\n      if (event.type === \"pagehide\" || WINDOW5.document && WINDOW5.document.visibilityState === \"hidden\") {\n        cb(event);\n      }\n    };\n    if (WINDOW5.document) {\n      addEventListener(\"visibilitychange\", onHiddenOrPageHide, true);\n      addEventListener(\"pagehide\", onHiddenOrPageHide, true);\n    }\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/runOnce.js\n  var runOnce = (cb) => {\n    let called = false;\n    return (arg) => {\n      if (!called) {\n        cb(arg);\n        called = true;\n      }\n    };\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/getVisibilityWatcher.js\n  var firstHiddenTime = -1;\n  var initHiddenTime = () => {\n    firstHiddenTime = WINDOW5.document.visibilityState === \"hidden\" && !WINDOW5.document.prerendering ? 0 : Infinity;\n  };\n  var onVisibilityUpdate = (event) => {\n    if (WINDOW5.document.visibilityState === \"hidden\" && firstHiddenTime > -1) {\n      firstHiddenTime = event.type === \"visibilitychange\" ? event.timeStamp : 0;\n      removeEventListener(\"visibilitychange\", onVisibilityUpdate, true);\n      removeEventListener(\"prerenderingchange\", onVisibilityUpdate, true);\n    }\n  };\n  var addChangeListeners = () => {\n    addEventListener(\"visibilitychange\", onVisibilityUpdate, true);\n    addEventListener(\"prerenderingchange\", onVisibilityUpdate, true);\n  };\n  var getVisibilityWatcher = () => {\n    if (WINDOW5.document && firstHiddenTime < 0) {\n      initHiddenTime();\n      addChangeListeners();\n    }\n    return {\n      get firstHiddenTime() {\n        return firstHiddenTime;\n      }\n    };\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/whenActivated.js\n  var whenActivated = (callback) => {\n    if (WINDOW5.document && WINDOW5.document.prerendering) {\n      addEventListener(\"prerenderingchange\", () => callback(), true);\n    } else {\n      callback();\n    }\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/onFCP.js\n  var FCPThresholds = [1800, 3e3];\n  var onFCP = (onReport, opts = {}) => {\n    whenActivated(() => {\n      const visibilityWatcher = getVisibilityWatcher();\n      const metric = initMetric(\"FCP\");\n      let report;\n      const handleEntries = (entries) => {\n        entries.forEach((entry) => {\n          if (entry.name === \"first-contentful-paint\") {\n            po2.disconnect();\n            if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n              metric.value = Math.max(entry.startTime - getActivationStart(), 0);\n              metric.entries.push(entry);\n              report(true);\n            }\n          }\n        });\n      };\n      const po2 = observe(\"paint\", handleEntries);\n      if (po2) {\n        report = bindReporter(onReport, metric, FCPThresholds, opts.reportAllChanges);\n      }\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/getCLS.js\n  var CLSThresholds = [0.1, 0.25];\n  var onCLS = (onReport, opts = {}) => {\n    onFCP(\n      runOnce(() => {\n        const metric = initMetric(\"CLS\", 0);\n        let report;\n        let sessionValue = 0;\n        let sessionEntries = [];\n        const handleEntries = (entries) => {\n          entries.forEach((entry) => {\n            if (!entry.hadRecentInput) {\n              const firstSessionEntry = sessionEntries[0];\n              const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n              if (sessionValue && firstSessionEntry && lastSessionEntry && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {\n                sessionValue += entry.value;\n                sessionEntries.push(entry);\n              } else {\n                sessionValue = entry.value;\n                sessionEntries = [entry];\n              }\n            }\n          });\n          if (sessionValue > metric.value) {\n            metric.value = sessionValue;\n            metric.entries = sessionEntries;\n            report();\n          }\n        };\n        const po2 = observe(\"layout-shift\", handleEntries);\n        if (po2) {\n          report = bindReporter(onReport, metric, CLSThresholds, opts.reportAllChanges);\n          onHidden2(() => {\n            handleEntries(po2.takeRecords());\n            report(true);\n          });\n          setTimeout(report, 0);\n        }\n      })\n    );\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/getFID.js\n  var FIDThresholds = [100, 300];\n  var onFID = (onReport, opts = {}) => {\n    whenActivated(() => {\n      const visibilityWatcher = getVisibilityWatcher();\n      const metric = initMetric(\"FID\");\n      let report;\n      const handleEntry = (entry) => {\n        if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n          metric.value = entry.processingStart - entry.startTime;\n          metric.entries.push(entry);\n          report(true);\n        }\n      };\n      const handleEntries = (entries) => {\n        entries.forEach(handleEntry);\n      };\n      const po2 = observe(\"first-input\", handleEntries);\n      report = bindReporter(onReport, metric, FIDThresholds, opts.reportAllChanges);\n      if (po2) {\n        onHidden2(\n          runOnce(() => {\n            handleEntries(po2.takeRecords());\n            po2.disconnect();\n          })\n        );\n      }\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/lib/polyfills/interactionCountPolyfill.js\n  var interactionCountEstimate = 0;\n  var minKnownInteractionId = Infinity;\n  var maxKnownInteractionId = 0;\n  var updateEstimate = (entries) => {\n    entries.forEach((e2) => {\n      if (e2.interactionId) {\n        minKnownInteractionId = Math.min(minKnownInteractionId, e2.interactionId);\n        maxKnownInteractionId = Math.max(maxKnownInteractionId, e2.interactionId);\n        interactionCountEstimate = maxKnownInteractionId ? (maxKnownInteractionId - minKnownInteractionId) / 7 + 1 : 0;\n      }\n    });\n  };\n  var po;\n  var getInteractionCount = () => {\n    return po ? interactionCountEstimate : performance.interactionCount || 0;\n  };\n  var initInteractionCountPolyfill = () => {\n    if (\"interactionCount\" in performance || po)\n      return;\n    po = observe(\"event\", updateEstimate, {\n      type: \"event\",\n      buffered: true,\n      durationThreshold: 0\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/getINP.js\n  var INPThresholds = [200, 500];\n  var prevInteractionCount = 0;\n  var getInteractionCountForNavigation = () => {\n    return getInteractionCount() - prevInteractionCount;\n  };\n  var MAX_INTERACTIONS_TO_CONSIDER = 10;\n  var longestInteractionList = [];\n  var longestInteractionMap = {};\n  var processEntry = (entry) => {\n    const minLongestInteraction = longestInteractionList[longestInteractionList.length - 1];\n    const existingInteraction = longestInteractionMap[entry.interactionId];\n    if (existingInteraction || longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER || minLongestInteraction && entry.duration > minLongestInteraction.latency) {\n      if (existingInteraction) {\n        existingInteraction.entries.push(entry);\n        existingInteraction.latency = Math.max(existingInteraction.latency, entry.duration);\n      } else {\n        const interaction = {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          id: entry.interactionId,\n          latency: entry.duration,\n          entries: [entry]\n        };\n        longestInteractionMap[interaction.id] = interaction;\n        longestInteractionList.push(interaction);\n      }\n      longestInteractionList.sort((a, b) => b.latency - a.latency);\n      longestInteractionList.splice(MAX_INTERACTIONS_TO_CONSIDER).forEach((i) => {\n        delete longestInteractionMap[i.id];\n      });\n    }\n  };\n  var estimateP98LongestInteraction = () => {\n    const candidateInteractionIndex = Math.min(\n      longestInteractionList.length - 1,\n      Math.floor(getInteractionCountForNavigation() / 50)\n    );\n    return longestInteractionList[candidateInteractionIndex];\n  };\n  var onINP = (onReport, opts = {}) => {\n    whenActivated(() => {\n      initInteractionCountPolyfill();\n      const metric = initMetric(\"INP\");\n      let report;\n      const handleEntries = (entries) => {\n        entries.forEach((entry) => {\n          if (entry.interactionId) {\n            processEntry(entry);\n          }\n          if (entry.entryType === \"first-input\") {\n            const noMatchingEntry = !longestInteractionList.some((interaction) => {\n              return interaction.entries.some((prevEntry) => {\n                return entry.duration === prevEntry.duration && entry.startTime === prevEntry.startTime;\n              });\n            });\n            if (noMatchingEntry) {\n              processEntry(entry);\n            }\n          }\n        });\n        const inp = estimateP98LongestInteraction();\n        if (inp && inp.latency !== metric.value) {\n          metric.value = inp.latency;\n          metric.entries = inp.entries;\n          report();\n        }\n      };\n      const po2 = observe(\"event\", handleEntries, {\n        // Event Timing entries have their durations rounded to the nearest 8ms,\n        // so a duration of 40ms would be any event that spans 2.5 or more frames\n        // at 60Hz. This threshold is chosen to strike a balance between usefulness\n        // and performance. Running this callback for any interaction that spans\n        // just one or two frames is likely not worth the insight that could be\n        // gained.\n        durationThreshold: opts.durationThreshold != null ? opts.durationThreshold : 40\n      });\n      report = bindReporter(onReport, metric, INPThresholds, opts.reportAllChanges);\n      if (po2) {\n        if (\"PerformanceEventTiming\" in WINDOW5 && \"interactionId\" in PerformanceEventTiming.prototype) {\n          po2.observe({ type: \"first-input\", buffered: true });\n        }\n        onHidden2(() => {\n          handleEntries(po2.takeRecords());\n          if (metric.value < 0 && getInteractionCountForNavigation() > 0) {\n            metric.value = 0;\n            metric.entries = [];\n          }\n          report(true);\n        });\n      }\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/getLCP.js\n  var LCPThresholds = [2500, 4e3];\n  var reportedMetricIDs = {};\n  var onLCP = (onReport, opts = {}) => {\n    whenActivated(() => {\n      const visibilityWatcher = getVisibilityWatcher();\n      const metric = initMetric(\"LCP\");\n      let report;\n      const handleEntries = (entries) => {\n        const lastEntry = entries[entries.length - 1];\n        if (lastEntry) {\n          if (lastEntry.startTime < visibilityWatcher.firstHiddenTime) {\n            metric.value = Math.max(lastEntry.startTime - getActivationStart(), 0);\n            metric.entries = [lastEntry];\n            report();\n          }\n        }\n      };\n      const po2 = observe(\"largest-contentful-paint\", handleEntries);\n      if (po2) {\n        report = bindReporter(onReport, metric, LCPThresholds, opts.reportAllChanges);\n        const stopListening = runOnce(() => {\n          if (!reportedMetricIDs[metric.id]) {\n            handleEntries(po2.takeRecords());\n            po2.disconnect();\n            reportedMetricIDs[metric.id] = true;\n            report(true);\n          }\n        });\n        [\"keydown\", \"click\"].forEach((type) => {\n          if (WINDOW5.document) {\n            addEventListener(type, () => setTimeout(stopListening, 0), true);\n          }\n        });\n        onHidden2(stopListening);\n      }\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/web-vitals/onTTFB.js\n  var TTFBThresholds = [800, 1800];\n  var whenReady = (callback) => {\n    if (WINDOW5.document && WINDOW5.document.prerendering) {\n      whenActivated(() => whenReady(callback));\n    } else if (WINDOW5.document && WINDOW5.document.readyState !== \"complete\") {\n      addEventListener(\"load\", () => whenReady(callback), true);\n    } else {\n      setTimeout(callback, 0);\n    }\n  };\n  var onTTFB = (onReport, opts = {}) => {\n    const metric = initMetric(\"TTFB\");\n    const report = bindReporter(onReport, metric, TTFBThresholds, opts.reportAllChanges);\n    whenReady(() => {\n      const navEntry = getNavigationEntry();\n      if (navEntry) {\n        const responseStart = navEntry.responseStart;\n        if (responseStart <= 0 || responseStart > performance.now())\n          return;\n        metric.value = Math.max(responseStart - getActivationStart(), 0);\n        metric.entries = [navEntry];\n        report(true);\n      }\n    });\n  };\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/instrument.js\n  var handlers2 = {};\n  var instrumented2 = {};\n  var _previousCls;\n  var _previousFid;\n  var _previousLcp;\n  var _previousTtfb;\n  var _previousInp;\n  function addClsInstrumentationHandler(callback, stopOnCallback = false) {\n    return addMetricObserver(\"cls\", callback, instrumentCls, _previousCls, stopOnCallback);\n  }\n  function addLcpInstrumentationHandler(callback, stopOnCallback = false) {\n    return addMetricObserver(\"lcp\", callback, instrumentLcp, _previousLcp, stopOnCallback);\n  }\n  function addFidInstrumentationHandler(callback) {\n    return addMetricObserver(\"fid\", callback, instrumentFid, _previousFid);\n  }\n  function addTtfbInstrumentationHandler(callback) {\n    return addMetricObserver(\"ttfb\", callback, instrumentTtfb, _previousTtfb);\n  }\n  function addInpInstrumentationHandler(callback) {\n    return addMetricObserver(\"inp\", callback, instrumentInp, _previousInp);\n  }\n  function addPerformanceInstrumentationHandler(type, callback) {\n    addHandler2(type, callback);\n    if (!instrumented2[type]) {\n      instrumentPerformanceObserver(type);\n      instrumented2[type] = true;\n    }\n    return getCleanupCallback(type, callback);\n  }\n  function triggerHandlers2(type, data) {\n    const typeHandlers = handlers2[type];\n    if (!typeHandlers || !typeHandlers.length) {\n      return;\n    }\n    for (const handler of typeHandlers) {\n      try {\n        handler(data);\n      } catch (e2) {\n        DEBUG_BUILD4 && logger.error(\n          `Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`,\n          e2\n        );\n      }\n    }\n  }\n  function instrumentCls() {\n    return onCLS(\n      (metric) => {\n        triggerHandlers2(\"cls\", {\n          metric\n        });\n        _previousCls = metric;\n      },\n      // We want the callback to be called whenever the CLS value updates.\n      // By default, the callback is only called when the tab goes to the background.\n      { reportAllChanges: true }\n    );\n  }\n  function instrumentFid() {\n    return onFID((metric) => {\n      triggerHandlers2(\"fid\", {\n        metric\n      });\n      _previousFid = metric;\n    });\n  }\n  function instrumentLcp() {\n    return onLCP(\n      (metric) => {\n        triggerHandlers2(\"lcp\", {\n          metric\n        });\n        _previousLcp = metric;\n      },\n      // We want the callback to be called whenever the LCP value updates.\n      // By default, the callback is only called when the tab goes to the background.\n      { reportAllChanges: true }\n    );\n  }\n  function instrumentTtfb() {\n    return onTTFB((metric) => {\n      triggerHandlers2(\"ttfb\", {\n        metric\n      });\n      _previousTtfb = metric;\n    });\n  }\n  function instrumentInp() {\n    return onINP((metric) => {\n      triggerHandlers2(\"inp\", {\n        metric\n      });\n      _previousInp = metric;\n    });\n  }\n  function addMetricObserver(type, callback, instrumentFn, previousValue, stopOnCallback = false) {\n    addHandler2(type, callback);\n    let stopListening;\n    if (!instrumented2[type]) {\n      stopListening = instrumentFn();\n      instrumented2[type] = true;\n    }\n    if (previousValue) {\n      callback({ metric: previousValue });\n    }\n    return getCleanupCallback(type, callback, stopOnCallback ? stopListening : void 0);\n  }\n  function instrumentPerformanceObserver(type) {\n    const options = {};\n    if (type === \"event\") {\n      options.durationThreshold = 0;\n    }\n    observe(\n      type,\n      (entries) => {\n        triggerHandlers2(type, { entries });\n      },\n      options\n    );\n  }\n  function addHandler2(type, handler) {\n    handlers2[type] = handlers2[type] || [];\n    handlers2[type].push(handler);\n  }\n  function getCleanupCallback(type, callback, stopListening) {\n    return () => {\n      if (stopListening) {\n        stopListening();\n      }\n      const typeHandlers = handlers2[type];\n      if (!typeHandlers) {\n        return;\n      }\n      const index = typeHandlers.indexOf(callback);\n      if (index !== -1) {\n        typeHandlers.splice(index, 1);\n      }\n    };\n  }\n  function isPerformanceEventTiming(entry) {\n    return \"duration\" in entry;\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/utils.js\n  function isMeasurementValue(value) {\n    return typeof value === \"number\" && isFinite(value);\n  }\n  function startAndEndSpan(parentSpan, startTimeInSeconds, endTime, { ...ctx }) {\n    const parentStartTime = spanToJSON(parentSpan).start_timestamp;\n    if (parentStartTime && parentStartTime > startTimeInSeconds) {\n      if (typeof parentSpan.updateStartTime === \"function\") {\n        parentSpan.updateStartTime(startTimeInSeconds);\n      }\n    }\n    return withActiveSpan(parentSpan, () => {\n      const span = startInactiveSpan({\n        startTime: startTimeInSeconds,\n        ...ctx\n      });\n      if (span) {\n        span.end(endTime);\n      }\n      return span;\n    });\n  }\n  function getBrowserPerformanceAPI() {\n    return WINDOW5 && WINDOW5.addEventListener && WINDOW5.performance;\n  }\n  function msToSec(time) {\n    return time / 1e3;\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/browserMetrics.js\n  var MAX_INT_AS_BYTES = 2147483647;\n  var _performanceCursor = 0;\n  var _measurements = {};\n  var _lcpEntry;\n  var _clsEntry;\n  function startTrackingWebVitals() {\n    const performance2 = getBrowserPerformanceAPI();\n    if (performance2 && browserPerformanceTimeOrigin) {\n      if (performance2.mark) {\n        WINDOW5.performance.mark(\"sentry-tracing-init\");\n      }\n      const fidCallback = _trackFID();\n      const clsCallback = _trackCLS();\n      const lcpCallback = _trackLCP();\n      const ttfbCallback = _trackTtfb();\n      return () => {\n        fidCallback();\n        clsCallback();\n        lcpCallback();\n        ttfbCallback();\n      };\n    }\n    return () => void 0;\n  }\n  function startTrackingLongTasks() {\n    addPerformanceInstrumentationHandler(\"longtask\", ({ entries }) => {\n      for (const entry of entries) {\n        if (!getActiveSpan()) {\n          return;\n        }\n        const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);\n        const duration = msToSec(entry.duration);\n        const span = startInactiveSpan({\n          name: \"Main UI thread blocked\",\n          op: \"ui.long-task\",\n          startTime,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n          }\n        });\n        if (span) {\n          span.end(startTime + duration);\n        }\n      }\n    });\n  }\n  function startTrackingInteractions() {\n    addPerformanceInstrumentationHandler(\"event\", ({ entries }) => {\n      for (const entry of entries) {\n        if (!getActiveSpan()) {\n          return;\n        }\n        if (entry.name === \"click\") {\n          const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);\n          const duration = msToSec(entry.duration);\n          const spanOptions = {\n            name: htmlTreeAsString(entry.target),\n            op: `ui.interaction.${entry.name}`,\n            startTime,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n            }\n          };\n          const componentName = getComponentName(entry.target);\n          if (componentName) {\n            spanOptions.attributes[\"ui.component_name\"] = componentName;\n          }\n          const span = startInactiveSpan(spanOptions);\n          if (span) {\n            span.end(startTime + duration);\n          }\n        }\n      }\n    });\n  }\n  function _trackCLS() {\n    return addClsInstrumentationHandler(({ metric }) => {\n      const entry = metric.entries[metric.entries.length - 1];\n      if (!entry) {\n        return;\n      }\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding CLS\");\n      _measurements[\"cls\"] = { value: metric.value, unit: \"\" };\n      _clsEntry = entry;\n    }, true);\n  }\n  function _trackLCP() {\n    return addLcpInstrumentationHandler(({ metric }) => {\n      const entry = metric.entries[metric.entries.length - 1];\n      if (!entry) {\n        return;\n      }\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding LCP\");\n      _measurements[\"lcp\"] = { value: metric.value, unit: \"millisecond\" };\n      _lcpEntry = entry;\n    }, true);\n  }\n  function _trackFID() {\n    return addFidInstrumentationHandler(({ metric }) => {\n      const entry = metric.entries[metric.entries.length - 1];\n      if (!entry) {\n        return;\n      }\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n      const startTime = msToSec(entry.startTime);\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding FID\");\n      _measurements[\"fid\"] = { value: metric.value, unit: \"millisecond\" };\n      _measurements[\"mark.fid\"] = { value: timeOrigin + startTime, unit: \"second\" };\n    });\n  }\n  function _trackTtfb() {\n    return addTtfbInstrumentationHandler(({ metric }) => {\n      const entry = metric.entries[metric.entries.length - 1];\n      if (!entry) {\n        return;\n      }\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding TTFB\");\n      _measurements[\"ttfb\"] = { value: metric.value, unit: \"millisecond\" };\n    });\n  }\n  function addPerformanceEntries(span) {\n    const performance2 = getBrowserPerformanceAPI();\n    if (!performance2 || !WINDOW5.performance.getEntries || !browserPerformanceTimeOrigin) {\n      return;\n    }\n    DEBUG_BUILD4 && logger.log(\"[Tracing] Adding & adjusting spans using Performance API\");\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    const performanceEntries = performance2.getEntries();\n    const { op, start_timestamp: transactionStartTime } = spanToJSON(span);\n    performanceEntries.slice(_performanceCursor).forEach((entry) => {\n      const startTime = msToSec(entry.startTime);\n      const duration = msToSec(entry.duration);\n      if (op === \"navigation\" && transactionStartTime && timeOrigin + startTime < transactionStartTime) {\n        return;\n      }\n      switch (entry.entryType) {\n        case \"navigation\": {\n          _addNavigationSpans(span, entry, timeOrigin);\n          break;\n        }\n        case \"mark\":\n        case \"paint\":\n        case \"measure\": {\n          _addMeasureSpans(span, entry, startTime, duration, timeOrigin);\n          const firstHidden = getVisibilityWatcher();\n          const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n          if (entry.name === \"first-paint\" && shouldRecord) {\n            DEBUG_BUILD4 && logger.log(\"[Measurements] Adding FP\");\n            _measurements[\"fp\"] = { value: entry.startTime, unit: \"millisecond\" };\n          }\n          if (entry.name === \"first-contentful-paint\" && shouldRecord) {\n            DEBUG_BUILD4 && logger.log(\"[Measurements] Adding FCP\");\n            _measurements[\"fcp\"] = { value: entry.startTime, unit: \"millisecond\" };\n          }\n          break;\n        }\n        case \"resource\": {\n          _addResourceSpans(span, entry, entry.name, startTime, duration, timeOrigin);\n          break;\n        }\n      }\n    });\n    _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n    _trackNavigator(span);\n    if (op === \"pageload\") {\n      _addTtfbRequestTimeToMeasurements(_measurements);\n      [\"fcp\", \"fp\", \"lcp\"].forEach((name2) => {\n        const measurement = _measurements[name2];\n        if (!measurement || !transactionStartTime || timeOrigin >= transactionStartTime) {\n          return;\n        }\n        const oldValue = measurement.value;\n        const measurementTimestamp = timeOrigin + msToSec(oldValue);\n        const normalizedValue = Math.abs((measurementTimestamp - transactionStartTime) * 1e3);\n        const delta = normalizedValue - oldValue;\n        DEBUG_BUILD4 && logger.log(`[Measurements] Normalized ${name2} from ${oldValue} to ${normalizedValue} (${delta})`);\n        measurement.value = normalizedValue;\n      });\n      const fidMark = _measurements[\"mark.fid\"];\n      if (fidMark && _measurements[\"fid\"]) {\n        startAndEndSpan(span, fidMark.value, fidMark.value + msToSec(_measurements[\"fid\"].value), {\n          name: \"first input delay\",\n          op: \"ui.action\",\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n          }\n        });\n        delete _measurements[\"mark.fid\"];\n      }\n      if (!(\"fcp\" in _measurements)) {\n        delete _measurements.cls;\n      }\n      Object.entries(_measurements).forEach(([measurementName, measurement]) => {\n        setMeasurement(measurementName, measurement.value, measurement.unit);\n      });\n      _tagMetricInfo(span);\n    }\n    _lcpEntry = void 0;\n    _clsEntry = void 0;\n    _measurements = {};\n  }\n  function _addMeasureSpans(span, entry, startTime, duration, timeOrigin) {\n    const measureStartTimestamp = timeOrigin + startTime;\n    const measureEndTimestamp = measureStartTimestamp + duration;\n    startAndEndSpan(span, measureStartTimestamp, measureEndTimestamp, {\n      name: entry.name,\n      op: entry.entryType,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.resource.browser.metrics\"\n      }\n    });\n    return measureStartTimestamp;\n  }\n  function _addNavigationSpans(span, entry, timeOrigin) {\n    [\"unloadEvent\", \"redirect\", \"domContentLoadedEvent\", \"loadEvent\", \"connect\"].forEach((event) => {\n      _addPerformanceNavigationTiming(span, entry, event, timeOrigin);\n    });\n    _addPerformanceNavigationTiming(span, entry, \"secureConnection\", timeOrigin, \"TLS/SSL\", \"connectEnd\");\n    _addPerformanceNavigationTiming(span, entry, \"fetch\", timeOrigin, \"cache\", \"domainLookupStart\");\n    _addPerformanceNavigationTiming(span, entry, \"domainLookup\", timeOrigin, \"DNS\");\n    _addRequest(span, entry, timeOrigin);\n  }\n  function _addPerformanceNavigationTiming(span, entry, event, timeOrigin, name2, eventEnd) {\n    const end2 = eventEnd ? entry[eventEnd] : entry[`${event}End`];\n    const start2 = entry[`${event}Start`];\n    if (!start2 || !end2) {\n      return;\n    }\n    startAndEndSpan(span, timeOrigin + msToSec(start2), timeOrigin + msToSec(end2), {\n      op: \"browser\",\n      name: name2 || event,\n      attributes: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n      }\n    });\n  }\n  function _addRequest(span, entry, timeOrigin) {\n    if (entry.responseEnd) {\n      startAndEndSpan(\n        span,\n        timeOrigin + msToSec(entry.requestStart),\n        timeOrigin + msToSec(entry.responseEnd),\n        {\n          op: \"browser\",\n          name: \"request\",\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n          }\n        }\n      );\n      startAndEndSpan(\n        span,\n        timeOrigin + msToSec(entry.responseStart),\n        timeOrigin + msToSec(entry.responseEnd),\n        {\n          op: \"browser\",\n          name: \"response\",\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.ui.browser.metrics\"\n          }\n        }\n      );\n    }\n  }\n  function _addResourceSpans(span, entry, resourceUrl, startTime, duration, timeOrigin) {\n    if (entry.initiatorType === \"xmlhttprequest\" || entry.initiatorType === \"fetch\") {\n      return;\n    }\n    const parsedUrl = parseUrl(resourceUrl);\n    const attributes = {\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.resource.browser.metrics\"\n    };\n    setResourceEntrySizeData(attributes, entry, \"transferSize\", \"http.response_transfer_size\");\n    setResourceEntrySizeData(attributes, entry, \"encodedBodySize\", \"http.response_content_length\");\n    setResourceEntrySizeData(attributes, entry, \"decodedBodySize\", \"http.decoded_response_content_length\");\n    if (\"renderBlockingStatus\" in entry) {\n      attributes[\"resource.render_blocking_status\"] = entry.renderBlockingStatus;\n    }\n    if (parsedUrl.protocol) {\n      attributes[\"url.scheme\"] = parsedUrl.protocol.split(\":\").pop();\n    }\n    if (parsedUrl.host) {\n      attributes[\"server.address\"] = parsedUrl.host;\n    }\n    attributes[\"url.same_origin\"] = resourceUrl.includes(WINDOW5.location.origin);\n    const startTimestamp = timeOrigin + startTime;\n    const endTimestamp = startTimestamp + duration;\n    startAndEndSpan(span, startTimestamp, endTimestamp, {\n      name: resourceUrl.replace(WINDOW5.location.origin, \"\"),\n      op: entry.initiatorType ? `resource.${entry.initiatorType}` : \"resource.other\",\n      attributes\n    });\n  }\n  function _trackNavigator(span) {\n    const navigator2 = WINDOW5.navigator;\n    if (!navigator2) {\n      return;\n    }\n    const connection = navigator2.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        span.setAttribute(\"effectiveConnectionType\", connection.effectiveType);\n      }\n      if (connection.type) {\n        span.setAttribute(\"connectionType\", connection.type);\n      }\n      if (isMeasurementValue(connection.rtt)) {\n        _measurements[\"connection.rtt\"] = { value: connection.rtt, unit: \"millisecond\" };\n      }\n    }\n    if (isMeasurementValue(navigator2.deviceMemory)) {\n      span.setAttribute(\"deviceMemory\", `${navigator2.deviceMemory} GB`);\n    }\n    if (isMeasurementValue(navigator2.hardwareConcurrency)) {\n      span.setAttribute(\"hardwareConcurrency\", String(navigator2.hardwareConcurrency));\n    }\n  }\n  function _tagMetricInfo(span) {\n    if (_lcpEntry) {\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding LCP Data\");\n      if (_lcpEntry.element) {\n        span.setAttribute(\"lcp.element\", htmlTreeAsString(_lcpEntry.element));\n      }\n      if (_lcpEntry.id) {\n        span.setAttribute(\"lcp.id\", _lcpEntry.id);\n      }\n      if (_lcpEntry.url) {\n        span.setAttribute(\"lcp.url\", _lcpEntry.url.trim().slice(0, 200));\n      }\n      span.setAttribute(\"lcp.size\", _lcpEntry.size);\n    }\n    if (_clsEntry && _clsEntry.sources) {\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding CLS Data\");\n      _clsEntry.sources.forEach(\n        (source, index) => span.setAttribute(`cls.source.${index + 1}`, htmlTreeAsString(source.node))\n      );\n    }\n  }\n  function setResourceEntrySizeData(attributes, entry, key, dataKey) {\n    const entryVal = entry[key];\n    if (entryVal != null && entryVal < MAX_INT_AS_BYTES) {\n      attributes[dataKey] = entryVal;\n    }\n  }\n  function _addTtfbRequestTimeToMeasurements(_measurements2) {\n    const navEntry = getNavigationEntry();\n    if (!navEntry) {\n      return;\n    }\n    const { responseStart, requestStart } = navEntry;\n    if (requestStart <= responseStart) {\n      DEBUG_BUILD4 && logger.log(\"[Measurements] Adding TTFB Request Time\");\n      _measurements2[\"ttfb.requestTime\"] = {\n        value: responseStart - requestStart,\n        unit: \"millisecond\"\n      };\n    }\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/instrument/dom.js\n  var DEBOUNCE_DURATION = 1e3;\n  var debounceTimerID;\n  var lastCapturedEventType;\n  var lastCapturedEventTargetId;\n  function addClickKeypressInstrumentationHandler(handler) {\n    const type = \"dom\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentDOM);\n  }\n  function instrumentDOM() {\n    if (!WINDOW5.document) {\n      return;\n    }\n    const triggerDOMHandler = triggerHandlers.bind(null, \"dom\");\n    const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n    WINDOW5.document.addEventListener(\"click\", globalDOMEventHandler, false);\n    WINDOW5.document.addEventListener(\"keypress\", globalDOMEventHandler, false);\n    [\"EventTarget\", \"Node\"].forEach((target) => {\n      const proto = WINDOW5[target] && WINDOW5[target].prototype;\n      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty(\"addEventListener\")) {\n        return;\n      }\n      fill(proto, \"addEventListener\", function(originalAddEventListener) {\n        return function(type, listener, options) {\n          if (type === \"click\" || type == \"keypress\") {\n            try {\n              const el = this;\n              const handlers4 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers4[type] = handlers4[type] || { refCount: 0 };\n              if (!handlerForType.handler) {\n                const handler = makeDOMEventHandler(triggerDOMHandler);\n                handlerForType.handler = handler;\n                originalAddEventListener.call(this, type, handler, options);\n              }\n              handlerForType.refCount++;\n            } catch (e2) {\n            }\n          }\n          return originalAddEventListener.call(this, type, listener, options);\n        };\n      });\n      fill(\n        proto,\n        \"removeEventListener\",\n        function(originalRemoveEventListener) {\n          return function(type, listener, options) {\n            if (type === \"click\" || type == \"keypress\") {\n              try {\n                const el = this;\n                const handlers4 = el.__sentry_instrumentation_handlers__ || {};\n                const handlerForType = handlers4[type];\n                if (handlerForType) {\n                  handlerForType.refCount--;\n                  if (handlerForType.refCount <= 0) {\n                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                    handlerForType.handler = void 0;\n                    delete handlers4[type];\n                  }\n                  if (Object.keys(handlers4).length === 0) {\n                    delete el.__sentry_instrumentation_handlers__;\n                  }\n                }\n              } catch (e2) {\n              }\n            }\n            return originalRemoveEventListener.call(this, type, listener, options);\n          };\n        }\n      );\n    });\n  }\n  function isSimilarToLastCapturedEvent(event) {\n    if (event.type !== lastCapturedEventType) {\n      return false;\n    }\n    try {\n      if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {\n        return false;\n      }\n    } catch (e2) {\n    }\n    return true;\n  }\n  function shouldSkipDOMEvent(eventType, target) {\n    if (eventType !== \"keypress\") {\n      return false;\n    }\n    if (!target || !target.tagName) {\n      return true;\n    }\n    if (target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\" || target.isContentEditable) {\n      return false;\n    }\n    return true;\n  }\n  function makeDOMEventHandler(handler, globalListener = false) {\n    return (event) => {\n      if (!event || event[\"_sentryCaptured\"]) {\n        return;\n      }\n      const target = getEventTarget(event);\n      if (shouldSkipDOMEvent(event.type, target)) {\n        return;\n      }\n      addNonEnumerableProperty(event, \"_sentryCaptured\", true);\n      if (target && !target._sentryId) {\n        addNonEnumerableProperty(target, \"_sentryId\", uuid4());\n      }\n      const name2 = event.type === \"keypress\" ? \"input\" : event.type;\n      if (!isSimilarToLastCapturedEvent(event)) {\n        const handlerData = { event, name: name2, global: globalListener };\n        handler(handlerData);\n        lastCapturedEventType = event.type;\n        lastCapturedEventTargetId = target ? target._sentryId : void 0;\n      }\n      clearTimeout(debounceTimerID);\n      debounceTimerID = WINDOW5.setTimeout(() => {\n        lastCapturedEventTargetId = void 0;\n        lastCapturedEventType = void 0;\n      }, DEBOUNCE_DURATION);\n    };\n  }\n  function getEventTarget(event) {\n    try {\n      return event.target;\n    } catch (e2) {\n      return null;\n    }\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/instrument/history.js\n  var lastHref;\n  function addHistoryInstrumentationHandler(handler) {\n    const type = \"history\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentHistory);\n  }\n  function instrumentHistory() {\n    if (!supportsHistory()) {\n      return;\n    }\n    const oldOnPopState = WINDOW5.onpopstate;\n    WINDOW5.onpopstate = function(...args) {\n      const to = WINDOW5.location.href;\n      const from = lastHref;\n      lastHref = to;\n      const handlerData = { from, to };\n      triggerHandlers(\"history\", handlerData);\n      if (oldOnPopState) {\n        try {\n          return oldOnPopState.apply(this, args);\n        } catch (_oO) {\n        }\n      }\n    };\n    function historyReplacementFunction(originalHistoryFunction) {\n      return function(...args) {\n        const url = args.length > 2 ? args[2] : void 0;\n        if (url) {\n          const from = lastHref;\n          const to = String(url);\n          lastHref = to;\n          const handlerData = { from, to };\n          triggerHandlers(\"history\", handlerData);\n        }\n        return originalHistoryFunction.apply(this, args);\n      };\n    }\n    fill(WINDOW5.history, \"pushState\", historyReplacementFunction);\n    fill(WINDOW5.history, \"replaceState\", historyReplacementFunction);\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/getNativeImplementation.js\n  var cachedImplementations = {};\n  function getNativeImplementation(name2) {\n    const cached = cachedImplementations[name2];\n    if (cached) {\n      return cached;\n    }\n    let impl = WINDOW5[name2];\n    if (isNativeFunction(impl)) {\n      return cachedImplementations[name2] = impl.bind(WINDOW5);\n    }\n    const document2 = WINDOW5.document;\n    if (document2 && typeof document2.createElement === \"function\") {\n      try {\n        const sandbox = document2.createElement(\"iframe\");\n        sandbox.hidden = true;\n        document2.head.appendChild(sandbox);\n        const contentWindow = sandbox.contentWindow;\n        if (contentWindow && contentWindow[name2]) {\n          impl = contentWindow[name2];\n        }\n        document2.head.removeChild(sandbox);\n      } catch (e2) {\n        DEBUG_BUILD4 && logger.warn(`Could not create sandbox iframe for ${name2} check, bailing to window.${name2}: `, e2);\n      }\n    }\n    if (!impl) {\n      return impl;\n    }\n    return cachedImplementations[name2] = impl.bind(WINDOW5);\n  }\n  function clearCachedImplementation(name2) {\n    cachedImplementations[name2] = void 0;\n  }\n  function setTimeout2(...rest) {\n    return getNativeImplementation(\"setTimeout\")(...rest);\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/instrument/xhr.js\n  var SENTRY_XHR_DATA_KEY = \"__sentry_xhr_v3__\";\n  function addXhrInstrumentationHandler(handler) {\n    const type = \"xhr\";\n    addHandler(type, handler);\n    maybeInstrument(type, instrumentXHR);\n  }\n  function instrumentXHR() {\n    if (!WINDOW5.XMLHttpRequest) {\n      return;\n    }\n    const xhrproto = XMLHttpRequest.prototype;\n    fill(xhrproto, \"open\", function(originalOpen) {\n      return function(...args) {\n        const startTimestamp = timestampInSeconds() * 1e3;\n        const method = isString(args[0]) ? args[0].toUpperCase() : void 0;\n        const url = parseUrl2(args[1]);\n        if (!method || !url) {\n          return originalOpen.apply(this, args);\n        }\n        this[SENTRY_XHR_DATA_KEY] = {\n          method,\n          url,\n          request_headers: {}\n        };\n        if (method === \"POST\" && url.match(/sentry_key/)) {\n          this.__sentry_own_request__ = true;\n        }\n        const onreadystatechangeHandler = () => {\n          const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n          if (!xhrInfo) {\n            return;\n          }\n          if (this.readyState === 4) {\n            try {\n              xhrInfo.status_code = this.status;\n            } catch (e2) {\n            }\n            const handlerData = {\n              endTimestamp: timestampInSeconds() * 1e3,\n              startTimestamp,\n              xhr: this\n            };\n            triggerHandlers(\"xhr\", handlerData);\n          }\n        };\n        if (\"onreadystatechange\" in this && typeof this.onreadystatechange === \"function\") {\n          fill(this, \"onreadystatechange\", function(original) {\n            return function(...readyStateArgs) {\n              onreadystatechangeHandler();\n              return original.apply(this, readyStateArgs);\n            };\n          });\n        } else {\n          this.addEventListener(\"readystatechange\", onreadystatechangeHandler);\n        }\n        fill(this, \"setRequestHeader\", function(original) {\n          return function(...setRequestHeaderArgs) {\n            const [header, value] = setRequestHeaderArgs;\n            const xhrInfo = this[SENTRY_XHR_DATA_KEY];\n            if (xhrInfo && isString(header) && isString(value)) {\n              xhrInfo.request_headers[header.toLowerCase()] = value;\n            }\n            return original.apply(this, setRequestHeaderArgs);\n          };\n        });\n        return originalOpen.apply(this, args);\n      };\n    });\n    fill(xhrproto, \"send\", function(originalSend) {\n      return function(...args) {\n        const sentryXhrData = this[SENTRY_XHR_DATA_KEY];\n        if (!sentryXhrData) {\n          return originalSend.apply(this, args);\n        }\n        if (args[0] !== void 0) {\n          sentryXhrData.body = args[0];\n        }\n        const handlerData = {\n          startTimestamp: timestampInSeconds() * 1e3,\n          xhr: this\n        };\n        triggerHandlers(\"xhr\", handlerData);\n        return originalSend.apply(this, args);\n      };\n    });\n  }\n  function parseUrl2(url) {\n    if (isString(url)) {\n      return url;\n    }\n    try {\n      return url.toString();\n    } catch (e2) {\n    }\n    return void 0;\n  }\n\n  // node_modules/@sentry-internal/browser-utils/esm/metrics/inp.js\n  var LAST_INTERACTIONS = [];\n  var INTERACTIONS_ROUTE_MAP = /* @__PURE__ */ new Map();\n  function startTrackingINP() {\n    const performance2 = getBrowserPerformanceAPI();\n    if (performance2 && browserPerformanceTimeOrigin) {\n      const inpCallback = _trackINP();\n      return () => {\n        inpCallback();\n      };\n    }\n    return () => void 0;\n  }\n  var INP_ENTRY_MAP = {\n    click: \"click\",\n    pointerdown: \"click\",\n    pointerup: \"click\",\n    mousedown: \"click\",\n    mouseup: \"click\",\n    touchstart: \"click\",\n    touchend: \"click\",\n    mouseover: \"hover\",\n    mouseout: \"hover\",\n    mouseenter: \"hover\",\n    mouseleave: \"hover\",\n    pointerover: \"hover\",\n    pointerout: \"hover\",\n    pointerenter: \"hover\",\n    pointerleave: \"hover\",\n    dragstart: \"drag\",\n    dragend: \"drag\",\n    drag: \"drag\",\n    dragenter: \"drag\",\n    dragleave: \"drag\",\n    dragover: \"drag\",\n    drop: \"drag\",\n    keydown: \"press\",\n    keyup: \"press\",\n    keypress: \"press\",\n    input: \"press\"\n  };\n  function _trackINP() {\n    return addInpInstrumentationHandler(({ metric }) => {\n      const client = getClient();\n      if (!client || metric.value == void 0) {\n        return;\n      }\n      const entry = metric.entries.find((entry2) => entry2.duration === metric.value && INP_ENTRY_MAP[entry2.name]);\n      if (!entry) {\n        return;\n      }\n      const { interactionId } = entry;\n      const interactionType = INP_ENTRY_MAP[entry.name];\n      const options = client.getOptions();\n      const startTime = msToSec(browserPerformanceTimeOrigin + entry.startTime);\n      const duration = msToSec(metric.value);\n      const scope = getCurrentScope();\n      const activeSpan = getActiveSpan();\n      const rootSpan = activeSpan ? getRootSpan(activeSpan) : void 0;\n      const cachedRouteName = interactionId != null ? INTERACTIONS_ROUTE_MAP.get(interactionId) : void 0;\n      const routeName = cachedRouteName || (rootSpan ? spanToJSON(rootSpan).description : scope.getScopeData().transactionName);\n      const user = scope.getUser();\n      const replay = client.getIntegrationByName(\"Replay\");\n      const replayId = replay && replay.getReplayId();\n      const userDisplay = user !== void 0 ? user.email || user.id || user.ip_address : void 0;\n      let profileId = void 0;\n      try {\n        profileId = scope.getScopeData().contexts.profile.profile_id;\n      } catch (e2) {\n      }\n      const name2 = htmlTreeAsString(entry.target);\n      const attributes = dropUndefinedKeys({\n        release: options.release,\n        environment: options.environment,\n        transaction: routeName,\n        [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: metric.value,\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.http.browser.inp\",\n        user: userDisplay || void 0,\n        profile_id: profileId || void 0,\n        replay_id: replayId || void 0\n      });\n      const span = startInactiveSpan({\n        name: name2,\n        op: `ui.interaction.${interactionType}`,\n        attributes,\n        startTime,\n        experimental: {\n          standalone: true\n        }\n      });\n      span.addEvent(\"inp\", {\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: \"millisecond\",\n        [SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: metric.value\n      });\n      span.end(startTime + duration);\n    });\n  }\n  function registerInpInteractionListener(latestRoute) {\n    const handleEntries = ({ entries }) => {\n      entries.forEach((entry) => {\n        if (!isPerformanceEventTiming(entry) || !latestRoute.name) {\n          return;\n        }\n        const interactionId = entry.interactionId;\n        if (interactionId == null) {\n          return;\n        }\n        if (INTERACTIONS_ROUTE_MAP.has(interactionId)) {\n          return;\n        }\n        if (LAST_INTERACTIONS.length > 10) {\n          const last = LAST_INTERACTIONS.shift();\n          INTERACTIONS_ROUTE_MAP.delete(last);\n        }\n        LAST_INTERACTIONS.push(interactionId);\n        INTERACTIONS_ROUTE_MAP.set(interactionId, latestRoute.name);\n      });\n    };\n    addPerformanceInstrumentationHandler(\"event\", handleEntries);\n    addPerformanceInstrumentationHandler(\"first-input\", handleEntries);\n  }\n\n  // node_modules/@sentry/browser/esm/transports/fetch.js\n  function makeFetchTransport(options, nativeFetch = getNativeImplementation(\"fetch\")) {\n    let pendingBodySize = 0;\n    let pendingCount = 0;\n    function makeRequest(request) {\n      const requestSize = request.body.length;\n      pendingBodySize += requestSize;\n      pendingCount++;\n      const requestOptions = {\n        body: request.body,\n        method: \"POST\",\n        referrerPolicy: \"origin\",\n        headers: options.headers,\n        // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n        // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n        // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n        // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n        // Gotchas:\n        // - `keepalive` isn't supported by Firefox\n        // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):\n        //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.\n        //   We will therefore only activate the flag when we're below that limit.\n        // There is also a limit of requests that can be open at the same time, so we also limit this to 15\n        // See https://github.com/getsentry/sentry-javascript/pull/7553 for details\n        keepalive: pendingBodySize <= 6e4 && pendingCount < 15,\n        ...options.fetchOptions\n      };\n      if (!nativeFetch) {\n        clearCachedImplementation(\"fetch\");\n        return rejectedSyncPromise(\"No fetch implementation available\");\n      }\n      try {\n        return nativeFetch(options.url, requestOptions).then((response) => {\n          pendingBodySize -= requestSize;\n          pendingCount--;\n          return {\n            statusCode: response.status,\n            headers: {\n              \"x-sentry-rate-limits\": response.headers.get(\"X-Sentry-Rate-Limits\"),\n              \"retry-after\": response.headers.get(\"Retry-After\")\n            }\n          };\n        });\n      } catch (e2) {\n        clearCachedImplementation(\"fetch\");\n        pendingBodySize -= requestSize;\n        pendingCount--;\n        return rejectedSyncPromise(e2);\n      }\n    }\n    return createTransport(options, makeRequest);\n  }\n\n  // node_modules/@sentry/browser/esm/stack-parsers.js\n  var CHROME_PRIORITY = 30;\n  var GECKO_PRIORITY = 50;\n  function createFrame(filename, func, lineno, colno) {\n    const frame = {\n      filename,\n      function: func === \"<anonymous>\" ? UNKNOWN_FUNCTION : func,\n      in_app: true\n      // All browser frames are considered in_app\n    };\n    if (lineno !== void 0) {\n      frame.lineno = lineno;\n    }\n    if (colno !== void 0) {\n      frame.colno = colno;\n    }\n    return frame;\n  }\n  var chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\n  var chromeRegex = /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n  var chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n  var chromeStackParserFn = (line) => {\n    const noFnParts = chromeRegexNoFnName.exec(line);\n    if (noFnParts) {\n      const [, filename, line2, col] = noFnParts;\n      return createFrame(filename, UNKNOWN_FUNCTION, +line2, +col);\n    }\n    const parts = chromeRegex.exec(line);\n    if (parts) {\n      const isEval = parts[2] && parts[2].indexOf(\"eval\") === 0;\n      if (isEval) {\n        const subMatch = chromeEvalRegex.exec(parts[2]);\n        if (subMatch) {\n          parts[2] = subMatch[1];\n          parts[3] = subMatch[2];\n          parts[4] = subMatch[3];\n        }\n      }\n      const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);\n    }\n    return;\n  };\n  var chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];\n  var geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n  var geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n  var gecko = (line) => {\n    const parts = geckoREgex.exec(line);\n    if (parts) {\n      const isEval = parts[3] && parts[3].indexOf(\" > eval\") > -1;\n      if (isEval) {\n        const subMatch = geckoEvalRegex.exec(parts[3]);\n        if (subMatch) {\n          parts[1] = parts[1] || \"eval\";\n          parts[3] = subMatch[1];\n          parts[4] = subMatch[2];\n          parts[5] = \"\";\n        }\n      }\n      let filename = parts[3];\n      let func = parts[1] || UNKNOWN_FUNCTION;\n      [func, filename] = extractSafariExtensionDetails(func, filename);\n      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);\n    }\n    return;\n  };\n  var geckoStackLineParser = [GECKO_PRIORITY, gecko];\n  var defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];\n  var defaultStackParser = createStackParser(...defaultStackLineParsers);\n  var extractSafariExtensionDetails = (func, filename) => {\n    const isSafariExtension = func.indexOf(\"safari-extension\") !== -1;\n    const isSafariWebExtension = func.indexOf(\"safari-web-extension\") !== -1;\n    return isSafariExtension || isSafariWebExtension ? [\n      func.indexOf(\"@\") !== -1 ? func.split(\"@\")[0] : UNKNOWN_FUNCTION,\n      isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`\n    ] : [func, filename];\n  };\n\n  // node_modules/@sentry/browser/esm/integrations/breadcrumbs.js\n  var MAX_ALLOWED_STRING_LENGTH = 1024;\n  var INTEGRATION_NAME4 = \"Breadcrumbs\";\n  var _breadcrumbsIntegration = (options = {}) => {\n    const _options = {\n      console: true,\n      dom: true,\n      fetch: true,\n      history: true,\n      sentry: true,\n      xhr: true,\n      ...options\n    };\n    return {\n      name: INTEGRATION_NAME4,\n      setup(client) {\n        if (_options.console) {\n          addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));\n        }\n        if (_options.dom) {\n          addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));\n        }\n        if (_options.xhr) {\n          addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));\n        }\n        if (_options.fetch) {\n          addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));\n        }\n        if (_options.history) {\n          addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));\n        }\n        if (_options.sentry) {\n          client.on(\"beforeSendEvent\", _getSentryBreadcrumbHandler(client));\n        }\n      }\n    };\n  };\n  var breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);\n  function _getSentryBreadcrumbHandler(client) {\n    return function addSentryBreadcrumb(event) {\n      if (getClient() !== client) {\n        return;\n      }\n      addBreadcrumb(\n        {\n          category: `sentry.${event.type === \"transaction\" ? \"transaction\" : \"event\"}`,\n          event_id: event.event_id,\n          level: event.level,\n          message: getEventDescription(event)\n        },\n        {\n          event\n        }\n      );\n    };\n  }\n  function _getDomBreadcrumbHandler(client, dom) {\n    return function _innerDomBreadcrumb(handlerData) {\n      if (getClient() !== client) {\n        return;\n      }\n      let target;\n      let componentName;\n      let keyAttrs = typeof dom === \"object\" ? dom.serializeAttribute : void 0;\n      let maxStringLength = typeof dom === \"object\" && typeof dom.maxStringLength === \"number\" ? dom.maxStringLength : void 0;\n      if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {\n        DEBUG_BUILD3 && logger.warn(\n          `\\`dom.maxStringLength\\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`\n        );\n        maxStringLength = MAX_ALLOWED_STRING_LENGTH;\n      }\n      if (typeof keyAttrs === \"string\") {\n        keyAttrs = [keyAttrs];\n      }\n      try {\n        const event = handlerData.event;\n        const element = _isEvent(event) ? event.target : event;\n        target = htmlTreeAsString(element, { keyAttrs, maxStringLength });\n        componentName = getComponentName(element);\n      } catch (e2) {\n        target = \"<unknown>\";\n      }\n      if (target.length === 0) {\n        return;\n      }\n      const breadcrumb = {\n        category: `ui.${handlerData.name}`,\n        message: target\n      };\n      if (componentName) {\n        breadcrumb.data = { \"ui.component_name\": componentName };\n      }\n      addBreadcrumb(breadcrumb, {\n        event: handlerData.event,\n        name: handlerData.name,\n        global: handlerData.global\n      });\n    };\n  }\n  function _getConsoleBreadcrumbHandler(client) {\n    return function _consoleBreadcrumb(handlerData) {\n      if (getClient() !== client) {\n        return;\n      }\n      const breadcrumb = {\n        category: \"console\",\n        data: {\n          arguments: handlerData.args,\n          logger: \"console\"\n        },\n        level: severityLevelFromString(handlerData.level),\n        message: safeJoin(handlerData.args, \" \")\n      };\n      if (handlerData.level === \"assert\") {\n        if (handlerData.args[0] === false) {\n          breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), \" \") || \"console.assert\"}`;\n          breadcrumb.data.arguments = handlerData.args.slice(1);\n        } else {\n          return;\n        }\n      }\n      addBreadcrumb(breadcrumb, {\n        input: handlerData.args,\n        level: handlerData.level\n      });\n    };\n  }\n  function _getXhrBreadcrumbHandler(client) {\n    return function _xhrBreadcrumb(handlerData) {\n      if (getClient() !== client) {\n        return;\n      }\n      const { startTimestamp, endTimestamp } = handlerData;\n      const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];\n      if (!startTimestamp || !endTimestamp || !sentryXhrData) {\n        return;\n      }\n      const { method, url, status_code, body } = sentryXhrData;\n      const data = {\n        method,\n        url,\n        status_code\n      };\n      const hint = {\n        xhr: handlerData.xhr,\n        input: body,\n        startTimestamp,\n        endTimestamp\n      };\n      addBreadcrumb(\n        {\n          category: \"xhr\",\n          data,\n          type: \"http\"\n        },\n        hint\n      );\n    };\n  }\n  function _getFetchBreadcrumbHandler(client) {\n    return function _fetchBreadcrumb(handlerData) {\n      if (getClient() !== client) {\n        return;\n      }\n      const { startTimestamp, endTimestamp } = handlerData;\n      if (!endTimestamp) {\n        return;\n      }\n      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === \"POST\") {\n        return;\n      }\n      if (handlerData.error) {\n        const data = handlerData.fetchData;\n        const hint = {\n          data: handlerData.error,\n          input: handlerData.args,\n          startTimestamp,\n          endTimestamp\n        };\n        addBreadcrumb(\n          {\n            category: \"fetch\",\n            data,\n            level: \"error\",\n            type: \"http\"\n          },\n          hint\n        );\n      } else {\n        const response = handlerData.response;\n        const data = {\n          ...handlerData.fetchData,\n          status_code: response && response.status\n        };\n        const hint = {\n          input: handlerData.args,\n          response,\n          startTimestamp,\n          endTimestamp\n        };\n        addBreadcrumb(\n          {\n            category: \"fetch\",\n            data,\n            type: \"http\"\n          },\n          hint\n        );\n      }\n    };\n  }\n  function _getHistoryBreadcrumbHandler(client) {\n    return function _historyBreadcrumb(handlerData) {\n      if (getClient() !== client) {\n        return;\n      }\n      let from = handlerData.from;\n      let to = handlerData.to;\n      const parsedLoc = parseUrl(WINDOW4.location.href);\n      let parsedFrom = from ? parseUrl(from) : void 0;\n      const parsedTo = parseUrl(to);\n      if (!parsedFrom || !parsedFrom.path) {\n        parsedFrom = parsedLoc;\n      }\n      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {\n        to = parsedTo.relative;\n      }\n      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {\n        from = parsedFrom.relative;\n      }\n      addBreadcrumb({\n        category: \"navigation\",\n        data: {\n          from,\n          to\n        }\n      });\n    };\n  }\n  function _isEvent(event) {\n    return !!event && !!event.target;\n  }\n\n  // node_modules/@sentry/browser/esm/integrations/browserapierrors.js\n  var DEFAULT_EVENT_TARGET = [\n    \"EventTarget\",\n    \"Window\",\n    \"Node\",\n    \"ApplicationCache\",\n    \"AudioTrackList\",\n    \"BroadcastChannel\",\n    \"ChannelMergerNode\",\n    \"CryptoOperation\",\n    \"EventSource\",\n    \"FileReader\",\n    \"HTMLUnknownElement\",\n    \"IDBDatabase\",\n    \"IDBRequest\",\n    \"IDBTransaction\",\n    \"KeyOperation\",\n    \"MediaController\",\n    \"MessagePort\",\n    \"ModalWindow\",\n    \"Notification\",\n    \"SVGElementInstance\",\n    \"Screen\",\n    \"SharedWorker\",\n    \"TextTrack\",\n    \"TextTrackCue\",\n    \"TextTrackList\",\n    \"WebSocket\",\n    \"WebSocketWorker\",\n    \"Worker\",\n    \"XMLHttpRequest\",\n    \"XMLHttpRequestEventTarget\",\n    \"XMLHttpRequestUpload\"\n  ];\n  var INTEGRATION_NAME5 = \"BrowserApiErrors\";\n  var _browserApiErrorsIntegration = (options = {}) => {\n    const _options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options\n    };\n    return {\n      name: INTEGRATION_NAME5,\n      // TODO: This currently only works for the first client this is setup\n      // We may want to adjust this to check for client etc.\n      setupOnce() {\n        if (_options.setTimeout) {\n          fill(WINDOW4, \"setTimeout\", _wrapTimeFunction);\n        }\n        if (_options.setInterval) {\n          fill(WINDOW4, \"setInterval\", _wrapTimeFunction);\n        }\n        if (_options.requestAnimationFrame) {\n          fill(WINDOW4, \"requestAnimationFrame\", _wrapRAF);\n        }\n        if (_options.XMLHttpRequest && \"XMLHttpRequest\" in WINDOW4) {\n          fill(XMLHttpRequest.prototype, \"send\", _wrapXHR);\n        }\n        const eventTargetOption = _options.eventTarget;\n        if (eventTargetOption) {\n          const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n          eventTarget.forEach(_wrapEventTarget);\n        }\n      }\n    };\n  };\n  var browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);\n  function _wrapTimeFunction(original) {\n    return function(...args) {\n      const originalCallback = args[0];\n      args[0] = wrap(originalCallback, {\n        mechanism: {\n          data: { function: getFunctionName(original) },\n          handled: false,\n          type: \"instrument\"\n        }\n      });\n      return original.apply(this, args);\n    };\n  }\n  function _wrapRAF(original) {\n    return function(callback) {\n      return original.apply(this, [\n        wrap(callback, {\n          mechanism: {\n            data: {\n              function: \"requestAnimationFrame\",\n              handler: getFunctionName(original)\n            },\n            handled: false,\n            type: \"instrument\"\n          }\n        })\n      ]);\n    };\n  }\n  function _wrapXHR(originalSend) {\n    return function(...args) {\n      const xhr = this;\n      const xmlHttpRequestProps = [\"onload\", \"onerror\", \"onprogress\", \"onreadystatechange\"];\n      xmlHttpRequestProps.forEach((prop) => {\n        if (prop in xhr && typeof xhr[prop] === \"function\") {\n          fill(xhr, prop, function(original) {\n            const wrapOptions = {\n              mechanism: {\n                data: {\n                  function: prop,\n                  handler: getFunctionName(original)\n                },\n                handled: false,\n                type: \"instrument\"\n              }\n            };\n            const originalFunction = getOriginalFunction(original);\n            if (originalFunction) {\n              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n            }\n            return wrap(original, wrapOptions);\n          });\n        }\n      });\n      return originalSend.apply(this, args);\n    };\n  }\n  function _wrapEventTarget(target) {\n    const globalObject = WINDOW4;\n    const proto = globalObject[target] && globalObject[target].prototype;\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty(\"addEventListener\")) {\n      return;\n    }\n    fill(proto, \"addEventListener\", function(original) {\n      return function(eventName, fn2, options) {\n        try {\n          if (typeof fn2.handleEvent === \"function\") {\n            fn2.handleEvent = wrap(fn2.handleEvent, {\n              mechanism: {\n                data: {\n                  function: \"handleEvent\",\n                  handler: getFunctionName(fn2),\n                  target\n                },\n                handled: false,\n                type: \"instrument\"\n              }\n            });\n          }\n        } catch (err) {\n        }\n        return original.apply(this, [\n          eventName,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          wrap(fn2, {\n            mechanism: {\n              data: {\n                function: \"addEventListener\",\n                handler: getFunctionName(fn2),\n                target\n              },\n              handled: false,\n              type: \"instrument\"\n            }\n          }),\n          options\n        ]);\n      };\n    });\n    fill(\n      proto,\n      \"removeEventListener\",\n      function(originalRemoveEventListener) {\n        return function(eventName, fn2, options) {\n          const wrappedEventHandler = fn2;\n          try {\n            const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n            if (originalEventHandler) {\n              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n            }\n          } catch (e2) {\n          }\n          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n        };\n      }\n    );\n  }\n\n  // node_modules/@sentry/browser/esm/integrations/globalhandlers.js\n  var INTEGRATION_NAME6 = \"GlobalHandlers\";\n  var _globalHandlersIntegration = (options = {}) => {\n    const _options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options\n    };\n    return {\n      name: INTEGRATION_NAME6,\n      setupOnce() {\n        Error.stackTraceLimit = 50;\n      },\n      setup(client) {\n        if (_options.onerror) {\n          _installGlobalOnErrorHandler(client);\n          globalHandlerLog(\"onerror\");\n        }\n        if (_options.onunhandledrejection) {\n          _installGlobalOnUnhandledRejectionHandler(client);\n          globalHandlerLog(\"onunhandledrejection\");\n        }\n      }\n    };\n  };\n  var globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);\n  function _installGlobalOnErrorHandler(client) {\n    addGlobalErrorInstrumentationHandler((data) => {\n      const { stackParser, attachStacktrace } = getOptions();\n      if (getClient() !== client || shouldIgnoreOnError()) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      const event = _enhanceEventWithInitialFrame(\n        eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, false),\n        url,\n        line,\n        column\n      );\n      event.level = \"error\";\n      captureEvent(event, {\n        originalException: error,\n        mechanism: {\n          handled: false,\n          type: \"onerror\"\n        }\n      });\n    });\n  }\n  function _installGlobalOnUnhandledRejectionHandler(client) {\n    addGlobalUnhandledRejectionInstrumentationHandler((e2) => {\n      const { stackParser, attachStacktrace } = getOptions();\n      if (getClient() !== client || shouldIgnoreOnError()) {\n        return;\n      }\n      const error = _getUnhandledRejectionError(e2);\n      const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, true);\n      event.level = \"error\";\n      captureEvent(event, {\n        originalException: error,\n        mechanism: {\n          handled: false,\n          type: \"onunhandledrejection\"\n        }\n      });\n    });\n  }\n  function _getUnhandledRejectionError(error) {\n    if (isPrimitive(error)) {\n      return error;\n    }\n    try {\n      if (\"reason\" in error) {\n        return error.reason;\n      }\n      if (\"detail\" in error && \"reason\" in error.detail) {\n        return error.detail.reason;\n      }\n    } catch (e2) {\n    }\n    return error;\n  }\n  function _eventFromRejectionWithPrimitive(reason) {\n    return {\n      exception: {\n        values: [\n          {\n            type: \"UnhandledRejection\",\n            // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n            value: `Non-Error promise rejection captured with value: ${String(reason)}`\n          }\n        ]\n      }\n    };\n  }\n  function _enhanceEventWithInitialFrame(event, url, line, column) {\n    const e2 = event.exception = event.exception || {};\n    const ev = e2.values = e2.values || [];\n    const ev0 = ev[0] = ev[0] || {};\n    const ev0s = ev0.stacktrace = ev0.stacktrace || {};\n    const ev0sf = ev0s.frames = ev0s.frames || [];\n    const colno = isNaN(parseInt(column, 10)) ? void 0 : column;\n    const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;\n    const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n    if (ev0sf.length === 0) {\n      ev0sf.push({\n        colno,\n        filename,\n        function: UNKNOWN_FUNCTION,\n        in_app: true,\n        lineno\n      });\n    }\n    return event;\n  }\n  function globalHandlerLog(type) {\n    DEBUG_BUILD3 && logger.log(`Global Handler attached: ${type}`);\n  }\n  function getOptions() {\n    const client = getClient();\n    const options = client && client.getOptions() || {\n      stackParser: () => [],\n      attachStacktrace: false\n    };\n    return options;\n  }\n\n  // node_modules/@sentry/browser/esm/integrations/httpcontext.js\n  var httpContextIntegration = defineIntegration(() => {\n    return {\n      name: \"HttpContext\",\n      preprocessEvent(event) {\n        if (!WINDOW4.navigator && !WINDOW4.location && !WINDOW4.document) {\n          return;\n        }\n        const url = event.request && event.request.url || WINDOW4.location && WINDOW4.location.href;\n        const { referrer } = WINDOW4.document || {};\n        const { userAgent } = WINDOW4.navigator || {};\n        const headers = {\n          ...event.request && event.request.headers,\n          ...referrer && { Referer: referrer },\n          ...userAgent && { \"User-Agent\": userAgent }\n        };\n        const request = { ...event.request, ...url && { url }, headers };\n        event.request = request;\n      }\n    };\n  });\n\n  // node_modules/@sentry/browser/esm/integrations/linkederrors.js\n  var DEFAULT_KEY = \"cause\";\n  var DEFAULT_LIMIT = 5;\n  var INTEGRATION_NAME7 = \"LinkedErrors\";\n  var _linkedErrorsIntegration = (options = {}) => {\n    const limit = options.limit || DEFAULT_LIMIT;\n    const key = options.key || DEFAULT_KEY;\n    return {\n      name: INTEGRATION_NAME7,\n      preprocessEvent(event, hint, client) {\n        const options2 = client.getOptions();\n        applyAggregateErrorsToEvent(\n          // This differs from the LinkedErrors integration in core by using a different exceptionFromError function\n          exceptionFromError,\n          options2.stackParser,\n          options2.maxValueLength,\n          key,\n          limit,\n          event,\n          hint\n        );\n      }\n    };\n  };\n  var linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);\n\n  // node_modules/@sentry/browser/esm/sdk.js\n  function getDefaultIntegrations(_options) {\n    return [\n      inboundFiltersIntegration(),\n      functionToStringIntegration(),\n      browserApiErrorsIntegration(),\n      breadcrumbsIntegration(),\n      globalHandlersIntegration(),\n      linkedErrorsIntegration(),\n      dedupeIntegration(),\n      httpContextIntegration()\n    ];\n  }\n  function applyDefaultOptions(optionsArg = {}) {\n    const defaultOptions2 = {\n      defaultIntegrations: getDefaultIntegrations(),\n      release: typeof __SENTRY_RELEASE__ === \"string\" ? __SENTRY_RELEASE__ : WINDOW4.SENTRY_RELEASE && WINDOW4.SENTRY_RELEASE.id ? WINDOW4.SENTRY_RELEASE.id : void 0,\n      autoSessionTracking: true,\n      sendClientReports: true\n    };\n    return { ...defaultOptions2, ...optionsArg };\n  }\n  function shouldShowBrowserExtensionError() {\n    const windowWithMaybeExtension = WINDOW4;\n    const extensionKey = windowWithMaybeExtension.chrome ? \"chrome\" : \"browser\";\n    const extensionObject = windowWithMaybeExtension[extensionKey];\n    const runtimeId = extensionObject && extensionObject.runtime && extensionObject.runtime.id;\n    const href = WINDOW4.location && WINDOW4.location.href || \"\";\n    const extensionProtocols = [\"chrome-extension:\", \"moz-extension:\", \"ms-browser-extension:\"];\n    const isDedicatedExtensionPage = !!runtimeId && WINDOW4 === WINDOW4.top && extensionProtocols.some((protocol) => href.startsWith(`${protocol}//`));\n    return !!runtimeId && !isDedicatedExtensionPage;\n  }\n  function init(browserOptions = {}) {\n    const options = applyDefaultOptions(browserOptions);\n    if (shouldShowBrowserExtensionError()) {\n      consoleSandbox(() => {\n        console.error(\n          \"[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/\"\n        );\n      });\n      return;\n    }\n    if (DEBUG_BUILD3) {\n      if (!supportsFetch()) {\n        logger.warn(\n          \"No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill.\"\n        );\n      }\n    }\n    const clientOptions = {\n      ...options,\n      stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),\n      integrations: getIntegrationsToSetup(options),\n      transport: options.transport || makeFetchTransport\n    };\n    initAndBind(BrowserClient, clientOptions);\n    if (options.autoSessionTracking) {\n      startSessionTracking();\n    }\n  }\n  function startSessionTracking() {\n    if (typeof WINDOW4.document === \"undefined\") {\n      DEBUG_BUILD3 && logger.warn(\"Session tracking in non-browser environment with @sentry/browser is not supported.\");\n      return;\n    }\n    startSession({ ignoreDuration: true });\n    captureSession();\n    addHistoryInstrumentationHandler(({ from, to }) => {\n      if (from !== void 0 && from !== to) {\n        startSession({ ignoreDuration: true });\n        captureSession();\n      }\n    });\n  }\n\n  // node_modules/@sentry-internal/replay/esm/index.js\n  var WINDOW6 = GLOBAL_OBJ;\n  var REPLAY_SESSION_KEY = \"sentryReplaySession\";\n  var REPLAY_EVENT_NAME = \"replay_event\";\n  var UNABLE_TO_SEND_REPLAY = \"Unable to send Replay\";\n  var SESSION_IDLE_PAUSE_DURATION = 3e5;\n  var SESSION_IDLE_EXPIRE_DURATION = 9e5;\n  var DEFAULT_FLUSH_MIN_DELAY = 5e3;\n  var DEFAULT_FLUSH_MAX_DELAY = 5500;\n  var BUFFER_CHECKOUT_TIME = 6e4;\n  var RETRY_BASE_INTERVAL = 5e3;\n  var RETRY_MAX_COUNT = 3;\n  var NETWORK_BODY_MAX_SIZE = 15e4;\n  var CONSOLE_ARG_MAX_SIZE = 5e3;\n  var SLOW_CLICK_THRESHOLD = 3e3;\n  var SLOW_CLICK_SCROLL_TIMEOUT = 300;\n  var REPLAY_MAX_EVENT_BUFFER_SIZE = 2e7;\n  var MIN_REPLAY_DURATION = 4999;\n  var MIN_REPLAY_DURATION_LIMIT = 15e3;\n  var MAX_REPLAY_DURATION = 36e5;\n  function _nullishCoalesce$1(lhs, rhsFn) {\n    if (lhs != null) {\n      return lhs;\n    } else {\n      return rhsFn();\n    }\n  }\n  function _optionalChain$5(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return void 0;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  var NodeType$1;\n  (function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  })(NodeType$1 || (NodeType$1 = {}));\n  function isElement$1(n) {\n    return n.nodeType === n.ELEMENT_NODE;\n  }\n  function isShadowRoot2(n) {\n    const host = _optionalChain$5([n, \"optionalAccess\", (_) => _.host]);\n    return Boolean(_optionalChain$5([host, \"optionalAccess\", (_2) => _2.shadowRoot]) === n);\n  }\n  function isNativeShadowDom(shadowRoot) {\n    return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n  }\n  function fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n      cssText = cssText.replace(\" background-clip: text;\", \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n  }\n  function escapeImportStatement(rule) {\n    const { cssText } = rule;\n    if (cssText.split('\"').length < 3)\n      return cssText;\n    const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n    if (rule.layerName === \"\") {\n      statement.push(`layer`);\n    } else if (rule.layerName) {\n      statement.push(`layer(${rule.layerName})`);\n    }\n    if (rule.supportsText) {\n      statement.push(`supports(${rule.supportsText})`);\n    }\n    if (rule.media.length) {\n      statement.push(rule.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n  }\n  function stringifyStylesheet(s) {\n    try {\n      const rules = s.rules || s.cssRules;\n      return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(\"\")) : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  function stringifyRule(rule) {\n    let importStringified;\n    if (isCSSImportRule(rule)) {\n      try {\n        importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);\n      } catch (error) {\n      }\n    } else if (isCSSStyleRule(rule) && rule.selectorText.includes(\":\")) {\n      return fixSafariColons(rule.cssText);\n    }\n    return importStringified || rule.cssText;\n  }\n  function fixSafariColons(cssStringified) {\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n  }\n  function isCSSImportRule(rule) {\n    return \"styleSheet\" in rule;\n  }\n  function isCSSStyleRule(rule) {\n    return \"selectorText\" in rule;\n  }\n  var Mirror = class {\n    constructor() {\n      this.idNodeMap = /* @__PURE__ */ new Map();\n      this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    }\n    getId(n) {\n      if (!n)\n        return -1;\n      const id = _optionalChain$5([this, \"access\", (_3) => _3.getMeta, \"call\", (_4) => _4(n), \"optionalAccess\", (_5) => _5.id]);\n      return _nullishCoalesce$1(id, () => -1);\n    }\n    getNode(id) {\n      return this.idNodeMap.get(id) || null;\n    }\n    getIds() {\n      return Array.from(this.idNodeMap.keys());\n    }\n    getMeta(n) {\n      return this.nodeMetaMap.get(n) || null;\n    }\n    removeNodeFromMap(n) {\n      const id = this.getId(n);\n      this.idNodeMap.delete(id);\n      if (n.childNodes) {\n        n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n      }\n    }\n    has(id) {\n      return this.idNodeMap.has(id);\n    }\n    hasNode(node) {\n      return this.nodeMetaMap.has(node);\n    }\n    add(n, meta) {\n      const id = meta.id;\n      this.idNodeMap.set(id, n);\n      this.nodeMetaMap.set(n, meta);\n    }\n    replace(id, n) {\n      const oldNode = this.getNode(id);\n      if (oldNode) {\n        const meta = this.nodeMetaMap.get(oldNode);\n        if (meta)\n          this.nodeMetaMap.set(n, meta);\n      }\n      this.idNodeMap.set(id, n);\n    }\n    reset() {\n      this.idNodeMap = /* @__PURE__ */ new Map();\n      this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    }\n  };\n  function createMirror() {\n    return new Mirror();\n  }\n  function shouldMaskInput({ maskInputOptions, tagName, type }) {\n    if (tagName === \"OPTION\") {\n      tagName = \"SELECT\";\n    }\n    return Boolean(maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]);\n  }\n  function maskInputValue({ isMasked, element, value, maskInputFn }) {\n    let text = value || \"\";\n    if (!isMasked) {\n      return text;\n    }\n    if (maskInputFn) {\n      text = maskInputFn(text, element);\n    }\n    return \"*\".repeat(text.length);\n  }\n  function toLowerCase(str2) {\n    return str2.toLowerCase();\n  }\n  function toUpperCase(str2) {\n    return str2.toUpperCase();\n  }\n  var ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\n  function is2DCanvasBlank(canvas) {\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx)\n      return true;\n    const chunkSize = 50;\n    for (let x = 0; x < canvas.width; x += chunkSize) {\n      for (let y = 0; y < canvas.height; y += chunkSize) {\n        const getImageData = ctx.getImageData;\n        const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n        const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\n        if (pixelBuffer.some((pixel) => pixel !== 0))\n          return false;\n      }\n    }\n    return true;\n  }\n  function getInputType(element) {\n    const type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? toLowerCase(type) : null;\n  }\n  function getInputValue(el, tagName, type) {\n    if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n      return el.getAttribute(\"value\") || \"\";\n    }\n    return el.value;\n  }\n  var _id = 1;\n  var tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\n  var IGNORED_NODE = -2;\n  function genId() {\n    return _id++;\n  }\n  function getValidTagName(element) {\n    if (element instanceof HTMLFormElement) {\n      return \"form\";\n    }\n    const processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n      return \"div\";\n    }\n    return processedTagName;\n  }\n  function extractOrigin(url) {\n    let origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n      origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n      origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n  }\n  var canvasService;\n  var canvasCtx;\n  var URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\n  var URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\n  var URL_WWW_MATCH = /^www\\..*/i;\n  var DATA_URI = /^(data:)([^,]*),(.*)/i;\n  function absoluteToStylesheet(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    });\n  }\n  var SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\n  var SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\n  function getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n      return attributeValue;\n    }\n    let pos = 0;\n    function collectCharacters(regEx) {\n      let chars;\n      const match = regEx.exec(attributeValue.substring(pos));\n      if (match) {\n        chars = match[0];\n        pos += chars.length;\n        return chars;\n      }\n      return \"\";\n    }\n    const output = [];\n    while (true) {\n      collectCharacters(SRCSET_COMMAS_OR_SPACES);\n      if (pos >= attributeValue.length) {\n        break;\n      }\n      let url = collectCharacters(SRCSET_NOT_SPACES);\n      if (url.slice(-1) === \",\") {\n        url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n        output.push(url);\n      } else {\n        let descriptorsStr = \"\";\n        url = absoluteToDoc(doc, url);\n        let inParens = false;\n        while (true) {\n          const c = attributeValue.charAt(pos);\n          if (c === \"\") {\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (!inParens) {\n            if (c === \",\") {\n              pos += 1;\n              output.push((url + descriptorsStr).trim());\n              break;\n            } else if (c === \"(\") {\n              inParens = true;\n            }\n          } else {\n            if (c === \")\") {\n              inParens = false;\n            }\n          }\n          descriptorsStr += c;\n          pos += 1;\n        }\n      }\n    }\n    return output.join(\", \");\n  }\n  function absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n      return attributeValue;\n    }\n    const a = doc.createElement(\"a\");\n    a.href = attributeValue;\n    return a.href;\n  }\n  function isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n  }\n  function getHref() {\n    const a = document.createElement(\"a\");\n    a.href = \"\";\n    return a.href;\n  }\n  function transformAttribute(doc, tagName, name2, value, element, maskAttributeFn) {\n    if (!value) {\n      return value;\n    }\n    if (name2 === \"src\" || name2 === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n      return absoluteToDoc(doc, value);\n    } else if (name2 === \"xlink:href\" && value[0] !== \"#\") {\n      return absoluteToDoc(doc, value);\n    } else if (name2 === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n      return absoluteToDoc(doc, value);\n    } else if (name2 === \"srcset\") {\n      return getAbsoluteSrcsetString(doc, value);\n    } else if (name2 === \"style\") {\n      return absoluteToStylesheet(value, getHref());\n    } else if (tagName === \"object\" && name2 === \"data\") {\n      return absoluteToDoc(doc, value);\n    }\n    if (typeof maskAttributeFn === \"function\") {\n      return maskAttributeFn(name2, value, element);\n    }\n    return value;\n  }\n  function ignoreAttribute(tagName, name2, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name2 === \"autoplay\";\n  }\n  function _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n    try {\n      if (unblockSelector && element.matches(unblockSelector)) {\n        return false;\n      }\n      if (typeof blockClass === \"string\") {\n        if (element.classList.contains(blockClass)) {\n          return true;\n        }\n      } else {\n        for (let eIndex = element.classList.length; eIndex--; ) {\n          const className = element.classList[eIndex];\n          if (blockClass.test(className)) {\n            return true;\n          }\n        }\n      }\n      if (blockSelector) {\n        return element.matches(blockSelector);\n      }\n    } catch (e2) {\n    }\n    return false;\n  }\n  function elementClassMatchesRegex(el, regex) {\n    for (let eIndex = el.classList.length; eIndex--; ) {\n      const className = el.classList[eIndex];\n      if (regex.test(className)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n    if (!node)\n      return -1;\n    if (node.nodeType !== node.ELEMENT_NODE)\n      return -1;\n    if (distance > limit)\n      return -1;\n    if (matchPredicate(node))\n      return distance;\n    return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n  }\n  function createMatchPredicate(className, selector) {\n    return (node) => {\n      const el = node;\n      if (el === null)\n        return false;\n      try {\n        if (className) {\n          if (typeof className === \"string\") {\n            if (el.matches(`.${className}`))\n              return true;\n          } else if (elementClassMatchesRegex(el, className)) {\n            return true;\n          }\n        }\n        if (selector && el.matches(selector))\n          return true;\n        return false;\n      } catch (e2) {\n        return false;\n      }\n    };\n  }\n  function needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n    try {\n      const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n      if (el === null)\n        return false;\n      if (el.tagName === \"INPUT\") {\n        const autocomplete = el.getAttribute(\"autocomplete\");\n        const disallowedAutocompleteValues = [\n          \"current-password\",\n          \"new-password\",\n          \"cc-number\",\n          \"cc-exp\",\n          \"cc-exp-month\",\n          \"cc-exp-year\",\n          \"cc-csc\"\n        ];\n        if (disallowedAutocompleteValues.includes(autocomplete)) {\n          return true;\n        }\n      }\n      let maskDistance = -1;\n      let unmaskDistance = -1;\n      if (maskAllText) {\n        unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector));\n        if (unmaskDistance < 0) {\n          return true;\n        }\n        maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector), unmaskDistance >= 0 ? unmaskDistance : Infinity);\n      } else {\n        maskDistance = distanceToMatch(el, createMatchPredicate(maskTextClass, maskTextSelector));\n        if (maskDistance < 0) {\n          return false;\n        }\n        unmaskDistance = distanceToMatch(el, createMatchPredicate(unmaskTextClass, unmaskTextSelector), maskDistance >= 0 ? maskDistance : Infinity);\n      }\n      return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n    } catch (e2) {\n    }\n    return !!maskAllText;\n  }\n  function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    const win = iframeEl.contentWindow;\n    if (!win) {\n      return;\n    }\n    let fired = false;\n    let readyState;\n    try {\n      readyState = win.document.readyState;\n    } catch (error) {\n      return;\n    }\n    if (readyState !== \"complete\") {\n      const timer = setTimeout(() => {\n        if (!fired) {\n          listener();\n          fired = true;\n        }\n      }, iframeLoadTimeout);\n      iframeEl.addEventListener(\"load\", () => {\n        clearTimeout(timer);\n        fired = true;\n        listener();\n      });\n      return;\n    }\n    const blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n      setTimeout(listener, 0);\n      return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n  }\n  function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    let fired = false;\n    let styleSheetLoaded;\n    try {\n      styleSheetLoaded = link.sheet;\n    } catch (error) {\n      return;\n    }\n    if (styleSheetLoaded)\n      return;\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n  }\n  function serializeNode(n, options) {\n    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, maskAllText, maskAttributeFn, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;\n    const rootId = getRootId(doc, mirror2);\n    switch (n.nodeType) {\n      case n.DOCUMENT_NODE:\n        if (n.compatMode !== \"CSS1Compat\") {\n          return {\n            type: NodeType$1.Document,\n            childNodes: [],\n            compatMode: n.compatMode\n          };\n        } else {\n          return {\n            type: NodeType$1.Document,\n            childNodes: []\n          };\n        }\n      case n.DOCUMENT_TYPE_NODE:\n        return {\n          type: NodeType$1.DocumentType,\n          name: n.name,\n          publicId: n.publicId,\n          systemId: n.systemId,\n          rootId\n        };\n      case n.ELEMENT_NODE:\n        return serializeElementNode(n, {\n          doc,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          inlineStylesheet,\n          maskAttributeFn,\n          maskInputOptions,\n          maskInputFn,\n          dataURLOptions,\n          inlineImages,\n          recordCanvas,\n          keepIframeSrcFn,\n          newlyAddedElement,\n          rootId,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector\n        });\n      case n.TEXT_NODE:\n        return serializeTextNode(n, {\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskTextFn,\n          maskInputOptions,\n          maskInputFn,\n          rootId\n        });\n      case n.CDATA_SECTION_NODE:\n        return {\n          type: NodeType$1.CDATA,\n          textContent: \"\",\n          rootId\n        };\n      case n.COMMENT_NODE:\n        return {\n          type: NodeType$1.Comment,\n          textContent: n.textContent || \"\",\n          rootId\n        };\n      default:\n        return false;\n    }\n  }\n  function getRootId(doc, mirror2) {\n    if (!mirror2.hasNode(doc))\n      return void 0;\n    const docId = mirror2.getId(doc);\n    return docId === 1 ? void 0 : docId;\n  }\n  function serializeTextNode(n, options) {\n    const { maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, maskTextFn, maskInputOptions, maskInputFn, rootId } = options;\n    const parentTagName = n.parentNode && n.parentNode.tagName;\n    let textContent = n.textContent;\n    const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n    const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n    const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n    if (isStyle && textContent) {\n      try {\n        if (n.nextSibling || n.previousSibling) {\n        } else if (_optionalChain$5([n, \"access\", (_6) => _6.parentNode, \"access\", (_7) => _7.sheet, \"optionalAccess\", (_8) => _8.cssRules])) {\n          textContent = stringifyStylesheet(n.parentNode.sheet);\n        }\n      } catch (err) {\n        console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\n      }\n      textContent = absoluteToStylesheet(textContent, getHref());\n    }\n    if (isScript) {\n      textContent = \"SCRIPT_PLACEHOLDER\";\n    }\n    const forceMask = needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText);\n    if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n      textContent = maskTextFn ? maskTextFn(textContent, n.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n    }\n    if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n      textContent = maskInputFn ? maskInputFn(textContent, n.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n    }\n    if (parentTagName === \"OPTION\" && textContent) {\n      const isInputMasked = shouldMaskInput({\n        type: null,\n        tagName: parentTagName,\n        maskInputOptions\n      });\n      textContent = maskInputValue({\n        isMasked: needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked),\n        element: n,\n        value: textContent,\n        maskInputFn\n      });\n    }\n    return {\n      type: NodeType$1.Text,\n      textContent: textContent || \"\",\n      isStyle,\n      rootId\n    };\n  }\n  function serializeElementNode(n, options) {\n    const { doc, blockClass, blockSelector, unblockSelector, inlineStylesheet, maskInputOptions = {}, maskAttributeFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector } = options;\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);\n    const tagName = getValidTagName(n);\n    let attributes = {};\n    const len = n.attributes.length;\n    for (let i = 0; i < len; i++) {\n      const attr = n.attributes[i];\n      if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n        attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value, n, maskAttributeFn);\n      }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n      const stylesheet = Array.from(doc.styleSheets).find((s) => {\n        return s.href === n.href;\n      });\n      let cssText = null;\n      if (stylesheet) {\n        cssText = stringifyStylesheet(stylesheet);\n      }\n      if (cssText) {\n        delete attributes.rel;\n        delete attributes.href;\n        attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n      }\n    }\n    if (tagName === \"style\" && n.sheet && !(n.innerText || n.textContent || \"\").trim().length) {\n      const cssText = stringifyStylesheet(n.sheet);\n      if (cssText) {\n        attributes._cssText = absoluteToStylesheet(cssText, getHref());\n      }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n      const el = n;\n      const type = getInputType(el);\n      const value = getInputValue(el, toUpperCase(tagName), type);\n      const checked = el.checked;\n      if (type !== \"submit\" && type !== \"button\" && value) {\n        const forceMask = needMaskingText(el, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        }));\n        attributes.value = maskInputValue({\n          isMasked: forceMask,\n          element: el,\n          value,\n          maskInputFn\n        });\n      }\n      if (checked) {\n        attributes.checked = checked;\n      }\n    }\n    if (tagName === \"option\") {\n      if (n.selected && !maskInputOptions[\"select\"]) {\n        attributes.selected = true;\n      } else {\n        delete attributes.selected;\n      }\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n      if (n.__context === \"2d\") {\n        if (!is2DCanvasBlank(n)) {\n          attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n        }\n      } else if (!(\"__context\" in n)) {\n        const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n        const blankCanvas = document.createElement(\"canvas\");\n        blankCanvas.width = n.width;\n        blankCanvas.height = n.height;\n        const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n        if (canvasDataURL !== blankCanvasDataURL) {\n          attributes.rr_dataURL = canvasDataURL;\n        }\n      }\n    }\n    if (tagName === \"img\" && inlineImages) {\n      if (!canvasService) {\n        canvasService = doc.createElement(\"canvas\");\n        canvasCtx = canvasService.getContext(\"2d\");\n      }\n      const image = n;\n      const oldValue = image.crossOrigin;\n      image.crossOrigin = \"anonymous\";\n      const recordInlineImage = () => {\n        image.removeEventListener(\"load\", recordInlineImage);\n        try {\n          canvasService.width = image.naturalWidth;\n          canvasService.height = image.naturalHeight;\n          canvasCtx.drawImage(image, 0, 0);\n          attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n        } catch (err) {\n          console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\n        }\n        oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute(\"crossorigin\");\n      };\n      if (image.complete && image.naturalWidth !== 0)\n        recordInlineImage();\n      else\n        image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n      attributes.rr_mediaState = n.paused ? \"paused\" : \"played\";\n      attributes.rr_mediaCurrentTime = n.currentTime;\n    }\n    if (!newlyAddedElement) {\n      if (n.scrollLeft) {\n        attributes.rr_scrollLeft = n.scrollLeft;\n      }\n      if (n.scrollTop) {\n        attributes.rr_scrollTop = n.scrollTop;\n      }\n    }\n    if (needBlock) {\n      const { width, height } = n.getBoundingClientRect();\n      attributes = {\n        class: attributes.class,\n        rr_width: `${width}px`,\n        rr_height: `${height}px`\n      };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n      if (!n.contentDocument) {\n        attributes.rr_src = attributes.src;\n      }\n      delete attributes.src;\n    }\n    let isCustomElement;\n    try {\n      if (customElements.get(tagName))\n        isCustomElement = true;\n    } catch (e2) {\n    }\n    return {\n      type: NodeType$1.Element,\n      tagName,\n      attributes,\n      childNodes: [],\n      isSVG: isSVGElement(n) || void 0,\n      needBlock,\n      rootId,\n      isCustom: isCustomElement\n    };\n  }\n  function lowerIfExists(maybeAttr) {\n    if (maybeAttr === void 0 || maybeAttr === null) {\n      return \"\";\n    } else {\n      return maybeAttr.toLowerCase();\n    }\n  }\n  function slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType$1.Comment) {\n      return true;\n    } else if (sn.type === NodeType$1.Element) {\n      if (slimDOMOptions.script && (sn.tagName === \"script\" || sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") && sn.attributes.as === \"script\" || sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && sn.attributes.href.endsWith(\".js\"))) {\n        return true;\n      } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n        return true;\n      } else if (sn.tagName === \"meta\") {\n        if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n          return true;\n        } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n          return true;\n        } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n          return true;\n        } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n          return true;\n        } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n          return true;\n        } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  function serializeNodeWithId(n, options) {\n    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, maskAllText, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskAttributeFn, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5e3, onStylesheetLoad, stylesheetLoadTimeout = 5e3, keepIframeSrcFn = () => false, newlyAddedElement = false } = options;\n    let { preserveWhiteSpace = true } = options;\n    const _serializedNode = serializeNode(n, {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      keepIframeSrcFn,\n      newlyAddedElement\n    });\n    if (!_serializedNode) {\n      console.warn(n, \"not serialized\");\n      return null;\n    }\n    let id;\n    if (mirror2.hasNode(n)) {\n      id = mirror2.getId(n);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$1.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n      id = IGNORED_NODE;\n    } else {\n      id = genId();\n    }\n    const serializedNode = Object.assign(_serializedNode, { id });\n    mirror2.add(n, serializedNode);\n    if (id === IGNORED_NODE) {\n      return null;\n    }\n    if (onSerialize) {\n      onSerialize(n);\n    }\n    let recordChild = !skipChild;\n    if (serializedNode.type === NodeType$1.Element) {\n      recordChild = recordChild && !serializedNode.needBlock;\n      delete serializedNode.needBlock;\n      const shadowRoot = n.shadowRoot;\n      if (shadowRoot && isNativeShadowDom(shadowRoot))\n        serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType$1.Document || serializedNode.type === NodeType$1.Element) && recordChild) {\n      if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$1.Element && serializedNode.tagName === \"head\") {\n        preserveWhiteSpace = false;\n      }\n      const bypassOptions = {\n        doc,\n        mirror: mirror2,\n        blockClass,\n        blockSelector,\n        maskAllText,\n        unblockSelector,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        skipChild,\n        inlineStylesheet,\n        maskInputOptions,\n        maskAttributeFn,\n        maskTextFn,\n        maskInputFn,\n        slimDOMOptions,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        preserveWhiteSpace,\n        onSerialize,\n        onIframeLoad,\n        iframeLoadTimeout,\n        onStylesheetLoad,\n        stylesheetLoadTimeout,\n        keepIframeSrcFn\n      };\n      for (const childN of Array.from(n.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n      if (isElement$1(n) && n.shadowRoot) {\n        for (const childN of Array.from(n.shadowRoot.childNodes)) {\n          const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n          if (serializedChildNode) {\n            isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);\n            serializedNode.childNodes.push(serializedChildNode);\n          }\n        }\n      }\n    }\n    if (n.parentNode && isShadowRoot2(n.parentNode) && isNativeShadowDom(n.parentNode)) {\n      serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === \"iframe\") {\n      onceIframeLoaded(n, () => {\n        const iframeDoc = n.contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(n, serializedIframeNode);\n          }\n        }\n      }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType$1.Element && serializedNode.tagName === \"link\" && serializedNode.attributes.rel === \"stylesheet\") {\n      onceStylesheetLoaded(n, () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(n, serializedLinkNode);\n          }\n        }\n      }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n  }\n  function snapshot(n, options) {\n    const { mirror: mirror2 = new Mirror(), blockClass = \"rr-block\", blockSelector = null, unblockSelector = null, maskAllText = false, maskTextClass = \"rr-mask\", unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskAttributeFn, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false } = options || {};\n    const maskInputOptions = maskAllInputs === true ? {\n      color: true,\n      date: true,\n      \"datetime-local\": true,\n      email: true,\n      month: true,\n      number: true,\n      range: true,\n      search: true,\n      tel: true,\n      text: true,\n      time: true,\n      url: true,\n      week: true,\n      textarea: true,\n      select: true\n    } : maskAllInputs === false ? {} : maskAllInputs;\n    const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n, {\n      doc: n,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn,\n      newlyAddedElement: false\n    });\n  }\n  function _optionalChain$4(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return void 0;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  function on(type, fn2, target = document) {\n    const options = { capture: true, passive: true };\n    target.addEventListener(type, fn2, options);\n    return () => target.removeEventListener(type, fn2, options);\n  }\n  var DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\n  var _mirror = {\n    map: {},\n    getId() {\n      console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      return -1;\n    },\n    getNode() {\n      console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      return null;\n    },\n    removeNodeFromMap() {\n      console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has() {\n      console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      return false;\n    },\n    reset() {\n      console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n  };\n  if (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n      get(target, prop, receiver) {\n        if (prop === \"map\") {\n          console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        }\n        return Reflect.get(target, prop, receiver);\n      }\n    });\n  }\n  function throttle$1(func, wait, options = {}) {\n    let timeout = null;\n    let previous = 0;\n    return function(...args) {\n      const now = Date.now();\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n      const remaining = wait - (now - previous);\n      const context = this;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout$1(timeout);\n          timeout = null;\n        }\n        previous = now;\n        func.apply(context, args);\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout$1(() => {\n          previous = options.leading === false ? 0 : Date.now();\n          timeout = null;\n          func.apply(context, args);\n        }, remaining);\n      }\n    };\n  }\n  function hookSetter(target, key, d, isRevoked, win = window) {\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    });\n    return () => hookSetter(target, key, original || {}, true);\n  }\n  function patch(source, name2, replacement) {\n    try {\n      if (!(name2 in source)) {\n        return () => {\n        };\n      }\n      const original = source[name2];\n      const wrapped = replacement(original);\n      if (typeof wrapped === \"function\") {\n        wrapped.prototype = wrapped.prototype || {};\n        Object.defineProperties(wrapped, {\n          __rrweb_original__: {\n            enumerable: false,\n            value: original\n          }\n        });\n      }\n      source[name2] = wrapped;\n      return () => {\n        source[name2] = original;\n      };\n    } catch (e2) {\n      return () => {\n      };\n    }\n  }\n  var nowTimestamp = Date.now;\n  if (!/[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n  }\n  function getWindowScroll2(win) {\n    const doc = win.document;\n    return {\n      left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : _optionalChain$4([doc, \"optionalAccess\", (_) => _.documentElement, \"access\", (_2) => _2.scrollLeft]) || _optionalChain$4([doc, \"optionalAccess\", (_3) => _3.body, \"optionalAccess\", (_4) => _4.parentElement, \"optionalAccess\", (_5) => _5.scrollLeft]) || _optionalChain$4([doc, \"optionalAccess\", (_6) => _6.body, \"optionalAccess\", (_7) => _7.scrollLeft]) || 0,\n      top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : _optionalChain$4([doc, \"optionalAccess\", (_8) => _8.documentElement, \"access\", (_9) => _9.scrollTop]) || _optionalChain$4([doc, \"optionalAccess\", (_10) => _10.body, \"optionalAccess\", (_11) => _11.parentElement, \"optionalAccess\", (_12) => _12.scrollTop]) || _optionalChain$4([doc, \"optionalAccess\", (_13) => _13.body, \"optionalAccess\", (_14) => _14.scrollTop]) || 0\n    };\n  }\n  function getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n  }\n  function getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n  }\n  function closestElementOfNode(node) {\n    if (!node) {\n      return null;\n    }\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  }\n  function isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n    if (!node) {\n      return false;\n    }\n    const el = closestElementOfNode(node);\n    if (!el) {\n      return false;\n    }\n    const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n    if (!checkAncestors) {\n      const isUnblocked = unblockSelector && el.matches(unblockSelector);\n      return blockedPredicate(el) && !isUnblocked;\n    }\n    const blockDistance = distanceToMatch(el, blockedPredicate);\n    let unblockDistance = -1;\n    if (blockDistance < 0) {\n      return false;\n    }\n    if (unblockSelector) {\n      unblockDistance = distanceToMatch(el, createMatchPredicate(null, unblockSelector));\n    }\n    if (blockDistance > -1 && unblockDistance < 0) {\n      return true;\n    }\n    return blockDistance < unblockDistance;\n  }\n  function isSerialized(n, mirror2) {\n    return mirror2.getId(n) !== -1;\n  }\n  function isIgnored(n, mirror2) {\n    return mirror2.getId(n) === IGNORED_NODE;\n  }\n  function isAncestorRemoved(target, mirror2) {\n    if (isShadowRoot2(target)) {\n      return false;\n    }\n    const id = mirror2.getId(target);\n    if (!mirror2.has(id)) {\n      return true;\n    }\n    if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n      return false;\n    }\n    if (!target.parentNode) {\n      return true;\n    }\n    return isAncestorRemoved(target.parentNode, mirror2);\n  }\n  function legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n  }\n  function polyfill(win = window) {\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n      win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n      win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (!Node.prototype.contains) {\n      Node.prototype.contains = (...args) => {\n        let node = args[0];\n        if (!(0 in args)) {\n          throw new TypeError(\"1 argument is required\");\n        }\n        do {\n          if (this === node) {\n            return true;\n          }\n        } while (node = node && node.parentNode);\n        return false;\n      };\n    }\n  }\n  function isSerializedIframe(n, mirror2) {\n    return Boolean(n.nodeName === \"IFRAME\" && mirror2.getMeta(n));\n  }\n  function isSerializedStylesheet(n, mirror2) {\n    return Boolean(n.nodeName === \"LINK\" && n.nodeType === n.ELEMENT_NODE && n.getAttribute && n.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n));\n  }\n  function hasShadowRoot(n) {\n    return Boolean(_optionalChain$4([n, \"optionalAccess\", (_18) => _18.shadowRoot]));\n  }\n  var StyleSheetMirror = class {\n    constructor() {\n      this.id = 1;\n      this.styleIDMap = /* @__PURE__ */ new WeakMap();\n      this.idStyleMap = /* @__PURE__ */ new Map();\n    }\n    getId(stylesheet) {\n      return _nullishCoalesce(this.styleIDMap.get(stylesheet), () => -1);\n    }\n    has(stylesheet) {\n      return this.styleIDMap.has(stylesheet);\n    }\n    add(stylesheet, id) {\n      if (this.has(stylesheet))\n        return this.getId(stylesheet);\n      let newId;\n      if (id === void 0) {\n        newId = this.id++;\n      } else\n        newId = id;\n      this.styleIDMap.set(stylesheet, newId);\n      this.idStyleMap.set(newId, stylesheet);\n      return newId;\n    }\n    getStyle(id) {\n      return this.idStyleMap.get(id) || null;\n    }\n    reset() {\n      this.styleIDMap = /* @__PURE__ */ new WeakMap();\n      this.idStyleMap = /* @__PURE__ */ new Map();\n      this.id = 1;\n    }\n    generateId() {\n      return this.id++;\n    }\n  };\n  function getShadowHost(n) {\n    let shadowHost = null;\n    if (_optionalChain$4([n, \"access\", (_19) => _19.getRootNode, \"optionalCall\", (_20) => _20(), \"optionalAccess\", (_21) => _21.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host)\n      shadowHost = n.getRootNode().host;\n    return shadowHost;\n  }\n  function getRootShadowHost(n) {\n    let rootShadowHost = n;\n    let shadowHost;\n    while (shadowHost = getShadowHost(rootShadowHost))\n      rootShadowHost = shadowHost;\n    return rootShadowHost;\n  }\n  function shadowHostInDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc)\n      return false;\n    const shadowHost = getRootShadowHost(n);\n    return doc.contains(shadowHost);\n  }\n  function inDom(n) {\n    const doc = n.ownerDocument;\n    if (!doc)\n      return false;\n    return doc.contains(n) || shadowHostInDom(n);\n  }\n  var cachedImplementations2 = {};\n  function getImplementation(name2) {\n    const cached = cachedImplementations2[name2];\n    if (cached) {\n      return cached;\n    }\n    const document2 = window.document;\n    let impl = window[name2];\n    if (document2 && typeof document2.createElement === \"function\") {\n      try {\n        const sandbox = document2.createElement(\"iframe\");\n        sandbox.hidden = true;\n        document2.head.appendChild(sandbox);\n        const contentWindow = sandbox.contentWindow;\n        if (contentWindow && contentWindow[name2]) {\n          impl = contentWindow[name2];\n        }\n        document2.head.removeChild(sandbox);\n      } catch (e2) {\n      }\n    }\n    return cachedImplementations2[name2] = impl.bind(window);\n  }\n  function onRequestAnimationFrame(...rest) {\n    return getImplementation(\"requestAnimationFrame\")(...rest);\n  }\n  function setTimeout$1(...rest) {\n    return getImplementation(\"setTimeout\")(...rest);\n  }\n  function clearTimeout$1(...rest) {\n    return getImplementation(\"clearTimeout\")(...rest);\n  }\n  var EventType = /* @__PURE__ */ ((EventType2) => {\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n  })(EventType || {});\n  var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n  })(IncrementalSource || {});\n  var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n  })(MouseInteractions || {});\n  var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n  })(PointerTypes || {});\n  function _optionalChain$3(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return void 0;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  function isNodeInLinkedList(n) {\n    return \"__ln\" in n;\n  }\n  var DoubleLinkedList = class {\n    constructor() {\n      this.length = 0;\n      this.head = null;\n      this.tail = null;\n    }\n    get(position) {\n      if (position >= this.length) {\n        throw new Error(\"Position outside of list range\");\n      }\n      let current = this.head;\n      for (let index = 0; index < position; index++) {\n        current = _optionalChain$3([current, \"optionalAccess\", (_) => _.next]) || null;\n      }\n      return current;\n    }\n    addNode(n) {\n      const node = {\n        value: n,\n        previous: null,\n        next: null\n      };\n      n.__ln = node;\n      if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n        const current = n.previousSibling.__ln.next;\n        node.next = current;\n        node.previous = n.previousSibling.__ln;\n        n.previousSibling.__ln.next = node;\n        if (current) {\n          current.previous = node;\n        }\n      } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n        const current = n.nextSibling.__ln.previous;\n        node.previous = current;\n        node.next = n.nextSibling.__ln;\n        n.nextSibling.__ln.previous = node;\n        if (current) {\n          current.next = node;\n        }\n      } else {\n        if (this.head) {\n          this.head.previous = node;\n        }\n        node.next = this.head;\n        this.head = node;\n      }\n      if (node.next === null) {\n        this.tail = node;\n      }\n      this.length++;\n    }\n    removeNode(n) {\n      const current = n.__ln;\n      if (!this.head) {\n        return;\n      }\n      if (!current.previous) {\n        this.head = current.next;\n        if (this.head) {\n          this.head.previous = null;\n        } else {\n          this.tail = null;\n        }\n      } else {\n        current.previous.next = current.next;\n        if (current.next) {\n          current.next.previous = current.previous;\n        } else {\n          this.tail = current.previous;\n        }\n      }\n      if (n.__ln) {\n        delete n.__ln;\n      }\n      this.length--;\n    }\n  };\n  var moveKey = (id, parentId) => `${id}@${parentId}`;\n  var MutationBuffer = class {\n    constructor() {\n      this.frozen = false;\n      this.locked = false;\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.mapRemoves = [];\n      this.movedMap = {};\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.processMutations = (mutations) => {\n        mutations.forEach(this.processMutation);\n        this.emit();\n      };\n      this.emit = () => {\n        if (this.frozen || this.locked) {\n          return;\n        }\n        const adds = [];\n        const addedIds = /* @__PURE__ */ new Set();\n        const addList = new DoubleLinkedList();\n        const getNextId = (n) => {\n          let ns = n;\n          let nextId = IGNORED_NODE;\n          while (nextId === IGNORED_NODE) {\n            ns = ns && ns.nextSibling;\n            nextId = ns && this.mirror.getId(ns);\n          }\n          return nextId;\n        };\n        const pushAdd = (n) => {\n          if (!n.parentNode || !inDom(n)) {\n            return;\n          }\n          const parentId = isShadowRoot2(n.parentNode) ? this.mirror.getId(getShadowHost(n)) : this.mirror.getId(n.parentNode);\n          const nextId = getNextId(n);\n          if (parentId === -1 || nextId === -1) {\n            return addList.addNode(n);\n          }\n          const sn = serializeNodeWithId(n, {\n            doc: this.doc,\n            mirror: this.mirror,\n            blockClass: this.blockClass,\n            blockSelector: this.blockSelector,\n            maskAllText: this.maskAllText,\n            unblockSelector: this.unblockSelector,\n            maskTextClass: this.maskTextClass,\n            unmaskTextClass: this.unmaskTextClass,\n            maskTextSelector: this.maskTextSelector,\n            unmaskTextSelector: this.unmaskTextSelector,\n            skipChild: true,\n            newlyAddedElement: true,\n            inlineStylesheet: this.inlineStylesheet,\n            maskInputOptions: this.maskInputOptions,\n            maskAttributeFn: this.maskAttributeFn,\n            maskTextFn: this.maskTextFn,\n            maskInputFn: this.maskInputFn,\n            slimDOMOptions: this.slimDOMOptions,\n            dataURLOptions: this.dataURLOptions,\n            recordCanvas: this.recordCanvas,\n            inlineImages: this.inlineImages,\n            onSerialize: (currentN) => {\n              if (isSerializedIframe(currentN, this.mirror)) {\n                this.iframeManager.addIframe(currentN);\n              }\n              if (isSerializedStylesheet(currentN, this.mirror)) {\n                this.stylesheetManager.trackLinkElement(currentN);\n              }\n              if (hasShadowRoot(n)) {\n                this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\n              }\n            },\n            onIframeLoad: (iframe, childSn) => {\n              this.iframeManager.attachIframe(iframe, childSn);\n              this.shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: (link, childSn) => {\n              this.stylesheetManager.attachLinkElement(link, childSn);\n            }\n          });\n          if (sn) {\n            adds.push({\n              parentId,\n              nextId,\n              node: sn\n            });\n            addedIds.add(sn.id);\n          }\n        };\n        while (this.mapRemoves.length) {\n          this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n        }\n        for (const n of this.movedSet) {\n          if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {\n            continue;\n          }\n          pushAdd(n);\n        }\n        for (const n of this.addedSet) {\n          if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {\n            pushAdd(n);\n          } else if (isAncestorInSet(this.movedSet, n)) {\n            pushAdd(n);\n          } else {\n            this.droppedSet.add(n);\n          }\n        }\n        let candidate = null;\n        while (addList.length) {\n          let node = null;\n          if (candidate) {\n            const parentId = this.mirror.getId(candidate.value.parentNode);\n            const nextId = getNextId(candidate.value);\n            if (parentId !== -1 && nextId !== -1) {\n              node = candidate;\n            }\n          }\n          if (!node) {\n            let tailNode = addList.tail;\n            while (tailNode) {\n              const _node = tailNode;\n              tailNode = tailNode.previous;\n              if (_node) {\n                const parentId = this.mirror.getId(_node.value.parentNode);\n                const nextId = getNextId(_node.value);\n                if (nextId === -1)\n                  continue;\n                else if (parentId !== -1) {\n                  node = _node;\n                  break;\n                } else {\n                  const unhandledNode = _node.value;\n                  if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                    const shadowHost = unhandledNode.parentNode.host;\n                    const parentId2 = this.mirror.getId(shadowHost);\n                    if (parentId2 !== -1) {\n                      node = _node;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (!node) {\n            while (addList.head) {\n              addList.removeNode(addList.head.value);\n            }\n            break;\n          }\n          candidate = node.previous;\n          addList.removeNode(node.value);\n          pushAdd(node.value);\n        }\n        const payload = {\n          texts: this.texts.map((text) => ({\n            id: this.mirror.getId(text.node),\n            value: text.value\n          })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n          attributes: this.attributes.map((attribute) => {\n            const { attributes } = attribute;\n            if (typeof attributes.style === \"string\") {\n              const diffAsStr = JSON.stringify(attribute.styleDiff);\n              const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n              if (diffAsStr.length < attributes.style.length) {\n                if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                  attributes.style = attribute.styleDiff;\n                }\n              }\n            }\n            return {\n              id: this.mirror.getId(attribute.node),\n              attributes\n            };\n          }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n          removes: this.removes,\n          adds\n        };\n        if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n          return;\n        }\n        this.texts = [];\n        this.attributes = [];\n        this.attributeMap = /* @__PURE__ */ new WeakMap();\n        this.removes = [];\n        this.addedSet = /* @__PURE__ */ new Set();\n        this.movedSet = /* @__PURE__ */ new Set();\n        this.droppedSet = /* @__PURE__ */ new Set();\n        this.movedMap = {};\n        this.mutationCb(payload);\n      };\n      this.processMutation = (m) => {\n        if (isIgnored(m.target, this.mirror)) {\n          return;\n        }\n        switch (m.type) {\n          case \"characterData\": {\n            const value = m.target.textContent;\n            if (!isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) && value !== m.oldValue) {\n              this.texts.push({\n                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                node: m.target\n              });\n            }\n            break;\n          }\n          case \"attributes\": {\n            const target = m.target;\n            let attributeName = m.attributeName;\n            let value = m.target.getAttribute(attributeName);\n            if (attributeName === \"value\") {\n              const type = getInputType(target);\n              const tagName = target.tagName;\n              value = getInputValue(target, tagName, type);\n              const isInputMasked = shouldMaskInput({\n                maskInputOptions: this.maskInputOptions,\n                tagName,\n                type\n              });\n              const forceMask = needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, isInputMasked);\n              value = maskInputValue({\n                isMasked: forceMask,\n                element: target,\n                value,\n                maskInputFn: this.maskInputFn\n              });\n            }\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || value === m.oldValue) {\n              return;\n            }\n            let item = this.attributeMap.get(m.target);\n            if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n              if (!target.contentDocument) {\n                attributeName = \"rr_src\";\n              } else {\n                return;\n              }\n            }\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {},\n                styleDiff: {},\n                _unchangedStyles: {}\n              };\n              this.attributes.push(item);\n              this.attributeMap.set(m.target, item);\n            }\n            if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n              target.setAttribute(\"data-rr-is-password\", \"true\");\n            }\n            if (!ignoreAttribute(target.tagName, attributeName)) {\n              item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value, target, this.maskAttributeFn);\n              if (attributeName === \"style\") {\n                if (!this.unattachedDoc) {\n                  try {\n                    this.unattachedDoc = document.implementation.createHTMLDocument();\n                  } catch (e2) {\n                    this.unattachedDoc = this.doc;\n                  }\n                }\n                const old = this.unattachedDoc.createElement(\"span\");\n                if (m.oldValue) {\n                  old.setAttribute(\"style\", m.oldValue);\n                }\n                for (const pname of Array.from(target.style)) {\n                  const newValue = target.style.getPropertyValue(pname);\n                  const newPriority = target.style.getPropertyPriority(pname);\n                  if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                    if (newPriority === \"\") {\n                      item.styleDiff[pname] = newValue;\n                    } else {\n                      item.styleDiff[pname] = [newValue, newPriority];\n                    }\n                  } else {\n                    item._unchangedStyles[pname] = [newValue, newPriority];\n                  }\n                }\n                for (const pname of Array.from(old.style)) {\n                  if (target.style.getPropertyValue(pname) === \"\") {\n                    item.styleDiff[pname] = false;\n                  }\n                }\n              }\n            }\n            break;\n          }\n          case \"childList\": {\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, true)) {\n              return;\n            }\n            m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n            m.removedNodes.forEach((n) => {\n              const nodeId = this.mirror.getId(n);\n              const parentId = isShadowRoot2(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n              if (isBlocked(m.target, this.blockClass, this.blockSelector, this.unblockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {\n                return;\n              }\n              if (this.addedSet.has(n)) {\n                deepDelete(this.addedSet, n);\n                this.droppedSet.add(n);\n              } else if (this.addedSet.has(m.target) && nodeId === -1)\n                ;\n              else if (isAncestorRemoved(m.target, this.mirror))\n                ;\n              else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(this.movedSet, n);\n              } else {\n                this.removes.push({\n                  parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot2(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                });\n              }\n              this.mapRemoves.push(n);\n            });\n            break;\n          }\n        }\n      };\n      this.genAdds = (n, target) => {\n        if (this.processedNodeManager.inOtherBuffer(n, this))\n          return;\n        if (this.addedSet.has(n) || this.movedSet.has(n))\n          return;\n        if (this.mirror.hasNode(n)) {\n          if (isIgnored(n, this.mirror)) {\n            return;\n          }\n          this.movedSet.add(n);\n          let targetId = null;\n          if (target && this.mirror.hasNode(target)) {\n            targetId = this.mirror.getId(target);\n          }\n          if (targetId && targetId !== -1) {\n            this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\n          }\n        } else {\n          this.addedSet.add(n);\n          this.droppedSet.delete(n);\n        }\n        if (!isBlocked(n, this.blockClass, this.blockSelector, this.unblockSelector, false)) {\n          n.childNodes.forEach((childN) => this.genAdds(childN));\n          if (hasShadowRoot(n)) {\n            n.shadowRoot.childNodes.forEach((childN) => {\n              this.processedNodeManager.add(childN, this);\n              this.genAdds(childN, n);\n            });\n          }\n        }\n      };\n    }\n    init(options) {\n      [\n        \"mutationCb\",\n        \"blockClass\",\n        \"blockSelector\",\n        \"unblockSelector\",\n        \"maskAllText\",\n        \"maskTextClass\",\n        \"unmaskTextClass\",\n        \"maskTextSelector\",\n        \"unmaskTextSelector\",\n        \"inlineStylesheet\",\n        \"maskInputOptions\",\n        \"maskAttributeFn\",\n        \"maskTextFn\",\n        \"maskInputFn\",\n        \"keepIframeSrcFn\",\n        \"recordCanvas\",\n        \"inlineImages\",\n        \"slimDOMOptions\",\n        \"dataURLOptions\",\n        \"doc\",\n        \"mirror\",\n        \"iframeManager\",\n        \"stylesheetManager\",\n        \"shadowDomManager\",\n        \"canvasManager\",\n        \"processedNodeManager\"\n      ].forEach((key) => {\n        this[key] = options[key];\n      });\n    }\n    freeze() {\n      this.frozen = true;\n      this.canvasManager.freeze();\n    }\n    unfreeze() {\n      this.frozen = false;\n      this.canvasManager.unfreeze();\n      this.emit();\n    }\n    isFrozen() {\n      return this.frozen;\n    }\n    lock() {\n      this.locked = true;\n      this.canvasManager.lock();\n    }\n    unlock() {\n      this.locked = false;\n      this.canvasManager.unlock();\n      this.emit();\n    }\n    reset() {\n      this.shadowDomManager.reset();\n      this.canvasManager.reset();\n    }\n  };\n  function deepDelete(addsSet, n) {\n    addsSet.delete(n);\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n  }\n  function isParentRemoved(removes, n, mirror2) {\n    if (removes.length === 0)\n      return false;\n    return _isParentRemoved(removes, n, mirror2);\n  }\n  function _isParentRemoved(removes, n, mirror2) {\n    const { parentNode } = n;\n    if (!parentNode) {\n      return false;\n    }\n    const parentId = mirror2.getId(parentNode);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    return _isParentRemoved(removes, parentNode, mirror2);\n  }\n  function isAncestorInSet(set, n) {\n    if (set.size === 0)\n      return false;\n    return _isAncestorInSet(set, n);\n  }\n  function _isAncestorInSet(set, n) {\n    const { parentNode } = n;\n    if (!parentNode) {\n      return false;\n    }\n    if (set.has(parentNode)) {\n      return true;\n    }\n    return _isAncestorInSet(set, parentNode);\n  }\n  var errorHandler;\n  function registerErrorHandler(handler) {\n    errorHandler = handler;\n  }\n  function unregisterErrorHandler() {\n    errorHandler = void 0;\n  }\n  var callbackWrapper = (cb) => {\n    if (!errorHandler) {\n      return cb;\n    }\n    const rrwebWrapped = (...rest) => {\n      try {\n        return cb(...rest);\n      } catch (error) {\n        if (errorHandler && errorHandler(error) === true) {\n          return () => {\n          };\n        }\n        throw error;\n      }\n    };\n    return rrwebWrapped;\n  };\n  function _optionalChain$2(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return void 0;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  var mutationBuffers = [];\n  function getEventTarget2(event) {\n    try {\n      if (\"composedPath\" in event) {\n        const path = event.composedPath();\n        if (path.length) {\n          return path[0];\n        }\n      } else if (\"path\" in event && event.path.length) {\n        return event.path[0];\n      }\n    } catch (e2) {\n    }\n    return event && event.target;\n  }\n  function initMutationObserver(options, rootEl) {\n    const mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;\n    const angularZoneSymbol = _optionalChain$2([window, \"optionalAccess\", (_) => _.Zone, \"optionalAccess\", (_2) => _2.__symbol__, \"optionalCall\", (_3) => _3(\"MutationObserver\")]);\n    if (angularZoneSymbol && window[angularZoneSymbol]) {\n      mutationObserverCtor = window[angularZoneSymbol];\n    }\n    const observer = new mutationObserverCtor(callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    }));\n    observer.observe(rootEl, {\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true,\n      characterDataOldValue: true,\n      childList: true,\n      subtree: true\n    });\n    return observer;\n  }\n  function initMoveObserver({ mousemoveCb, sampling, doc, mirror: mirror2 }) {\n    if (sampling.mousemove === false) {\n      return () => {\n      };\n    }\n    const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    let positions = [];\n    let timeBaseline;\n    const wrappedCb = throttle$1(callbackWrapper((source) => {\n      const totalOffset = Date.now() - timeBaseline;\n      mousemoveCb(positions.map((p) => {\n        p.timeOffset -= totalOffset;\n        return p;\n      }), source);\n      positions = [];\n      timeBaseline = null;\n    }), callbackThreshold);\n    const updatePosition = callbackWrapper(throttle$1(callbackWrapper((evt) => {\n      const target = getEventTarget2(evt);\n      const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n      if (!timeBaseline) {\n        timeBaseline = nowTimestamp();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror2.getId(target),\n        timeOffset: nowTimestamp() - timeBaseline\n      });\n      wrappedCb(typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n    }), threshold, {\n      trailing: false\n    }));\n    const handlers4 = [\n      on(\"mousemove\", updatePosition, doc),\n      on(\"touchmove\", updatePosition, doc),\n      on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(() => {\n      handlers4.forEach((h) => h());\n    });\n  }\n  function initMouseInteractionObserver({ mouseInteractionCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, sampling }) {\n    if (sampling.mouseInteraction === false) {\n      return () => {\n      };\n    }\n    const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n    const handlers4 = [];\n    let currentPointerType = null;\n    const getHandler = (eventKey) => {\n      return (event) => {\n        const target = getEventTarget2(event);\n        if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n          return;\n        }\n        let pointerType = null;\n        let thisEventKey = eventKey;\n        if (\"pointerType\" in event) {\n          switch (event.pointerType) {\n            case \"mouse\":\n              pointerType = PointerTypes.Mouse;\n              break;\n            case \"touch\":\n              pointerType = PointerTypes.Touch;\n              break;\n            case \"pen\":\n              pointerType = PointerTypes.Pen;\n              break;\n          }\n          if (pointerType === PointerTypes.Touch) {\n            if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n              thisEventKey = \"TouchStart\";\n            } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n              thisEventKey = \"TouchEnd\";\n            }\n          } else if (pointerType === PointerTypes.Pen)\n            ;\n        } else if (legacy_isTouchEvent(event)) {\n          pointerType = PointerTypes.Touch;\n        }\n        if (pointerType !== null) {\n          currentPointerType = pointerType;\n          if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n            pointerType = null;\n          }\n        } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n          pointerType = currentPointerType;\n          currentPointerType = null;\n        }\n        const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n        if (!e2) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        const { clientX, clientY } = e2;\n        callbackWrapper(mouseInteractionCb)({\n          type: MouseInteractions[thisEventKey],\n          id,\n          x: clientX,\n          y: clientY,\n          ...pointerType !== null && { pointerType }\n        });\n      };\n    };\n    Object.keys(MouseInteractions).filter((key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false).forEach((eventKey) => {\n      let eventName = toLowerCase(eventKey);\n      const handler = getHandler(eventKey);\n      if (window.PointerEvent) {\n        switch (MouseInteractions[eventKey]) {\n          case MouseInteractions.MouseDown:\n          case MouseInteractions.MouseUp:\n            eventName = eventName.replace(\"mouse\", \"pointer\");\n            break;\n          case MouseInteractions.TouchStart:\n          case MouseInteractions.TouchEnd:\n            return;\n        }\n      }\n      handlers4.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(() => {\n      handlers4.forEach((h) => h());\n    });\n  }\n  function initScrollObserver({ scrollCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, sampling }) {\n    const updatePosition = callbackWrapper(throttle$1(callbackWrapper((evt) => {\n      const target = getEventTarget2(evt);\n      if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      if (target === doc && doc.defaultView) {\n        const scrollLeftTop = getWindowScroll2(doc.defaultView);\n        scrollCb({\n          id,\n          x: scrollLeftTop.left,\n          y: scrollLeftTop.top\n        });\n      } else {\n        scrollCb({\n          id,\n          x: target.scrollLeft,\n          y: target.scrollTop\n        });\n      }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n  }\n  function initViewportResizeObserver({ viewportResizeCb }, { win }) {\n    let lastH = -1;\n    let lastW = -1;\n    const updateDimension = callbackWrapper(throttle$1(callbackWrapper(() => {\n      const height = getWindowHeight();\n      const width = getWindowWidth();\n      if (lastH !== height || lastW !== width) {\n        viewportResizeCb({\n          width: Number(width),\n          height: Number(height)\n        });\n        lastH = height;\n        lastW = width;\n      }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n  }\n  var INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\n  var lastInputValueMap = /* @__PURE__ */ new WeakMap();\n  function initInputObserver({ inputCb, doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, maskTextClass, unmaskTextClass, maskTextSelector, unmaskTextSelector }) {\n    function eventHandler(event) {\n      let target = getEventTarget2(event);\n      const userTriggered = event.isTrusted;\n      const tagName = target && toUpperCase(target.tagName);\n      if (tagName === \"OPTION\")\n        target = target.parentElement;\n      if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      const el = target;\n      if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n        return;\n      }\n      const type = getInputType(target);\n      let text = getInputValue(el, tagName, type);\n      let isChecked = false;\n      const isInputMasked = shouldMaskInput({\n        maskInputOptions,\n        tagName,\n        type\n      });\n      const forceMask = needMaskingText(target, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, isInputMasked);\n      if (type === \"radio\" || type === \"checkbox\") {\n        isChecked = target.checked;\n      }\n      text = maskInputValue({\n        isMasked: forceMask,\n        element: target,\n        value: text,\n        maskInputFn\n      });\n      cbWithDedup(target, userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked });\n      const name2 = target.name;\n      if (type === \"radio\" && name2 && isChecked) {\n        doc.querySelectorAll(`input[type=\"radio\"][name=\"${name2}\"]`).forEach((el2) => {\n          if (el2 !== target) {\n            const text2 = maskInputValue({\n              isMasked: forceMask,\n              element: el2,\n              value: getInputValue(el2, tagName, type),\n              maskInputFn\n            });\n            cbWithDedup(el2, userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked });\n          }\n        });\n      }\n    }\n    function cbWithDedup(target, v) {\n      const lastInputValue = lastInputValueMap.get(target);\n      if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {\n        lastInputValueMap.set(target, v);\n        const id = mirror2.getId(target);\n        callbackWrapper(inputCb)({\n          ...v,\n          id\n        });\n      }\n    }\n    const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n    const handlers4 = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));\n    const currentWindow = doc.defaultView;\n    if (!currentWindow) {\n      return () => {\n        handlers4.forEach((h) => h());\n      };\n    }\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    const hookProperties = [\n      [currentWindow.HTMLInputElement.prototype, \"value\"],\n      [currentWindow.HTMLInputElement.prototype, \"checked\"],\n      [currentWindow.HTMLSelectElement.prototype, \"value\"],\n      [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n      [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n      [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n      handlers4.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {\n        set() {\n          callbackWrapper(eventHandler)({\n            target: this,\n            isTrusted: false\n          });\n        }\n      }, false, currentWindow)));\n    }\n    return callbackWrapper(() => {\n      handlers4.forEach((h) => h());\n    });\n  }\n  function getNestedCSSRulePositions(rule) {\n    const positions = [];\n    function recurse(childRule, pos) {\n      if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n        const rules = Array.from(childRule.parentRule.cssRules);\n        const index = rules.indexOf(childRule);\n        pos.unshift(index);\n      } else if (childRule.parentStyleSheet) {\n        const rules = Array.from(childRule.parentStyleSheet.cssRules);\n        const index = rules.indexOf(childRule);\n        pos.unshift(index);\n      }\n      return pos;\n    }\n    return recurse(rule, positions);\n  }\n  function getIdAndStyleId(sheet, mirror2, styleMirror) {\n    let id, styleId;\n    if (!sheet)\n      return {};\n    if (sheet.ownerNode)\n      id = mirror2.getId(sheet.ownerNode);\n    else\n      styleId = styleMirror.getId(sheet);\n    return {\n      styleId,\n      id\n    };\n  }\n  function initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n      return () => {\n      };\n    }\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    let replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n      replace = win.CSSStyleSheet.prototype.replace;\n      win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        })\n      });\n    }\n    let replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n      replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n      win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror);\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        })\n      });\n    }\n    const supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n      supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n      if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n        supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n      }\n      if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n        supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n      }\n      if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n        supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n      }\n    }\n    const unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      unmodifiedFunctions[typeKey] = {\n        insertRule: type.prototype.insertRule,\n        deleteRule: type.prototype.deleteRule\n      };\n      type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\n          const [rule, index] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              adds: [\n                {\n                  rule,\n                  index: [\n                    ...getNestedCSSRulePositions(thisArg),\n                    index || 0\n                  ]\n                }\n              ]\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        })\n      });\n      type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\n          const [index] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror);\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              removes: [\n                { index: [...getNestedCSSRulePositions(thisArg), index] }\n              ]\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        })\n      });\n    });\n    return callbackWrapper(() => {\n      win.CSSStyleSheet.prototype.insertRule = insertRule;\n      win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n      replace && (win.CSSStyleSheet.prototype.replace = replace);\n      replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n      Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n        type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n        type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n      });\n    });\n  }\n  function initAdoptedStyleSheetObserver({ mirror: mirror2, stylesheetManager }, host) {\n    let hostId = null;\n    if (host.nodeName === \"#document\")\n      hostId = mirror2.getId(host);\n    else\n      hostId = mirror2.getId(host.host);\n    const patchTarget = host.nodeName === \"#document\" ? _optionalChain$2([host, \"access\", (_4) => _4.defaultView, \"optionalAccess\", (_5) => _5.Document]) : _optionalChain$2([host, \"access\", (_6) => _6.ownerDocument, \"optionalAccess\", (_7) => _7.defaultView, \"optionalAccess\", (_8) => _8.ShadowRoot]);\n    const originalPropertyDescriptor = _optionalChain$2([patchTarget, \"optionalAccess\", (_9) => _9.prototype]) ? Object.getOwnPropertyDescriptor(_optionalChain$2([patchTarget, \"optionalAccess\", (_10) => _10.prototype]), \"adoptedStyleSheets\") : void 0;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n      return () => {\n      };\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      get() {\n        return _optionalChain$2([originalPropertyDescriptor, \"access\", (_11) => _11.get, \"optionalAccess\", (_12) => _12.call, \"call\", (_13) => _13(this)]);\n      },\n      set(sheets) {\n        const result = _optionalChain$2([originalPropertyDescriptor, \"access\", (_14) => _14.set, \"optionalAccess\", (_15) => _15.call, \"call\", (_16) => _16(this, sheets)]);\n        if (hostId !== null && hostId !== -1) {\n          try {\n            stylesheetManager.adoptStyleSheets(sheets, hostId);\n          } catch (e2) {\n          }\n        }\n        return result;\n      }\n    });\n    return callbackWrapper(() => {\n      Object.defineProperty(host, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get: originalPropertyDescriptor.get,\n        set: originalPropertyDescriptor.set\n      });\n    });\n  }\n  function initStyleDeclarationObserver({ styleDeclarationCb, mirror: mirror2, ignoreCSSAttributes, stylesheetManager }, { win }) {\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(_optionalChain$2([thisArg, \"access\", (_17) => _17.parentRule, \"optionalAccess\", (_18) => _18.parentStyleSheet]), mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n      apply: callbackWrapper((target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(_optionalChain$2([thisArg, \"access\", (_19) => _19.parentRule, \"optionalAccess\", (_20) => _20.parentStyleSheet]), mirror2, stylesheetManager.styleMirror);\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      })\n    });\n    return callbackWrapper(() => {\n      win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n      win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n  }\n  function initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, unblockSelector, mirror: mirror2, sampling, doc }) {\n    const handler = callbackWrapper((type) => throttle$1(callbackWrapper((event) => {\n      const target = getEventTarget2(event);\n      if (!target || isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      const { currentTime, volume, muted, playbackRate } = target;\n      mediaInteractionCb({\n        type,\n        id: mirror2.getId(target),\n        currentTime,\n        volume,\n        muted,\n        playbackRate\n      });\n    }), sampling.media || 500));\n    const handlers4 = [\n      on(\"play\", handler(0), doc),\n      on(\"pause\", handler(1), doc),\n      on(\"seeked\", handler(2), doc),\n      on(\"volumechange\", handler(3), doc),\n      on(\"ratechange\", handler(4), doc)\n    ];\n    return callbackWrapper(() => {\n      handlers4.forEach((h) => h());\n    });\n  }\n  function initFontObserver({ fontCb, doc }) {\n    const win = doc.defaultView;\n    if (!win) {\n      return () => {\n      };\n    }\n    const handlers4 = [];\n    const fontMap = /* @__PURE__ */ new WeakMap();\n    const originalFontFace = win.FontFace;\n    win.FontFace = function FontFace(family, source, descriptors) {\n      const fontFace = new originalFontFace(family, source, descriptors);\n      fontMap.set(fontFace, {\n        family,\n        buffer: typeof source !== \"string\",\n        descriptors,\n        fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n      });\n      return fontFace;\n    };\n    const restoreHandler = patch(doc.fonts, \"add\", function(original) {\n      return function(fontFace) {\n        setTimeout$1(callbackWrapper(() => {\n          const p = fontMap.get(fontFace);\n          if (p) {\n            fontCb(p);\n            fontMap.delete(fontFace);\n          }\n        }), 0);\n        return original.apply(this, [fontFace]);\n      };\n    });\n    handlers4.push(() => {\n      win.FontFace = originalFontFace;\n    });\n    handlers4.push(restoreHandler);\n    return callbackWrapper(() => {\n      handlers4.forEach((h) => h());\n    });\n  }\n  function initSelectionObserver(param) {\n    const { doc, mirror: mirror2, blockClass, blockSelector, unblockSelector, selectionCb } = param;\n    let collapsed = true;\n    const updateSelection = callbackWrapper(() => {\n      const selection = doc.getSelection();\n      if (!selection || collapsed && _optionalChain$2([selection, \"optionalAccess\", (_21) => _21.isCollapsed]))\n        return;\n      collapsed = selection.isCollapsed || false;\n      const ranges = [];\n      const count = selection.rangeCount || 0;\n      for (let i = 0; i < count; i++) {\n        const range = selection.getRangeAt(i);\n        const { startContainer, startOffset, endContainer, endOffset } = range;\n        const blocked = isBlocked(startContainer, blockClass, blockSelector, unblockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, unblockSelector, true);\n        if (blocked)\n          continue;\n        ranges.push({\n          start: mirror2.getId(startContainer),\n          startOffset,\n          end: mirror2.getId(endContainer),\n          endOffset\n        });\n      }\n      selectionCb({ ranges });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n  }\n  function initCustomElementObserver({ doc, customElementCb }) {\n    const win = doc.defaultView;\n    if (!win || !win.customElements)\n      return () => {\n      };\n    const restoreHandler = patch(win.customElements, \"define\", function(original) {\n      return function(name2, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name: name2\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name2, constructor, options]);\n      };\n    });\n    return restoreHandler;\n  }\n  function initObservers(o, _hooks = {}) {\n    const currentWindow = o.doc.defaultView;\n    if (!currentWindow) {\n      return () => {\n      };\n    }\n    const mutationObserver = initMutationObserver(o, o.doc);\n    const mousemoveHandler = initMoveObserver(o);\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\n    const scrollHandler2 = initScrollObserver(o);\n    const viewportResizeHandler = initViewportResizeObserver(o, {\n      win: currentWindow\n    });\n    const inputHandler = initInputObserver(o);\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\n    const styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\n    const adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\n    const styleDeclarationObserver = initStyleDeclarationObserver(o, {\n      win: currentWindow\n    });\n    const fontObserver = o.collectFonts ? initFontObserver(o) : () => {\n    };\n    const selectionObserver = initSelectionObserver(o);\n    const customElementObserver = initCustomElementObserver(o);\n    const pluginHandlers = [];\n    for (const plugin of o.plugins) {\n      pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\n    }\n    return callbackWrapper(() => {\n      mutationBuffers.forEach((b) => b.reset());\n      mutationObserver.disconnect();\n      mousemoveHandler();\n      mouseInteractionHandler();\n      scrollHandler2();\n      viewportResizeHandler();\n      inputHandler();\n      mediaInteractionHandler();\n      styleSheetObserver();\n      adoptedStyleSheetObserver();\n      styleDeclarationObserver();\n      fontObserver();\n      selectionObserver();\n      customElementObserver();\n      pluginHandlers.forEach((h) => h());\n    });\n  }\n  function hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n  }\n  function canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n  }\n  var CrossOriginIframeMirror = class {\n    constructor(generateIdFn) {\n      this.generateIdFn = generateIdFn;\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n    }\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n      const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n      const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n      let id = idToRemoteIdMap.get(remoteId);\n      if (!id) {\n        id = this.generateIdFn();\n        idToRemoteIdMap.set(remoteId, id);\n        remoteIdToIdMap.set(id, remoteId);\n      }\n      return id;\n    }\n    getIds(iframe, remoteId) {\n      const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n      const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n      return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\n    }\n    getRemoteId(iframe, id, map) {\n      const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n      if (typeof id !== \"number\")\n        return id;\n      const remoteId = remoteIdToIdMap.get(id);\n      if (!remoteId)\n        return -1;\n      return remoteId;\n    }\n    getRemoteIds(iframe, ids) {\n      const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n      return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n    }\n    reset(iframe) {\n      if (!iframe) {\n        this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n        this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n        return;\n      }\n      this.iframeIdToRemoteIdMap.delete(iframe);\n      this.iframeRemoteIdToIdMap.delete(iframe);\n    }\n    getIdToRemoteIdMap(iframe) {\n      let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n      if (!idToRemoteIdMap) {\n        idToRemoteIdMap = /* @__PURE__ */ new Map();\n        this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n      }\n      return idToRemoteIdMap;\n    }\n    getRemoteIdToIdMap(iframe) {\n      let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n      if (!remoteIdToIdMap) {\n        remoteIdToIdMap = /* @__PURE__ */ new Map();\n        this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n      }\n      return remoteIdToIdMap;\n    }\n  };\n  function _optionalChain$1(ops) {\n    let lastAccessLHS = void 0;\n    let value = ops[0];\n    let i = 1;\n    while (i < ops.length) {\n      const op = ops[i];\n      const fn2 = ops[i + 1];\n      i += 2;\n      if ((op === \"optionalAccess\" || op === \"optionalCall\") && value == null) {\n        return void 0;\n      }\n      if (op === \"access\" || op === \"optionalAccess\") {\n        lastAccessLHS = value;\n        value = fn2(value);\n      } else if (op === \"call\" || op === \"optionalCall\") {\n        value = fn2((...args) => value.call(lastAccessLHS, ...args));\n        lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  var IframeManagerNoop = class {\n    constructor() {\n      this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n      this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    }\n    addIframe() {\n    }\n    addLoadListener() {\n    }\n    attachIframe() {\n    }\n  };\n  var IframeManager = class {\n    constructor(options) {\n      this.iframes = /* @__PURE__ */ new WeakMap();\n      this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n      this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n      this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n      this.mutationCb = options.mutationCb;\n      this.wrappedEmit = options.wrappedEmit;\n      this.stylesheetManager = options.stylesheetManager;\n      this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n      this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n      this.mirror = options.mirror;\n      if (this.recordCrossOriginIframes) {\n        window.addEventListener(\"message\", this.handleMessage.bind(this));\n      }\n    }\n    addIframe(iframeEl) {\n      this.iframes.set(iframeEl, true);\n      if (iframeEl.contentWindow)\n        this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    }\n    addLoadListener(cb) {\n      this.loadListener = cb;\n    }\n    attachIframe(iframeEl, childSn) {\n      this.mutationCb({\n        adds: [\n          {\n            parentId: this.mirror.getId(iframeEl),\n            nextId: null,\n            node: childSn\n          }\n        ],\n        removes: [],\n        texts: [],\n        attributes: [],\n        isAttachIframe: true\n      });\n      _optionalChain$1([this, \"access\", (_) => _.loadListener, \"optionalCall\", (_2) => _2(iframeEl)]);\n      if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)\n        this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    }\n    handleMessage(message) {\n      const crossOriginMessageEvent = message;\n      if (crossOriginMessageEvent.data.type !== \"rrweb\" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n        return;\n      const iframeSourceWindow = message.source;\n      if (!iframeSourceWindow)\n        return;\n      const iframeEl = this.crossOriginIframeMap.get(message.source);\n      if (!iframeEl)\n        return;\n      const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n      if (transformedEvent)\n        this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    }\n    transformCrossOriginEvent(iframeEl, e2) {\n      switch (e2.type) {\n        case EventType.FullSnapshot: {\n          this.crossOriginIframeMirror.reset(iframeEl);\n          this.crossOriginIframeStyleMirror.reset(iframeEl);\n          this.replaceIdOnNode(e2.data.node, iframeEl);\n          const rootId = e2.data.node.id;\n          this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n          this.patchRootIdOnNode(e2.data.node, rootId);\n          return {\n            timestamp: e2.timestamp,\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Mutation,\n              adds: [\n                {\n                  parentId: this.mirror.getId(iframeEl),\n                  nextId: null,\n                  node: e2.data.node\n                }\n              ],\n              removes: [],\n              texts: [],\n              attributes: [],\n              isAttachIframe: true\n            }\n          };\n        }\n        case EventType.Meta:\n        case EventType.Load:\n        case EventType.DomContentLoaded: {\n          return false;\n        }\n        case EventType.Plugin: {\n          return e2;\n        }\n        case EventType.Custom: {\n          this.replaceIds(e2.data.payload, iframeEl, [\"id\", \"parentId\", \"previousId\", \"nextId\"]);\n          return e2;\n        }\n        case EventType.IncrementalSnapshot: {\n          switch (e2.data.source) {\n            case IncrementalSource.Mutation: {\n              e2.data.adds.forEach((n) => {\n                this.replaceIds(n, iframeEl, [\n                  \"parentId\",\n                  \"nextId\",\n                  \"previousId\"\n                ]);\n                this.replaceIdOnNode(n.node, iframeEl);\n                const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n                rootId && this.patchRootIdOnNode(n.node, rootId);\n              });\n              e2.data.removes.forEach((n) => {\n                this.replaceIds(n, iframeEl, [\"parentId\", \"id\"]);\n              });\n              e2.data.attributes.forEach((n) => {\n                this.replaceIds(n, iframeEl, [\"id\"]);\n              });\n              e2.data.texts.forEach((n) => {\n                this.replaceIds(n, iframeEl, [\"id\"]);\n              });\n              return e2;\n            }\n            case IncrementalSource.Drag:\n            case IncrementalSource.TouchMove:\n            case IncrementalSource.MouseMove: {\n              e2.data.positions.forEach((p) => {\n                this.replaceIds(p, iframeEl, [\"id\"]);\n              });\n              return e2;\n            }\n            case IncrementalSource.ViewportResize: {\n              return false;\n            }\n            case IncrementalSource.MediaInteraction:\n            case IncrementalSource.MouseInteraction:\n            case IncrementalSource.Scroll:\n            case IncrementalSource.CanvasMutation:\n            case IncrementalSource.Input: {\n              this.replaceIds(e2.data, iframeEl, [\"id\"]);\n              return e2;\n            }\n            case IncrementalSource.StyleSheetRule:\n            case IncrementalSource.StyleDeclaration: {\n              this.replaceIds(e2.data, iframeEl, [\"id\"]);\n              this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n              return e2;\n            }\n            case IncrementalSource.Font: {\n              return e2;\n            }\n            case IncrementalSource.Selection: {\n              e2.data.ranges.forEach((range) => {\n                this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n              });\n              return e2;\n            }\n            case IncrementalSource.AdoptedStyleSheet: {\n              this.replaceIds(e2.data, iframeEl, [\"id\"]);\n              this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n              _optionalChain$1([e2, \"access\", (_3) => _3.data, \"access\", (_4) => _4.styles, \"optionalAccess\", (_5) => _5.forEach, \"call\", (_6) => _6((style) => {\n                this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n              })]);\n              return e2;\n            }\n          }\n        }\n      }\n      return false;\n    }\n    replace(iframeMirror, obj, iframeEl, keys) {\n      for (const key of keys) {\n        if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\")\n          continue;\n        if (Array.isArray(obj[key])) {\n          obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n        } else {\n          obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n        }\n      }\n      return obj;\n    }\n    replaceIds(obj, iframeEl, keys) {\n      return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    }\n    replaceStyleIds(obj, iframeEl, keys) {\n      return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    }\n    replaceIdOnNode(node, iframeEl) {\n      this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n      if (\"childNodes\" in node) {\n        node.childNodes.forEach((child) => {\n          this.replaceIdOnNode(child, iframeEl);\n        });\n      }\n    }\n    patchRootIdOnNode(node, rootId) {\n      if (node.type !== NodeType$1.Document && !node.rootId)\n        node.rootId = rootId;\n      if (\"childNodes\" in node) {\n        node.childNodes.forEach((child) => {\n          this.patchRootIdOnNode(child, rootId);\n        });\n      }\n    }\n  };\n  var ShadowDomManagerNoop = class {\n    init() {\n    }\n    addShadowRoot() {\n    }\n    observeAttachShadow() {\n    }\n    reset() {\n    }\n  };\n  var ShadowDomManager = class {\n    constructor(options) {\n      this.shadowDoms = /* @__PURE__ */ new WeakSet();\n      this.restoreHandlers = [];\n      this.mutationCb = options.mutationCb;\n      this.scrollCb = options.scrollCb;\n      this.bypassOptions = options.bypassOptions;\n      this.mirror = options.mirror;\n      this.init();\n    }\n    init() {\n      this.reset();\n      this.patchAttachShadow(Element, document);\n    }\n    addShadowRoot(shadowRoot, doc) {\n      if (!isNativeShadowDom(shadowRoot))\n        return;\n      if (this.shadowDoms.has(shadowRoot))\n        return;\n      this.shadowDoms.add(shadowRoot);\n      const observer = initMutationObserver({\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      }, shadowRoot);\n      this.restoreHandlers.push(() => observer.disconnect());\n      this.restoreHandlers.push(initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        doc: shadowRoot,\n        mirror: this.mirror\n      }));\n      setTimeout$1(() => {\n        if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n          this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\n        this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n          mirror: this.mirror,\n          stylesheetManager: this.bypassOptions.stylesheetManager\n        }, shadowRoot));\n      }, 0);\n    }\n    observeAttachShadow(iframeElement) {\n      if (!iframeElement.contentWindow || !iframeElement.contentDocument)\n        return;\n      this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    }\n    patchAttachShadow(element, doc) {\n      const manager = this;\n      this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function(original) {\n        return function(option) {\n          const shadowRoot = original.call(this, option);\n          if (this.shadowRoot && inDom(this))\n            manager.addShadowRoot(this.shadowRoot, doc);\n          return shadowRoot;\n        };\n      }));\n    }\n    reset() {\n      this.restoreHandlers.forEach((handler) => {\n        try {\n          handler();\n        } catch (e2) {\n        }\n      });\n      this.restoreHandlers = [];\n      this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    }\n  };\n  var CanvasManagerNoop = class {\n    reset() {\n    }\n    freeze() {\n    }\n    unfreeze() {\n    }\n    lock() {\n    }\n    unlock() {\n    }\n    snapshot() {\n    }\n  };\n  var StylesheetManager = class {\n    constructor(options) {\n      this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n      this.styleMirror = new StyleSheetMirror();\n      this.mutationCb = options.mutationCb;\n      this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    attachLinkElement(linkEl, childSn) {\n      if (\"_cssText\" in childSn.attributes)\n        this.mutationCb({\n          adds: [],\n          removes: [],\n          texts: [],\n          attributes: [\n            {\n              id: childSn.id,\n              attributes: childSn.attributes\n            }\n          ]\n        });\n      this.trackLinkElement(linkEl);\n    }\n    trackLinkElement(linkEl) {\n      if (this.trackedLinkElements.has(linkEl))\n        return;\n      this.trackedLinkElements.add(linkEl);\n      this.trackStylesheetInLinkElement(linkEl);\n    }\n    adoptStyleSheets(sheets, hostId) {\n      if (sheets.length === 0)\n        return;\n      const adoptedStyleSheetData = {\n        id: hostId,\n        styleIds: []\n      };\n      const styles = [];\n      for (const sheet of sheets) {\n        let styleId;\n        if (!this.styleMirror.has(sheet)) {\n          styleId = this.styleMirror.add(sheet);\n          styles.push({\n            styleId,\n            rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n              rule: stringifyRule(r2),\n              index\n            }))\n          });\n        } else\n          styleId = this.styleMirror.getId(sheet);\n        adoptedStyleSheetData.styleIds.push(styleId);\n      }\n      if (styles.length > 0)\n        adoptedStyleSheetData.styles = styles;\n      this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    }\n    reset() {\n      this.styleMirror.reset();\n      this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    }\n    trackStylesheetInLinkElement(linkEl) {\n    }\n  };\n  var ProcessedNodeManager = class {\n    constructor() {\n      this.nodeMap = /* @__PURE__ */ new WeakMap();\n      this.loop = true;\n      this.periodicallyClear();\n    }\n    periodicallyClear() {\n      onRequestAnimationFrame(() => {\n        this.clear();\n        if (this.loop)\n          this.periodicallyClear();\n      });\n    }\n    inOtherBuffer(node, thisBuffer) {\n      const buffers = this.nodeMap.get(node);\n      return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n    }\n    add(node, buffer) {\n      this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n    }\n    clear() {\n      this.nodeMap = /* @__PURE__ */ new WeakMap();\n    }\n    destroy() {\n      this.loop = false;\n    }\n  };\n  var wrappedEmit;\n  var _takeFullSnapshot;\n  var mirror = createMirror();\n  function record(options = {}) {\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = \"rr-block\", blockSelector = null, unblockSelector = null, ignoreClass = \"rr-ignore\", ignoreSelector = null, maskAllText = false, maskTextClass = \"rr-mask\", unmaskTextClass = null, maskTextSelector = null, unmaskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskAttributeFn, maskInputFn, maskTextFn, maxCanvasSize = null, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\", userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = /* @__PURE__ */ new Set([]), errorHandler: errorHandler2, onMutation, getCanvasManager } = options;\n    registerErrorHandler(errorHandler2);\n    const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    let passEmitsToParent = false;\n    if (!inEmittingFrame) {\n      try {\n        if (window.parent.document) {\n          passEmitsToParent = false;\n        }\n      } catch (e2) {\n        passEmitsToParent = true;\n      }\n    }\n    if (inEmittingFrame && !emit) {\n      throw new Error(\"emit function is required\");\n    }\n    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n      sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    const maskInputOptions = maskAllInputs === true ? {\n      color: true,\n      date: true,\n      \"datetime-local\": true,\n      email: true,\n      month: true,\n      number: true,\n      range: true,\n      search: true,\n      tel: true,\n      text: true,\n      time: true,\n      url: true,\n      week: true,\n      textarea: true,\n      select: true,\n      radio: true,\n      checkbox: true\n    } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaVerification: true,\n      headMetaAuthorship: _slimDOMOptions === \"all\",\n      headMetaDescKeywords: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill();\n    let lastFullSnapshotEvent;\n    let incrementalSnapshotCount = 0;\n    const eventProcessor = (e2) => {\n      for (const plugin of plugins || []) {\n        if (plugin.eventProcessor) {\n          e2 = plugin.eventProcessor(e2);\n        }\n      }\n      if (packFn && !passEmitsToParent) {\n        e2 = packFn(e2);\n      }\n      return e2;\n    };\n    wrappedEmit = (r2, isCheckout) => {\n      const e2 = r2;\n      e2.timestamp = nowTimestamp();\n      if (_optionalChain([mutationBuffers, \"access\", (_) => _[0], \"optionalAccess\", (_2) => _2.isFrozen, \"call\", (_3) => _3()]) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n        mutationBuffers.forEach((buf) => buf.unfreeze());\n      }\n      if (inEmittingFrame) {\n        _optionalChain([emit, \"optionalCall\", (_4) => _4(eventProcessor(e2), isCheckout)]);\n      } else if (passEmitsToParent) {\n        const message = {\n          type: \"rrweb\",\n          event: eventProcessor(e2),\n          origin: window.location.origin,\n          isCheckout\n        };\n        window.parent.postMessage(message, \"*\");\n      }\n      if (e2.type === EventType.FullSnapshot) {\n        lastFullSnapshotEvent = e2;\n        incrementalSnapshotCount = 0;\n      } else if (e2.type === EventType.IncrementalSnapshot) {\n        if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n          return;\n        }\n        incrementalSnapshotCount++;\n        const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n        const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n        if (exceedCount || exceedTime) {\n          takeFullSnapshot2(true);\n        }\n      }\n    };\n    const wrappedMutationEmit = (m) => {\n      wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.Mutation,\n          ...m\n        }\n      });\n    };\n    const wrappedScrollEmit = (p) => wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Scroll,\n        ...p\n      }\n    });\n    const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.CanvasMutation,\n        ...p\n      }\n    });\n    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.AdoptedStyleSheet,\n        ...a\n      }\n    });\n    const stylesheetManager = new StylesheetManager({\n      mutationCb: wrappedMutationEmit,\n      adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n      mirror,\n      mutationCb: wrappedMutationEmit,\n      stylesheetManager,\n      recordCrossOriginIframes,\n      wrappedEmit\n    });\n    for (const plugin of plugins || []) {\n      if (plugin.getMirror)\n        plugin.getMirror({\n          nodeMirror: mirror,\n          crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n          crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    const processedNodeManager = new ProcessedNodeManager();\n    const canvasManager = _getCanvasManager(getCanvasManager, {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    });\n    const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n      mutationCb: wrappedMutationEmit,\n      scrollCb: wrappedScrollEmit,\n      bypassOptions: {\n        onMutation,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        inlineStylesheet,\n        maskInputOptions,\n        dataURLOptions,\n        maskAttributeFn,\n        maskTextFn,\n        maskInputFn,\n        recordCanvas,\n        inlineImages,\n        sampling,\n        slimDOMOptions,\n        iframeManager,\n        stylesheetManager,\n        canvasManager,\n        keepIframeSrcFn,\n        processedNodeManager\n      },\n      mirror\n    });\n    const takeFullSnapshot2 = (isCheckout = false) => {\n      wrappedEmit({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      }, isCheckout);\n      stylesheetManager.reset();\n      shadowDomManager.init();\n      mutationBuffers.forEach((buf) => buf.lock());\n      const node = snapshot(document, {\n        mirror,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        inlineStylesheet,\n        maskAllInputs: maskInputOptions,\n        maskAttributeFn,\n        maskInputFn,\n        maskTextFn,\n        slimDOM: slimDOMOptions,\n        dataURLOptions,\n        recordCanvas,\n        inlineImages,\n        onSerialize: (n) => {\n          if (isSerializedIframe(n, mirror)) {\n            iframeManager.addIframe(n);\n          }\n          if (isSerializedStylesheet(n, mirror)) {\n            stylesheetManager.trackLinkElement(n);\n          }\n          if (hasShadowRoot(n)) {\n            shadowDomManager.addShadowRoot(n.shadowRoot, document);\n          }\n        },\n        onIframeLoad: (iframe, childSn) => {\n          iframeManager.attachIframe(iframe, childSn);\n          shadowDomManager.observeAttachShadow(iframe);\n        },\n        onStylesheetLoad: (linkEl, childSn) => {\n          stylesheetManager.attachLinkElement(linkEl, childSn);\n        },\n        keepIframeSrcFn\n      });\n      if (!node) {\n        return console.warn(\"Failed to snapshot the document\");\n      }\n      wrappedEmit({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: getWindowScroll2(window)\n        }\n      });\n      mutationBuffers.forEach((buf) => buf.unlock());\n      if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n        stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    _takeFullSnapshot = takeFullSnapshot2;\n    try {\n      const handlers4 = [];\n      const observe2 = (doc) => {\n        return callbackWrapper(initObservers)({\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: _optionalChain([\n            plugins,\n            \"optionalAccess\",\n            (_5) => _5.filter,\n            \"call\",\n            (_6) => _6((p) => p.observer),\n            \"optionalAccess\",\n            (_7) => _7.map,\n            \"call\",\n            (_8) => _8((p) => ({\n              observer: p.observer,\n              options: p.options,\n              callback: (payload) => wrappedEmit({\n                type: EventType.Plugin,\n                data: {\n                  plugin: p.name,\n                  payload\n                }\n              })\n            }))\n          ]) || []\n        }, {});\n      };\n      iframeManager.addLoadListener((iframeEl) => {\n        try {\n          handlers4.push(observe2(iframeEl.contentDocument));\n        } catch (error) {\n          console.warn(error);\n        }\n      });\n      const init2 = () => {\n        takeFullSnapshot2();\n        handlers4.push(observe2(document));\n      };\n      if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n        init2();\n      } else {\n        handlers4.push(on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\")\n            init2();\n        }));\n        handlers4.push(on(\"load\", () => {\n          wrappedEmit({\n            type: EventType.Load,\n            data: {}\n          });\n          if (recordAfter === \"load\")\n            init2();\n        }, window));\n      }\n      return () => {\n        handlers4.forEach((h) => h());\n        processedNodeManager.destroy();\n        _takeFullSnapshot = void 0;\n        unregisterErrorHandler();\n      };\n    } catch (error) {\n      console.warn(error);\n    }\n  }\n  function takeFullSnapshot(isCheckout) {\n    if (!_takeFullSnapshot) {\n      throw new Error(\"please take full snapshot after start recording\");\n    }\n    _takeFullSnapshot(isCheckout);\n  }\n  record.mirror = mirror;\n  record.takeFullSnapshot = takeFullSnapshot;\n  function _getCanvasManager(getCanvasManagerFn, options) {\n    try {\n      return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n    } catch (e2) {\n      console.warn(\"Unable to initialize CanvasManager\");\n      return new CanvasManagerNoop();\n    }\n  }\n  var ReplayEventTypeIncrementalSnapshot = 3;\n  var ReplayEventTypeCustom = 5;\n  function timestampToMs(timestamp) {\n    const isMs = timestamp > 9999999999;\n    return isMs ? timestamp : timestamp * 1e3;\n  }\n  function timestampToS(timestamp) {\n    const isMs = timestamp > 9999999999;\n    return isMs ? timestamp / 1e3 : timestamp;\n  }\n  function addBreadcrumbEvent(replay, breadcrumb) {\n    if (breadcrumb.category === \"sentry.transaction\") {\n      return;\n    }\n    if ([\"ui.click\", \"ui.input\"].includes(breadcrumb.category)) {\n      replay.triggerUserActivity();\n    } else {\n      replay.checkAndHandleExpiredSession();\n    }\n    replay.addUpdate(() => {\n      replay.throttledAddEvent({\n        type: EventType.Custom,\n        // TODO: We were converting from ms to seconds for breadcrumbs, spans,\n        // but maybe we should just keep them as milliseconds\n        timestamp: (breadcrumb.timestamp || 0) * 1e3,\n        data: {\n          tag: \"breadcrumb\",\n          // normalize to max. 10 depth and 1_000 properties per object\n          payload: normalize(breadcrumb, 10, 1e3)\n        }\n      });\n      return breadcrumb.category === \"console\";\n    });\n  }\n  var INTERACTIVE_SELECTOR = \"button,a\";\n  function getClosestInteractive(element) {\n    const closestInteractive = element.closest(INTERACTIVE_SELECTOR);\n    return closestInteractive || element;\n  }\n  function getClickTargetNode(event) {\n    const target = getTargetNode(event);\n    if (!target || !(target instanceof Element)) {\n      return target;\n    }\n    return getClosestInteractive(target);\n  }\n  function getTargetNode(event) {\n    if (isEventWithTarget(event)) {\n      return event.target;\n    }\n    return event;\n  }\n  function isEventWithTarget(event) {\n    return typeof event === \"object\" && !!event && \"target\" in event;\n  }\n  var handlers3;\n  function onWindowOpen(cb) {\n    if (!handlers3) {\n      handlers3 = [];\n      monkeyPatchWindowOpen();\n    }\n    handlers3.push(cb);\n    return () => {\n      const pos = handlers3 ? handlers3.indexOf(cb) : -1;\n      if (pos > -1) {\n        handlers3.splice(pos, 1);\n      }\n    };\n  }\n  function monkeyPatchWindowOpen() {\n    fill(WINDOW6, \"open\", function(originalWindowOpen) {\n      return function(...args) {\n        if (handlers3) {\n          try {\n            handlers3.forEach((handler) => handler());\n          } catch (e2) {\n          }\n        }\n        return originalWindowOpen.apply(WINDOW6, args);\n      };\n    });\n  }\n  function handleClick(clickDetector, clickBreadcrumb, node) {\n    clickDetector.handleClick(clickBreadcrumb, node);\n  }\n  var ClickDetector = class {\n    // protected for testing\n    constructor(replay, slowClickConfig, _addBreadcrumbEvent = addBreadcrumbEvent) {\n      this._lastMutation = 0;\n      this._lastScroll = 0;\n      this._clicks = [];\n      this._timeout = slowClickConfig.timeout / 1e3;\n      this._threshold = slowClickConfig.threshold / 1e3;\n      this._scollTimeout = slowClickConfig.scrollTimeout / 1e3;\n      this._replay = replay;\n      this._ignoreSelector = slowClickConfig.ignoreSelector;\n      this._addBreadcrumbEvent = _addBreadcrumbEvent;\n    }\n    /** Register click detection handlers on mutation or scroll. */\n    addListeners() {\n      const cleanupWindowOpen = onWindowOpen(() => {\n        this._lastMutation = nowInSeconds();\n      });\n      this._teardown = () => {\n        cleanupWindowOpen();\n        this._clicks = [];\n        this._lastMutation = 0;\n        this._lastScroll = 0;\n      };\n    }\n    /** Clean up listeners. */\n    removeListeners() {\n      if (this._teardown) {\n        this._teardown();\n      }\n      if (this._checkClickTimeout) {\n        clearTimeout(this._checkClickTimeout);\n      }\n    }\n    /** @inheritDoc */\n    handleClick(breadcrumb, node) {\n      if (ignoreElement(node, this._ignoreSelector) || !isClickBreadcrumb(breadcrumb)) {\n        return;\n      }\n      const newClick = {\n        timestamp: timestampToS(breadcrumb.timestamp),\n        clickBreadcrumb: breadcrumb,\n        // Set this to 0 so we know it originates from the click breadcrumb\n        clickCount: 0,\n        node\n      };\n      if (this._clicks.some((click) => click.node === newClick.node && Math.abs(click.timestamp - newClick.timestamp) < 1)) {\n        return;\n      }\n      this._clicks.push(newClick);\n      if (this._clicks.length === 1) {\n        this._scheduleCheckClicks();\n      }\n    }\n    /** @inheritDoc */\n    registerMutation(timestamp = Date.now()) {\n      this._lastMutation = timestampToS(timestamp);\n    }\n    /** @inheritDoc */\n    registerScroll(timestamp = Date.now()) {\n      this._lastScroll = timestampToS(timestamp);\n    }\n    /** @inheritDoc */\n    registerClick(element) {\n      const node = getClosestInteractive(element);\n      this._handleMultiClick(node);\n    }\n    /** Count multiple clicks on elements. */\n    _handleMultiClick(node) {\n      this._getClicks(node).forEach((click) => {\n        click.clickCount++;\n      });\n    }\n    /** Get all pending clicks for a given node. */\n    _getClicks(node) {\n      return this._clicks.filter((click) => click.node === node);\n    }\n    /** Check the clicks that happened. */\n    _checkClicks() {\n      const timedOutClicks = [];\n      const now = nowInSeconds();\n      this._clicks.forEach((click) => {\n        if (!click.mutationAfter && this._lastMutation) {\n          click.mutationAfter = click.timestamp <= this._lastMutation ? this._lastMutation - click.timestamp : void 0;\n        }\n        if (!click.scrollAfter && this._lastScroll) {\n          click.scrollAfter = click.timestamp <= this._lastScroll ? this._lastScroll - click.timestamp : void 0;\n        }\n        if (click.timestamp + this._timeout <= now) {\n          timedOutClicks.push(click);\n        }\n      });\n      for (const click of timedOutClicks) {\n        const pos = this._clicks.indexOf(click);\n        if (pos > -1) {\n          this._generateBreadcrumbs(click);\n          this._clicks.splice(pos, 1);\n        }\n      }\n      if (this._clicks.length) {\n        this._scheduleCheckClicks();\n      }\n    }\n    /** Generate matching breadcrumb(s) for the click. */\n    _generateBreadcrumbs(click) {\n      const replay = this._replay;\n      const hadScroll = click.scrollAfter && click.scrollAfter <= this._scollTimeout;\n      const hadMutation = click.mutationAfter && click.mutationAfter <= this._threshold;\n      const isSlowClick = !hadScroll && !hadMutation;\n      const { clickCount, clickBreadcrumb } = click;\n      if (isSlowClick) {\n        const timeAfterClickMs = Math.min(click.mutationAfter || this._timeout, this._timeout) * 1e3;\n        const endReason = timeAfterClickMs < this._timeout * 1e3 ? \"mutation\" : \"timeout\";\n        const breadcrumb = {\n          type: \"default\",\n          message: clickBreadcrumb.message,\n          timestamp: clickBreadcrumb.timestamp,\n          category: \"ui.slowClickDetected\",\n          data: {\n            ...clickBreadcrumb.data,\n            url: WINDOW6.location.href,\n            route: replay.getCurrentRoute(),\n            timeAfterClickMs,\n            endReason,\n            // If clickCount === 0, it means multiClick was not correctly captured here\n            // - we still want to send 1 in this case\n            clickCount: clickCount || 1\n          }\n        };\n        this._addBreadcrumbEvent(replay, breadcrumb);\n        return;\n      }\n      if (clickCount > 1) {\n        const breadcrumb = {\n          type: \"default\",\n          message: clickBreadcrumb.message,\n          timestamp: clickBreadcrumb.timestamp,\n          category: \"ui.multiClick\",\n          data: {\n            ...clickBreadcrumb.data,\n            url: WINDOW6.location.href,\n            route: replay.getCurrentRoute(),\n            clickCount,\n            metric: true\n          }\n        };\n        this._addBreadcrumbEvent(replay, breadcrumb);\n      }\n    }\n    /** Schedule to check current clicks. */\n    _scheduleCheckClicks() {\n      if (this._checkClickTimeout) {\n        clearTimeout(this._checkClickTimeout);\n      }\n      this._checkClickTimeout = setTimeout2(() => this._checkClicks(), 1e3);\n    }\n  };\n  var SLOW_CLICK_TAGS = [\"A\", \"BUTTON\", \"INPUT\"];\n  function ignoreElement(node, ignoreSelector) {\n    if (!SLOW_CLICK_TAGS.includes(node.tagName)) {\n      return true;\n    }\n    if (node.tagName === \"INPUT\" && ![\"submit\", \"button\"].includes(node.getAttribute(\"type\") || \"\")) {\n      return true;\n    }\n    if (node.tagName === \"A\" && (node.hasAttribute(\"download\") || node.hasAttribute(\"target\") && node.getAttribute(\"target\") !== \"_self\")) {\n      return true;\n    }\n    if (ignoreSelector && node.matches(ignoreSelector)) {\n      return true;\n    }\n    return false;\n  }\n  function isClickBreadcrumb(breadcrumb) {\n    return !!(breadcrumb.data && typeof breadcrumb.data.nodeId === \"number\" && breadcrumb.timestamp);\n  }\n  function nowInSeconds() {\n    return Date.now() / 1e3;\n  }\n  function updateClickDetectorForRecordingEvent(clickDetector, event) {\n    try {\n      if (!isIncrementalEvent(event)) {\n        return;\n      }\n      const { source } = event.data;\n      if (source === IncrementalSource.Mutation) {\n        clickDetector.registerMutation(event.timestamp);\n      }\n      if (source === IncrementalSource.Scroll) {\n        clickDetector.registerScroll(event.timestamp);\n      }\n      if (isIncrementalMouseInteraction(event)) {\n        const { type, id } = event.data;\n        const node = record.mirror.getNode(id);\n        if (node instanceof HTMLElement && type === MouseInteractions.Click) {\n          clickDetector.registerClick(node);\n        }\n      }\n    } catch (e2) {\n    }\n  }\n  function isIncrementalEvent(event) {\n    return event.type === ReplayEventTypeIncrementalSnapshot;\n  }\n  function isIncrementalMouseInteraction(event) {\n    return event.data.source === IncrementalSource.MouseInteraction;\n  }\n  function createBreadcrumb(breadcrumb) {\n    return {\n      timestamp: Date.now() / 1e3,\n      type: \"default\",\n      ...breadcrumb\n    };\n  }\n  var NodeType;\n  (function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  })(NodeType || (NodeType = {}));\n  var ATTRIBUTES_TO_RECORD = /* @__PURE__ */ new Set([\n    \"id\",\n    \"class\",\n    \"aria-label\",\n    \"role\",\n    \"name\",\n    \"alt\",\n    \"title\",\n    \"data-test-id\",\n    \"data-testid\",\n    \"disabled\",\n    \"aria-disabled\",\n    \"data-sentry-component\"\n  ]);\n  function getAttributesToRecord(attributes) {\n    const obj = {};\n    if (!attributes[\"data-sentry-component\"] && attributes[\"data-sentry-element\"]) {\n      attributes[\"data-sentry-component\"] = attributes[\"data-sentry-element\"];\n    }\n    for (const key in attributes) {\n      if (ATTRIBUTES_TO_RECORD.has(key)) {\n        let normalizedKey = key;\n        if (key === \"data-testid\" || key === \"data-test-id\") {\n          normalizedKey = \"testId\";\n        }\n        obj[normalizedKey] = attributes[key];\n      }\n    }\n    return obj;\n  }\n  var handleDomListener = (replay) => {\n    return (handlerData) => {\n      if (!replay.isEnabled()) {\n        return;\n      }\n      const result = handleDom(handlerData);\n      if (!result) {\n        return;\n      }\n      const isClick = handlerData.name === \"click\";\n      const event = isClick ? handlerData.event : void 0;\n      if (isClick && replay.clickDetector && event && event.target && !event.altKey && !event.metaKey && !event.ctrlKey && !event.shiftKey) {\n        handleClick(\n          replay.clickDetector,\n          result,\n          getClickTargetNode(handlerData.event)\n        );\n      }\n      addBreadcrumbEvent(replay, result);\n    };\n  };\n  function getBaseDomBreadcrumb(target, message) {\n    const nodeId = record.mirror.getId(target);\n    const node = nodeId && record.mirror.getNode(nodeId);\n    const meta = node && record.mirror.getMeta(node);\n    const element = meta && isElement4(meta) ? meta : null;\n    return {\n      message,\n      data: element ? {\n        nodeId,\n        node: {\n          id: nodeId,\n          tagName: element.tagName,\n          textContent: Array.from(element.childNodes).map((node2) => node2.type === NodeType.Text && node2.textContent).filter(Boolean).map((text) => text.trim()).join(\"\"),\n          attributes: getAttributesToRecord(element.attributes)\n        }\n      } : {}\n    };\n  }\n  function handleDom(handlerData) {\n    const { target, message } = getDomTarget(handlerData);\n    return createBreadcrumb({\n      category: `ui.${handlerData.name}`,\n      ...getBaseDomBreadcrumb(target, message)\n    });\n  }\n  function getDomTarget(handlerData) {\n    const isClick = handlerData.name === \"click\";\n    let message;\n    let target = null;\n    try {\n      target = isClick ? getClickTargetNode(handlerData.event) : getTargetNode(handlerData.event);\n      message = htmlTreeAsString(target, { maxStringLength: 200 }) || \"<unknown>\";\n    } catch (e2) {\n      message = \"<unknown>\";\n    }\n    return { target, message };\n  }\n  function isElement4(node) {\n    return node.type === NodeType.Element;\n  }\n  function handleKeyboardEvent(replay, event) {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    replay.updateUserActivity();\n    const breadcrumb = getKeyboardBreadcrumb(event);\n    if (!breadcrumb) {\n      return;\n    }\n    addBreadcrumbEvent(replay, breadcrumb);\n  }\n  function getKeyboardBreadcrumb(event) {\n    const { metaKey, shiftKey, ctrlKey, altKey, key, target } = event;\n    if (!target || isInputElement(target) || !key) {\n      return null;\n    }\n    const hasModifierKey = metaKey || ctrlKey || altKey;\n    const isCharacterKey = key.length === 1;\n    if (!hasModifierKey && isCharacterKey) {\n      return null;\n    }\n    const message = htmlTreeAsString(target, { maxStringLength: 200 }) || \"<unknown>\";\n    const baseBreadcrumb = getBaseDomBreadcrumb(target, message);\n    return createBreadcrumb({\n      category: \"ui.keyDown\",\n      message,\n      data: {\n        ...baseBreadcrumb.data,\n        metaKey,\n        shiftKey,\n        ctrlKey,\n        altKey,\n        key\n      }\n    });\n  }\n  function isInputElement(target) {\n    return target.tagName === \"INPUT\" || target.tagName === \"TEXTAREA\" || target.isContentEditable;\n  }\n  var ENTRY_TYPES = {\n    // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n    resource: createResourceEntry,\n    paint: createPaintEntry,\n    // @ts-expect-error TODO: entry type does not fit the create* functions entry type\n    navigation: createNavigationEntry\n  };\n  function webVitalHandler(getter, replay) {\n    return ({ metric }) => void replay.replayPerformanceEntries.push(getter(metric));\n  }\n  function createPerformanceEntries(entries) {\n    return entries.map(createPerformanceEntry).filter(Boolean);\n  }\n  function createPerformanceEntry(entry) {\n    const entryType = ENTRY_TYPES[entry.entryType];\n    if (!entryType) {\n      return null;\n    }\n    return entryType(entry);\n  }\n  function getAbsoluteTime(time) {\n    return ((browserPerformanceTimeOrigin || WINDOW6.performance.timeOrigin) + time) / 1e3;\n  }\n  function createPaintEntry(entry) {\n    const { duration, entryType, name: name2, startTime } = entry;\n    const start2 = getAbsoluteTime(startTime);\n    return {\n      type: entryType,\n      name: name2,\n      start: start2,\n      end: start2 + duration,\n      data: void 0\n    };\n  }\n  function createNavigationEntry(entry) {\n    const {\n      entryType,\n      name: name2,\n      decodedBodySize,\n      duration,\n      domComplete,\n      encodedBodySize,\n      domContentLoadedEventStart,\n      domContentLoadedEventEnd,\n      domInteractive,\n      loadEventStart,\n      loadEventEnd,\n      redirectCount,\n      startTime,\n      transferSize,\n      type\n    } = entry;\n    if (duration === 0) {\n      return null;\n    }\n    return {\n      type: `${entryType}.${type}`,\n      start: getAbsoluteTime(startTime),\n      end: getAbsoluteTime(domComplete),\n      name: name2,\n      data: {\n        size: transferSize,\n        decodedBodySize,\n        encodedBodySize,\n        duration,\n        domInteractive,\n        domContentLoadedEventStart,\n        domContentLoadedEventEnd,\n        loadEventStart,\n        loadEventEnd,\n        domComplete,\n        redirectCount\n      }\n    };\n  }\n  function createResourceEntry(entry) {\n    const {\n      entryType,\n      initiatorType,\n      name: name2,\n      responseEnd,\n      startTime,\n      decodedBodySize,\n      encodedBodySize,\n      responseStatus,\n      transferSize\n    } = entry;\n    if ([\"fetch\", \"xmlhttprequest\"].includes(initiatorType)) {\n      return null;\n    }\n    return {\n      type: `${entryType}.${initiatorType}`,\n      start: getAbsoluteTime(startTime),\n      end: getAbsoluteTime(responseEnd),\n      name: name2,\n      data: {\n        size: transferSize,\n        statusCode: responseStatus,\n        decodedBodySize,\n        encodedBodySize\n      }\n    };\n  }\n  function getLargestContentfulPaint(metric) {\n    const lastEntry = metric.entries[metric.entries.length - 1];\n    const node = lastEntry ? lastEntry.element : void 0;\n    return getWebVital(metric, \"largest-contentful-paint\", node);\n  }\n  function getCumulativeLayoutShift(metric) {\n    const firstEntry = metric.entries[0];\n    const node = firstEntry ? firstEntry.sources && firstEntry.sources[0] ? firstEntry.sources[0].node : void 0 : void 0;\n    return getWebVital(metric, \"cumulative-layout-shift\", node);\n  }\n  function getFirstInputDelay(metric) {\n    const lastEntry = metric.entries[metric.entries.length - 1];\n    const node = lastEntry ? lastEntry.target : void 0;\n    return getWebVital(metric, \"first-input-delay\", node);\n  }\n  function getInteractionToNextPaint(metric) {\n    const lastEntry = metric.entries[metric.entries.length - 1];\n    const node = lastEntry ? lastEntry.target : void 0;\n    return getWebVital(metric, \"interaction-to-next-paint\", node);\n  }\n  function getWebVital(metric, name2, node) {\n    const value = metric.value;\n    const rating = metric.rating;\n    const end2 = getAbsoluteTime(value);\n    const data = {\n      type: \"web-vital\",\n      name: name2,\n      start: end2,\n      end: end2,\n      data: {\n        value,\n        size: value,\n        rating,\n        nodeId: node ? record.mirror.getId(node) : void 0\n      }\n    };\n    return data;\n  }\n  function setupPerformanceObserver(replay) {\n    function addPerformanceEntry(entry) {\n      if (!replay.performanceEntries.includes(entry)) {\n        replay.performanceEntries.push(entry);\n      }\n    }\n    function onEntries({ entries }) {\n      entries.forEach(addPerformanceEntry);\n    }\n    const clearCallbacks = [];\n    [\"navigation\", \"paint\", \"resource\"].forEach((type) => {\n      clearCallbacks.push(addPerformanceInstrumentationHandler(type, onEntries));\n    });\n    clearCallbacks.push(\n      addLcpInstrumentationHandler(webVitalHandler(getLargestContentfulPaint, replay)),\n      addClsInstrumentationHandler(webVitalHandler(getCumulativeLayoutShift, replay)),\n      addFidInstrumentationHandler(webVitalHandler(getFirstInputDelay, replay)),\n      addInpInstrumentationHandler(webVitalHandler(getInteractionToNextPaint, replay))\n    );\n    return () => {\n      clearCallbacks.forEach((clearCallback) => clearCallback());\n    };\n  }\n  var DEBUG_BUILD5 = typeof __SENTRY_DEBUG__ === \"undefined\" || __SENTRY_DEBUG__;\n  var r = `var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}},L=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},O=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},j=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},q=function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&j(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}},B=function(t){return 10+(t.filename?t.filename.length+1:0)},G=function(){function n(n,r){if(\"function\"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(O(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();var H=function(){function t(t,n){this.c=L(),this.v=1,G.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),G.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=O(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=L();i.p(n.dictionary),j(t,2,i.d())}}(r,this.o),this.v=0),n&&j(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),J=\"undefined\"!=typeof TextEncoder&&new TextEncoder,K=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{K.decode(F,{stream:!0})}catch(t){}var N=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(P(t),this.d=n||!1)},t}();function P(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(J)return J.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}function Q(t){return function(t,n){n||(n={});var r=S(),e=t.length;r.p(t);var i=O(t,n,B(n),8),a=i.length;return q(i,n),j(i,a-8,r.d()),j(i,a-4,e),i}(P(t))}const R=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error(\"Adding invalid event\");const n=this._hasEvents?\",\":\"\";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push(\"]\",!0);const t=function(t){let n=0;for(const r of t)n+=r.length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new H,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new N(((t,n)=>{this.deflate.push(t,n)})),this.stream.push(\"[\")}},V={clear:()=>{R.clear()},addEvent:t=>R.addEvent(t),finish:()=>R.finish(),compress:t=>Q(t)};addEventListener(\"message\",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in V&&\"function\"==typeof V[n])try{const t=V[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:\"init\",success:!0,response:void 0});`;\n  function e() {\n    const e2 = new Blob([r]);\n    return URL.createObjectURL(e2);\n  }\n  function logInfo(message, shouldAddBreadcrumb) {\n    if (!DEBUG_BUILD5) {\n      return;\n    }\n    logger.info(message);\n    if (shouldAddBreadcrumb) {\n      addLogBreadcrumb(message);\n    }\n  }\n  function logInfoNextTick(message, shouldAddBreadcrumb) {\n    if (!DEBUG_BUILD5) {\n      return;\n    }\n    logger.info(message);\n    if (shouldAddBreadcrumb) {\n      setTimeout2(() => {\n        addLogBreadcrumb(message);\n      }, 0);\n    }\n  }\n  function addLogBreadcrumb(message) {\n    addBreadcrumb(\n      {\n        category: \"console\",\n        data: {\n          logger: \"replay\"\n        },\n        level: \"info\",\n        message\n      },\n      { level: \"info\" }\n    );\n  }\n  var EventBufferSizeExceededError = class extends Error {\n    constructor() {\n      super(`Event buffer exceeded maximum size of ${REPLAY_MAX_EVENT_BUFFER_SIZE}.`);\n    }\n  };\n  var EventBufferArray = class {\n    /** All the events that are buffered to be sent. */\n    /** @inheritdoc */\n    constructor() {\n      this.events = [];\n      this._totalSize = 0;\n      this.hasCheckout = false;\n    }\n    /** @inheritdoc */\n    get hasEvents() {\n      return this.events.length > 0;\n    }\n    /** @inheritdoc */\n    get type() {\n      return \"sync\";\n    }\n    /** @inheritdoc */\n    destroy() {\n      this.events = [];\n    }\n    /** @inheritdoc */\n    async addEvent(event) {\n      const eventSize = JSON.stringify(event).length;\n      this._totalSize += eventSize;\n      if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n        throw new EventBufferSizeExceededError();\n      }\n      this.events.push(event);\n    }\n    /** @inheritdoc */\n    finish() {\n      return new Promise((resolve) => {\n        const eventsRet = this.events;\n        this.clear();\n        resolve(JSON.stringify(eventsRet));\n      });\n    }\n    /** @inheritdoc */\n    clear() {\n      this.events = [];\n      this._totalSize = 0;\n      this.hasCheckout = false;\n    }\n    /** @inheritdoc */\n    getEarliestTimestamp() {\n      const timestamp = this.events.map((event) => event.timestamp).sort()[0];\n      if (!timestamp) {\n        return null;\n      }\n      return timestampToMs(timestamp);\n    }\n  };\n  var WorkerHandler = class {\n    constructor(worker) {\n      this._worker = worker;\n      this._id = 0;\n    }\n    /**\n     * Ensure the worker is ready (or not).\n     * This will either resolve when the worker is ready, or reject if an error occured.\n     */\n    ensureReady() {\n      if (this._ensureReadyPromise) {\n        return this._ensureReadyPromise;\n      }\n      this._ensureReadyPromise = new Promise((resolve, reject) => {\n        this._worker.addEventListener(\n          \"message\",\n          ({ data }) => {\n            if (data.success) {\n              resolve();\n            } else {\n              reject();\n            }\n          },\n          { once: true }\n        );\n        this._worker.addEventListener(\n          \"error\",\n          (error) => {\n            reject(error);\n          },\n          { once: true }\n        );\n      });\n      return this._ensureReadyPromise;\n    }\n    /**\n     * Destroy the worker.\n     */\n    destroy() {\n      logInfo(\"[Replay] Destroying compression worker\");\n      this._worker.terminate();\n    }\n    /**\n     * Post message to worker and wait for response before resolving promise.\n     */\n    postMessage(method, arg) {\n      const id = this._getAndIncrementId();\n      return new Promise((resolve, reject) => {\n        const listener = ({ data }) => {\n          const response = data;\n          if (response.method !== method) {\n            return;\n          }\n          if (response.id !== id) {\n            return;\n          }\n          this._worker.removeEventListener(\"message\", listener);\n          if (!response.success) {\n            DEBUG_BUILD5 && logger.error(\"[Replay]\", response.response);\n            reject(new Error(\"Error in compression worker\"));\n            return;\n          }\n          resolve(response.response);\n        };\n        this._worker.addEventListener(\"message\", listener);\n        this._worker.postMessage({ id, method, arg });\n      });\n    }\n    /** Get the current ID and increment it for the next call. */\n    _getAndIncrementId() {\n      return this._id++;\n    }\n  };\n  var EventBufferCompressionWorker = class {\n    /** @inheritdoc */\n    constructor(worker) {\n      this._worker = new WorkerHandler(worker);\n      this._earliestTimestamp = null;\n      this._totalSize = 0;\n      this.hasCheckout = false;\n    }\n    /** @inheritdoc */\n    get hasEvents() {\n      return !!this._earliestTimestamp;\n    }\n    /** @inheritdoc */\n    get type() {\n      return \"worker\";\n    }\n    /**\n     * Ensure the worker is ready (or not).\n     * This will either resolve when the worker is ready, or reject if an error occured.\n     */\n    ensureReady() {\n      return this._worker.ensureReady();\n    }\n    /**\n     * Destroy the event buffer.\n     */\n    destroy() {\n      this._worker.destroy();\n    }\n    /**\n     * Add an event to the event buffer.\n     *\n     * Returns true if event was successfuly received and processed by worker.\n     */\n    addEvent(event) {\n      const timestamp = timestampToMs(event.timestamp);\n      if (!this._earliestTimestamp || timestamp < this._earliestTimestamp) {\n        this._earliestTimestamp = timestamp;\n      }\n      const data = JSON.stringify(event);\n      this._totalSize += data.length;\n      if (this._totalSize > REPLAY_MAX_EVENT_BUFFER_SIZE) {\n        return Promise.reject(new EventBufferSizeExceededError());\n      }\n      return this._sendEventToWorker(data);\n    }\n    /**\n     * Finish the event buffer and return the compressed data.\n     */\n    finish() {\n      return this._finishRequest();\n    }\n    /** @inheritdoc */\n    clear() {\n      this._earliestTimestamp = null;\n      this._totalSize = 0;\n      this.hasCheckout = false;\n      this._worker.postMessage(\"clear\").then(null, (e2) => {\n        DEBUG_BUILD5 && logger.warn('[Replay] Sending \"clear\" message to worker failed', e2);\n      });\n    }\n    /** @inheritdoc */\n    getEarliestTimestamp() {\n      return this._earliestTimestamp;\n    }\n    /**\n     * Send the event to the worker.\n     */\n    _sendEventToWorker(data) {\n      return this._worker.postMessage(\"addEvent\", data);\n    }\n    /**\n     * Finish the request and return the compressed data from the worker.\n     */\n    async _finishRequest() {\n      const response = await this._worker.postMessage(\"finish\");\n      this._earliestTimestamp = null;\n      this._totalSize = 0;\n      return response;\n    }\n  };\n  var EventBufferProxy = class {\n    constructor(worker) {\n      this._fallback = new EventBufferArray();\n      this._compression = new EventBufferCompressionWorker(worker);\n      this._used = this._fallback;\n      this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();\n    }\n    /** @inheritdoc */\n    get type() {\n      return this._used.type;\n    }\n    /** @inheritDoc */\n    get hasEvents() {\n      return this._used.hasEvents;\n    }\n    /** @inheritdoc */\n    get hasCheckout() {\n      return this._used.hasCheckout;\n    }\n    /** @inheritdoc */\n    set hasCheckout(value) {\n      this._used.hasCheckout = value;\n    }\n    /** @inheritDoc */\n    destroy() {\n      this._fallback.destroy();\n      this._compression.destroy();\n    }\n    /** @inheritdoc */\n    clear() {\n      return this._used.clear();\n    }\n    /** @inheritdoc */\n    getEarliestTimestamp() {\n      return this._used.getEarliestTimestamp();\n    }\n    /**\n     * Add an event to the event buffer.\n     *\n     * Returns true if event was successfully added.\n     */\n    addEvent(event) {\n      return this._used.addEvent(event);\n    }\n    /** @inheritDoc */\n    async finish() {\n      await this.ensureWorkerIsLoaded();\n      return this._used.finish();\n    }\n    /** Ensure the worker has loaded. */\n    ensureWorkerIsLoaded() {\n      return this._ensureWorkerIsLoadedPromise;\n    }\n    /** Actually check if the worker has been loaded. */\n    async _ensureWorkerIsLoaded() {\n      try {\n        await this._compression.ensureReady();\n      } catch (error) {\n        logInfo(\"[Replay] Failed to load the compression worker, falling back to simple buffer\");\n        return;\n      }\n      await this._switchToCompressionWorker();\n    }\n    /** Switch the used buffer to the compression worker. */\n    async _switchToCompressionWorker() {\n      const { events, hasCheckout } = this._fallback;\n      const addEventPromises = [];\n      for (const event of events) {\n        addEventPromises.push(this._compression.addEvent(event));\n      }\n      this._compression.hasCheckout = hasCheckout;\n      this._used = this._compression;\n      try {\n        await Promise.all(addEventPromises);\n      } catch (error) {\n        DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to add events when switching buffers.\", error);\n      }\n    }\n  };\n  function createEventBuffer({\n    useCompression,\n    workerUrl: customWorkerUrl\n  }) {\n    if (useCompression && // eslint-disable-next-line no-restricted-globals\n    window.Worker) {\n      const worker = _loadWorker(customWorkerUrl);\n      if (worker) {\n        return worker;\n      }\n    }\n    logInfo(\"[Replay] Using simple buffer\");\n    return new EventBufferArray();\n  }\n  function _loadWorker(customWorkerUrl) {\n    try {\n      const workerUrl = customWorkerUrl || _getWorkerUrl();\n      if (!workerUrl) {\n        return;\n      }\n      logInfo(`[Replay] Using compression worker${customWorkerUrl ? ` from ${customWorkerUrl}` : \"\"}`);\n      const worker = new Worker(workerUrl);\n      return new EventBufferProxy(worker);\n    } catch (error) {\n      logInfo(\"[Replay] Failed to create compression worker\");\n    }\n  }\n  function _getWorkerUrl() {\n    if (typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ === \"undefined\" || !__SENTRY_EXCLUDE_REPLAY_WORKER__) {\n      return e();\n    }\n    return \"\";\n  }\n  function hasSessionStorage() {\n    try {\n      return \"sessionStorage\" in WINDOW6 && !!WINDOW6.sessionStorage;\n    } catch (e2) {\n      return false;\n    }\n  }\n  function clearSession(replay) {\n    deleteSession();\n    replay.session = void 0;\n  }\n  function deleteSession() {\n    if (!hasSessionStorage()) {\n      return;\n    }\n    try {\n      WINDOW6.sessionStorage.removeItem(REPLAY_SESSION_KEY);\n    } catch (e2) {\n    }\n  }\n  function isSampled(sampleRate) {\n    if (sampleRate === void 0) {\n      return false;\n    }\n    return Math.random() < sampleRate;\n  }\n  function makeSession2(session) {\n    const now = Date.now();\n    const id = session.id || uuid4();\n    const started = session.started || now;\n    const lastActivity = session.lastActivity || now;\n    const segmentId = session.segmentId || 0;\n    const sampled = session.sampled;\n    const previousSessionId = session.previousSessionId;\n    return {\n      id,\n      started,\n      lastActivity,\n      segmentId,\n      sampled,\n      previousSessionId\n    };\n  }\n  function saveSession(session) {\n    if (!hasSessionStorage()) {\n      return;\n    }\n    try {\n      WINDOW6.sessionStorage.setItem(REPLAY_SESSION_KEY, JSON.stringify(session));\n    } catch (e2) {\n    }\n  }\n  function getSessionSampleType(sessionSampleRate, allowBuffering) {\n    return isSampled(sessionSampleRate) ? \"session\" : allowBuffering ? \"buffer\" : false;\n  }\n  function createSession({ sessionSampleRate, allowBuffering, stickySession = false }, { previousSessionId } = {}) {\n    const sampled = getSessionSampleType(sessionSampleRate, allowBuffering);\n    const session = makeSession2({\n      sampled,\n      previousSessionId\n    });\n    if (stickySession) {\n      saveSession(session);\n    }\n    return session;\n  }\n  function fetchSession(traceInternals) {\n    if (!hasSessionStorage()) {\n      return null;\n    }\n    try {\n      const sessionStringFromStorage = WINDOW6.sessionStorage.getItem(REPLAY_SESSION_KEY);\n      if (!sessionStringFromStorage) {\n        return null;\n      }\n      const sessionObj = JSON.parse(sessionStringFromStorage);\n      logInfoNextTick(\"[Replay] Loading existing session\", traceInternals);\n      return makeSession2(sessionObj);\n    } catch (e2) {\n      return null;\n    }\n  }\n  function isExpired(initialTime, expiry, targetTime = +/* @__PURE__ */ new Date()) {\n    if (initialTime === null || expiry === void 0 || expiry < 0) {\n      return true;\n    }\n    if (expiry === 0) {\n      return false;\n    }\n    return initialTime + expiry <= targetTime;\n  }\n  function isSessionExpired(session, {\n    maxReplayDuration,\n    sessionIdleExpire,\n    targetTime = Date.now()\n  }) {\n    return (\n      // First, check that maximum session length has not been exceeded\n      isExpired(session.started, maxReplayDuration, targetTime) || // check that the idle timeout has not been exceeded (i.e. user has\n      // performed an action within the last `sessionIdleExpire` ms)\n      isExpired(session.lastActivity, sessionIdleExpire, targetTime)\n    );\n  }\n  function shouldRefreshSession(session, { sessionIdleExpire, maxReplayDuration }) {\n    if (!isSessionExpired(session, { sessionIdleExpire, maxReplayDuration })) {\n      return false;\n    }\n    if (session.sampled === \"buffer\" && session.segmentId === 0) {\n      return false;\n    }\n    return true;\n  }\n  function loadOrCreateSession({\n    traceInternals,\n    sessionIdleExpire,\n    maxReplayDuration,\n    previousSessionId\n  }, sessionOptions) {\n    const existingSession = sessionOptions.stickySession && fetchSession(traceInternals);\n    if (!existingSession) {\n      logInfoNextTick(\"[Replay] Creating new session\", traceInternals);\n      return createSession(sessionOptions, { previousSessionId });\n    }\n    if (!shouldRefreshSession(existingSession, { sessionIdleExpire, maxReplayDuration })) {\n      return existingSession;\n    }\n    logInfoNextTick(\"[Replay] Session in sessionStorage is expired, creating new one...\");\n    return createSession(sessionOptions, { previousSessionId: existingSession.id });\n  }\n  function isCustomEvent(event) {\n    return event.type === EventType.Custom;\n  }\n  function addEventSync(replay, event, isCheckout) {\n    if (!shouldAddEvent(replay, event)) {\n      return false;\n    }\n    _addEvent(replay, event, isCheckout);\n    return true;\n  }\n  function addEvent(replay, event, isCheckout) {\n    if (!shouldAddEvent(replay, event)) {\n      return Promise.resolve(null);\n    }\n    return _addEvent(replay, event, isCheckout);\n  }\n  async function _addEvent(replay, event, isCheckout) {\n    if (!replay.eventBuffer) {\n      return null;\n    }\n    try {\n      if (isCheckout && replay.recordingMode === \"buffer\") {\n        replay.eventBuffer.clear();\n      }\n      if (isCheckout) {\n        replay.eventBuffer.hasCheckout = true;\n      }\n      const replayOptions = replay.getOptions();\n      const eventAfterPossibleCallback = maybeApplyCallback(event, replayOptions.beforeAddRecordingEvent);\n      if (!eventAfterPossibleCallback) {\n        return;\n      }\n      return await replay.eventBuffer.addEvent(eventAfterPossibleCallback);\n    } catch (error) {\n      const reason = error && error instanceof EventBufferSizeExceededError ? \"addEventSizeExceeded\" : \"addEvent\";\n      DEBUG_BUILD5 && logger.error(error);\n      await replay.stop({ reason });\n      const client = getClient();\n      if (client) {\n        client.recordDroppedEvent(\"internal_sdk_error\", \"replay\");\n      }\n    }\n  }\n  function shouldAddEvent(replay, event) {\n    if (!replay.eventBuffer || replay.isPaused() || !replay.isEnabled()) {\n      return false;\n    }\n    const timestampInMs = timestampToMs(event.timestamp);\n    if (timestampInMs + replay.timeouts.sessionIdlePause < Date.now()) {\n      return false;\n    }\n    if (timestampInMs > replay.getContext().initialTimestamp + replay.getOptions().maxReplayDuration) {\n      logInfoNextTick(\n        `[Replay] Skipping event with timestamp ${timestampInMs} because it is after maxReplayDuration`,\n        replay.getOptions()._experiments.traceInternals\n      );\n      return false;\n    }\n    return true;\n  }\n  function maybeApplyCallback(event, callback) {\n    try {\n      if (typeof callback === \"function\" && isCustomEvent(event)) {\n        return callback(event);\n      }\n    } catch (error) {\n      DEBUG_BUILD5 && logger.error(\"[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...\", error);\n      return null;\n    }\n    return event;\n  }\n  function isErrorEvent3(event) {\n    return !event.type;\n  }\n  function isTransactionEvent2(event) {\n    return event.type === \"transaction\";\n  }\n  function isReplayEvent(event) {\n    return event.type === \"replay_event\";\n  }\n  function isFeedbackEvent(event) {\n    return event.type === \"feedback\";\n  }\n  function handleAfterSendEvent(replay) {\n    return (event, sendResponse) => {\n      if (!replay.isEnabled() || !isErrorEvent3(event) && !isTransactionEvent2(event)) {\n        return;\n      }\n      const statusCode = sendResponse && sendResponse.statusCode;\n      if (!statusCode || statusCode < 200 || statusCode >= 300) {\n        return;\n      }\n      if (isTransactionEvent2(event)) {\n        handleTransactionEvent(replay, event);\n        return;\n      }\n      handleErrorEvent(replay, event);\n    };\n  }\n  function handleTransactionEvent(replay, event) {\n    const replayContext = replay.getContext();\n    if (event.contexts && event.contexts.trace && event.contexts.trace.trace_id && replayContext.traceIds.size < 100) {\n      replayContext.traceIds.add(event.contexts.trace.trace_id);\n    }\n  }\n  function handleErrorEvent(replay, event) {\n    const replayContext = replay.getContext();\n    if (event.event_id && replayContext.errorIds.size < 100) {\n      replayContext.errorIds.add(event.event_id);\n    }\n    if (replay.recordingMode !== \"buffer\" || !event.tags || !event.tags.replayId) {\n      return;\n    }\n    const { beforeErrorSampling } = replay.getOptions();\n    if (typeof beforeErrorSampling === \"function\" && !beforeErrorSampling(event)) {\n      return;\n    }\n    setTimeout2(() => {\n      replay.sendBufferedReplayOrFlush();\n    });\n  }\n  function handleBeforeSendEvent(replay) {\n    return (event) => {\n      if (!replay.isEnabled() || !isErrorEvent3(event)) {\n        return;\n      }\n      handleHydrationError(replay, event);\n    };\n  }\n  function handleHydrationError(replay, event) {\n    const exceptionValue = event.exception && event.exception.values && event.exception.values[0] && event.exception.values[0].value;\n    if (typeof exceptionValue !== \"string\") {\n      return;\n    }\n    if (\n      // Only matches errors in production builds of react-dom\n      // Example https://reactjs.org/docs/error-decoder.html?invariant=423\n      // With newer React versions, the messages changed to a different website https://react.dev/errors/418\n      exceptionValue.match(\n        /(reactjs\\.org\\/docs\\/error-decoder\\.html\\?invariant=|react\\.dev\\/errors\\/)(418|419|422|423|425)/\n      ) || // Development builds of react-dom\n      // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.\n      // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.\n      exceptionValue.match(/(does not match server-rendered HTML|Hydration failed because)/i)\n    ) {\n      const breadcrumb = createBreadcrumb({\n        category: \"replay.hydrate-error\",\n        data: {\n          url: getLocationHref()\n        }\n      });\n      addBreadcrumbEvent(replay, breadcrumb);\n    }\n  }\n  function handleBreadcrumbs(replay) {\n    const client = getClient();\n    if (!client) {\n      return;\n    }\n    client.on(\"beforeAddBreadcrumb\", (breadcrumb) => beforeAddBreadcrumb(replay, breadcrumb));\n  }\n  function beforeAddBreadcrumb(replay, breadcrumb) {\n    if (!replay.isEnabled() || !isBreadcrumbWithCategory(breadcrumb)) {\n      return;\n    }\n    const result = normalizeBreadcrumb(breadcrumb);\n    if (result) {\n      addBreadcrumbEvent(replay, result);\n    }\n  }\n  function normalizeBreadcrumb(breadcrumb) {\n    if (!isBreadcrumbWithCategory(breadcrumb) || [\n      // fetch & xhr are handled separately,in handleNetworkBreadcrumbs\n      \"fetch\",\n      \"xhr\",\n      // These two are breadcrumbs for emitted sentry events, we don't care about them\n      \"sentry.event\",\n      \"sentry.transaction\"\n    ].includes(breadcrumb.category) || // We capture UI breadcrumbs separately\n    breadcrumb.category.startsWith(\"ui.\")) {\n      return null;\n    }\n    if (breadcrumb.category === \"console\") {\n      return normalizeConsoleBreadcrumb(breadcrumb);\n    }\n    return createBreadcrumb(breadcrumb);\n  }\n  function normalizeConsoleBreadcrumb(breadcrumb) {\n    const args = breadcrumb.data && breadcrumb.data.arguments;\n    if (!Array.isArray(args) || args.length === 0) {\n      return createBreadcrumb(breadcrumb);\n    }\n    let isTruncated = false;\n    const normalizedArgs = args.map((arg) => {\n      if (!arg) {\n        return arg;\n      }\n      if (typeof arg === \"string\") {\n        if (arg.length > CONSOLE_ARG_MAX_SIZE) {\n          isTruncated = true;\n          return `${arg.slice(0, CONSOLE_ARG_MAX_SIZE)}\\u2026`;\n        }\n        return arg;\n      }\n      if (typeof arg === \"object\") {\n        try {\n          const normalizedArg = normalize(arg, 7);\n          const stringified = JSON.stringify(normalizedArg);\n          if (stringified.length > CONSOLE_ARG_MAX_SIZE) {\n            isTruncated = true;\n            return `${JSON.stringify(normalizedArg, null, 2).slice(0, CONSOLE_ARG_MAX_SIZE)}\\u2026`;\n          }\n          return normalizedArg;\n        } catch (e2) {\n        }\n      }\n      return arg;\n    });\n    return createBreadcrumb({\n      ...breadcrumb,\n      data: {\n        ...breadcrumb.data,\n        arguments: normalizedArgs,\n        ...isTruncated ? { _meta: { warnings: [\"CONSOLE_ARG_TRUNCATED\"] } } : {}\n      }\n    });\n  }\n  function isBreadcrumbWithCategory(breadcrumb) {\n    return !!breadcrumb.category;\n  }\n  function isRrwebError(event, hint) {\n    if (event.type || !event.exception || !event.exception.values || !event.exception.values.length) {\n      return false;\n    }\n    if (hint.originalException && hint.originalException.__rrweb__) {\n      return true;\n    }\n    return false;\n  }\n  function addFeedbackBreadcrumb(replay, event) {\n    replay.triggerUserActivity();\n    replay.addUpdate(() => {\n      if (!event.timestamp) {\n        return true;\n      }\n      replay.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: event.timestamp * 1e3,\n        data: {\n          tag: \"breadcrumb\",\n          payload: {\n            timestamp: event.timestamp,\n            type: \"default\",\n            category: \"sentry.feedback\",\n            data: {\n              feedbackId: event.event_id\n            }\n          }\n        }\n      });\n      return false;\n    });\n  }\n  function shouldSampleForBufferEvent(replay, event) {\n    if (replay.recordingMode !== \"buffer\") {\n      return false;\n    }\n    if (event.message === UNABLE_TO_SEND_REPLAY) {\n      return false;\n    }\n    if (!event.exception || event.type) {\n      return false;\n    }\n    return isSampled(replay.getOptions().errorSampleRate);\n  }\n  function handleGlobalEventListener(replay) {\n    return Object.assign(\n      (event, hint) => {\n        if (!replay.isEnabled()) {\n          return event;\n        }\n        if (isReplayEvent(event)) {\n          delete event.breadcrumbs;\n          return event;\n        }\n        if (!isErrorEvent3(event) && !isTransactionEvent2(event) && !isFeedbackEvent(event)) {\n          return event;\n        }\n        const isSessionActive = replay.checkAndHandleExpiredSession();\n        if (!isSessionActive) {\n          return event;\n        }\n        if (isFeedbackEvent(event)) {\n          replay.flush();\n          event.contexts.feedback.replay_id = replay.getSessionId();\n          addFeedbackBreadcrumb(replay, event);\n          return event;\n        }\n        if (isRrwebError(event, hint) && !replay.getOptions()._experiments.captureExceptions) {\n          DEBUG_BUILD5 && logger.log(\"[Replay] Ignoring error from rrweb internals\", event);\n          return null;\n        }\n        const isErrorEventSampled = shouldSampleForBufferEvent(replay, event);\n        const shouldTagReplayId = isErrorEventSampled || replay.recordingMode === \"session\";\n        if (shouldTagReplayId) {\n          event.tags = { ...event.tags, replayId: replay.getSessionId() };\n        }\n        return event;\n      },\n      { id: \"Replay\" }\n    );\n  }\n  function createPerformanceSpans(replay, entries) {\n    return entries.map(({ type, start: start2, end: end2, name: name2, data }) => {\n      const response = replay.throttledAddEvent({\n        type: EventType.Custom,\n        timestamp: start2,\n        data: {\n          tag: \"performanceSpan\",\n          payload: {\n            op: type,\n            description: name2,\n            startTimestamp: start2,\n            endTimestamp: end2,\n            data\n          }\n        }\n      });\n      return typeof response === \"string\" ? Promise.resolve(null) : response;\n    });\n  }\n  function handleHistory(handlerData) {\n    const { from, to } = handlerData;\n    const now = Date.now() / 1e3;\n    return {\n      type: \"navigation.push\",\n      start: now,\n      end: now,\n      name: to,\n      data: {\n        previous: from\n      }\n    };\n  }\n  function handleHistorySpanListener(replay) {\n    return (handlerData) => {\n      if (!replay.isEnabled()) {\n        return;\n      }\n      const result = handleHistory(handlerData);\n      if (result === null) {\n        return;\n      }\n      replay.getContext().urls.push(result.name);\n      replay.triggerUserActivity();\n      replay.addUpdate(() => {\n        createPerformanceSpans(replay, [result]);\n        return false;\n      });\n    };\n  }\n  function shouldFilterRequest(replay, url) {\n    if (DEBUG_BUILD5 && replay.getOptions()._experiments.traceInternals) {\n      return false;\n    }\n    return isSentryRequestUrl(url, getClient());\n  }\n  function addNetworkBreadcrumb(replay, result) {\n    if (!replay.isEnabled()) {\n      return;\n    }\n    if (result === null) {\n      return;\n    }\n    if (shouldFilterRequest(replay, result.name)) {\n      return;\n    }\n    replay.addUpdate(() => {\n      createPerformanceSpans(replay, [result]);\n      return true;\n    });\n  }\n  function getBodySize(body) {\n    if (!body) {\n      return void 0;\n    }\n    const textEncoder = new TextEncoder();\n    try {\n      if (typeof body === \"string\") {\n        return textEncoder.encode(body).length;\n      }\n      if (body instanceof URLSearchParams) {\n        return textEncoder.encode(body.toString()).length;\n      }\n      if (body instanceof FormData) {\n        const formDataStr = _serializeFormData(body);\n        return textEncoder.encode(formDataStr).length;\n      }\n      if (body instanceof Blob) {\n        return body.size;\n      }\n      if (body instanceof ArrayBuffer) {\n        return body.byteLength;\n      }\n    } catch (e2) {\n    }\n    return void 0;\n  }\n  function parseContentLengthHeader(header) {\n    if (!header) {\n      return void 0;\n    }\n    const size = parseInt(header, 10);\n    return isNaN(size) ? void 0 : size;\n  }\n  function getBodyString(body) {\n    try {\n      if (typeof body === \"string\") {\n        return [body];\n      }\n      if (body instanceof URLSearchParams) {\n        return [body.toString()];\n      }\n      if (body instanceof FormData) {\n        return [_serializeFormData(body)];\n      }\n      if (!body) {\n        return [void 0];\n      }\n    } catch (e2) {\n      DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to serialize body\", body);\n      return [void 0, \"BODY_PARSE_ERROR\"];\n    }\n    DEBUG_BUILD5 && logger.info(\"[Replay] Skipping network body because of body type\", body);\n    return [void 0, \"UNPARSEABLE_BODY_TYPE\"];\n  }\n  function mergeWarning(info, warning) {\n    if (!info) {\n      return {\n        headers: {},\n        size: void 0,\n        _meta: {\n          warnings: [warning]\n        }\n      };\n    }\n    const newMeta = { ...info._meta };\n    const existingWarnings = newMeta.warnings || [];\n    newMeta.warnings = [...existingWarnings, warning];\n    info._meta = newMeta;\n    return info;\n  }\n  function makeNetworkReplayBreadcrumb(type, data) {\n    if (!data) {\n      return null;\n    }\n    const { startTimestamp, endTimestamp, url, method, statusCode, request, response } = data;\n    const result = {\n      type,\n      start: startTimestamp / 1e3,\n      end: endTimestamp / 1e3,\n      name: url,\n      data: dropUndefinedKeys({\n        method,\n        statusCode,\n        request,\n        response\n      })\n    };\n    return result;\n  }\n  function buildSkippedNetworkRequestOrResponse(bodySize) {\n    return {\n      headers: {},\n      size: bodySize,\n      _meta: {\n        warnings: [\"URL_SKIPPED\"]\n      }\n    };\n  }\n  function buildNetworkRequestOrResponse(headers, bodySize, body) {\n    if (!bodySize && Object.keys(headers).length === 0) {\n      return void 0;\n    }\n    if (!bodySize) {\n      return {\n        headers\n      };\n    }\n    if (!body) {\n      return {\n        headers,\n        size: bodySize\n      };\n    }\n    const info = {\n      headers,\n      size: bodySize\n    };\n    const { body: normalizedBody, warnings } = normalizeNetworkBody(body);\n    info.body = normalizedBody;\n    if (warnings && warnings.length > 0) {\n      info._meta = {\n        warnings\n      };\n    }\n    return info;\n  }\n  function getAllowedHeaders(headers, allowedHeaders) {\n    return Object.entries(headers).reduce((filteredHeaders, [key, value]) => {\n      const normalizedKey = key.toLowerCase();\n      if (allowedHeaders.includes(normalizedKey) && headers[key]) {\n        filteredHeaders[normalizedKey] = value;\n      }\n      return filteredHeaders;\n    }, {});\n  }\n  function _serializeFormData(formData) {\n    return new URLSearchParams(formData).toString();\n  }\n  function normalizeNetworkBody(body) {\n    if (!body || typeof body !== \"string\") {\n      return {\n        body\n      };\n    }\n    const exceedsSizeLimit = body.length > NETWORK_BODY_MAX_SIZE;\n    const isProbablyJson = _strIsProbablyJson(body);\n    if (exceedsSizeLimit) {\n      const truncatedBody = body.slice(0, NETWORK_BODY_MAX_SIZE);\n      if (isProbablyJson) {\n        return {\n          body: truncatedBody,\n          warnings: [\"MAYBE_JSON_TRUNCATED\"]\n        };\n      }\n      return {\n        body: `${truncatedBody}\\u2026`,\n        warnings: [\"TEXT_TRUNCATED\"]\n      };\n    }\n    if (isProbablyJson) {\n      try {\n        const jsonBody = JSON.parse(body);\n        return {\n          body: jsonBody\n        };\n      } catch (e3) {\n      }\n    }\n    return {\n      body\n    };\n  }\n  function _strIsProbablyJson(str2) {\n    const first = str2[0];\n    const last = str2[str2.length - 1];\n    return first === \"[\" && last === \"]\" || first === \"{\" && last === \"}\";\n  }\n  function urlMatches(url, urls) {\n    const fullUrl = getFullUrl(url);\n    return stringMatchesSomePattern(fullUrl, urls);\n  }\n  function getFullUrl(url, baseURI = WINDOW6.document.baseURI) {\n    if (url.startsWith(\"http://\") || url.startsWith(\"https://\") || url.startsWith(WINDOW6.location.origin)) {\n      return url;\n    }\n    const fixedUrl = new URL(url, baseURI);\n    if (fixedUrl.origin !== new URL(baseURI).origin) {\n      return url;\n    }\n    const fullUrl = fixedUrl.href;\n    if (!url.endsWith(\"/\") && fullUrl.endsWith(\"/\")) {\n      return fullUrl.slice(0, -1);\n    }\n    return fullUrl;\n  }\n  async function captureFetchBreadcrumbToReplay(breadcrumb, hint, options) {\n    try {\n      const data = await _prepareFetchData(breadcrumb, hint, options);\n      const result = makeNetworkReplayBreadcrumb(\"resource.fetch\", data);\n      addNetworkBreadcrumb(options.replay, result);\n    } catch (error) {\n      DEBUG_BUILD5 && logger.error(\"[Replay] Failed to capture fetch breadcrumb\", error);\n    }\n  }\n  function enrichFetchBreadcrumb(breadcrumb, hint) {\n    const { input, response } = hint;\n    const body = input ? _getFetchRequestArgBody(input) : void 0;\n    const reqSize = getBodySize(body);\n    const resSize = response ? parseContentLengthHeader(response.headers.get(\"content-length\")) : void 0;\n    if (reqSize !== void 0) {\n      breadcrumb.data.request_body_size = reqSize;\n    }\n    if (resSize !== void 0) {\n      breadcrumb.data.response_body_size = resSize;\n    }\n  }\n  async function _prepareFetchData(breadcrumb, hint, options) {\n    const now = Date.now();\n    const { startTimestamp = now, endTimestamp = now } = hint;\n    const {\n      url,\n      method,\n      status_code: statusCode = 0,\n      request_body_size: requestBodySize,\n      response_body_size: responseBodySize\n    } = breadcrumb.data;\n    const captureDetails = urlMatches(url, options.networkDetailAllowUrls) && !urlMatches(url, options.networkDetailDenyUrls);\n    const request = captureDetails ? _getRequestInfo(options, hint.input, requestBodySize) : buildSkippedNetworkRequestOrResponse(requestBodySize);\n    const response = await _getResponseInfo(captureDetails, options, hint.response, responseBodySize);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request,\n      response\n    };\n  }\n  function _getRequestInfo({ networkCaptureBodies, networkRequestHeaders }, input, requestBodySize) {\n    const headers = input ? getRequestHeaders(input, networkRequestHeaders) : {};\n    if (!networkCaptureBodies) {\n      return buildNetworkRequestOrResponse(headers, requestBodySize, void 0);\n    }\n    const requestBody = _getFetchRequestArgBody(input);\n    const [bodyStr, warning] = getBodyString(requestBody);\n    const data = buildNetworkRequestOrResponse(headers, requestBodySize, bodyStr);\n    if (warning) {\n      return mergeWarning(data, warning);\n    }\n    return data;\n  }\n  async function _getResponseInfo(captureDetails, {\n    networkCaptureBodies,\n    networkResponseHeaders\n  }, response, responseBodySize) {\n    if (!captureDetails && responseBodySize !== void 0) {\n      return buildSkippedNetworkRequestOrResponse(responseBodySize);\n    }\n    const headers = response ? getAllHeaders(response.headers, networkResponseHeaders) : {};\n    if (!response || !networkCaptureBodies && responseBodySize !== void 0) {\n      return buildNetworkRequestOrResponse(headers, responseBodySize, void 0);\n    }\n    const [bodyText, warning] = await _parseFetchResponseBody(response);\n    const result = getResponseData(bodyText, {\n      networkCaptureBodies,\n      responseBodySize,\n      captureDetails,\n      headers\n    });\n    if (warning) {\n      return mergeWarning(result, warning);\n    }\n    return result;\n  }\n  function getResponseData(bodyText, {\n    networkCaptureBodies,\n    responseBodySize,\n    captureDetails,\n    headers\n  }) {\n    try {\n      const size = bodyText && bodyText.length && responseBodySize === void 0 ? getBodySize(bodyText) : responseBodySize;\n      if (!captureDetails) {\n        return buildSkippedNetworkRequestOrResponse(size);\n      }\n      if (networkCaptureBodies) {\n        return buildNetworkRequestOrResponse(headers, size, bodyText);\n      }\n      return buildNetworkRequestOrResponse(headers, size, void 0);\n    } catch (error) {\n      DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to serialize response body\", error);\n      return buildNetworkRequestOrResponse(headers, responseBodySize, void 0);\n    }\n  }\n  async function _parseFetchResponseBody(response) {\n    const res = _tryCloneResponse(response);\n    if (!res) {\n      return [void 0, \"BODY_PARSE_ERROR\"];\n    }\n    try {\n      const text = await _tryGetResponseText(res);\n      return [text];\n    } catch (error) {\n      DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to get text body from response\", error);\n      return [void 0, \"BODY_PARSE_ERROR\"];\n    }\n  }\n  function _getFetchRequestArgBody(fetchArgs = []) {\n    if (fetchArgs.length !== 2 || typeof fetchArgs[1] !== \"object\") {\n      return void 0;\n    }\n    return fetchArgs[1].body;\n  }\n  function getAllHeaders(headers, allowedHeaders) {\n    const allHeaders = {};\n    allowedHeaders.forEach((header) => {\n      if (headers.get(header)) {\n        allHeaders[header] = headers.get(header);\n      }\n    });\n    return allHeaders;\n  }\n  function getRequestHeaders(fetchArgs, allowedHeaders) {\n    if (fetchArgs.length === 1 && typeof fetchArgs[0] !== \"string\") {\n      return getHeadersFromOptions(fetchArgs[0], allowedHeaders);\n    }\n    if (fetchArgs.length === 2) {\n      return getHeadersFromOptions(fetchArgs[1], allowedHeaders);\n    }\n    return {};\n  }\n  function getHeadersFromOptions(input, allowedHeaders) {\n    if (!input) {\n      return {};\n    }\n    const headers = input.headers;\n    if (!headers) {\n      return {};\n    }\n    if (headers instanceof Headers) {\n      return getAllHeaders(headers, allowedHeaders);\n    }\n    if (Array.isArray(headers)) {\n      return {};\n    }\n    return getAllowedHeaders(headers, allowedHeaders);\n  }\n  function _tryCloneResponse(response) {\n    try {\n      return response.clone();\n    } catch (error) {\n      DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to clone response body\", error);\n    }\n  }\n  function _tryGetResponseText(response) {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout2(() => reject(new Error(\"Timeout while trying to read response body\")), 500);\n      _getResponseText(response).then(\n        (txt) => resolve(txt),\n        (reason) => reject(reason)\n      ).finally(() => clearTimeout(timeout));\n    });\n  }\n  async function _getResponseText(response) {\n    return await response.text();\n  }\n  async function captureXhrBreadcrumbToReplay(breadcrumb, hint, options) {\n    try {\n      const data = _prepareXhrData(breadcrumb, hint, options);\n      const result = makeNetworkReplayBreadcrumb(\"resource.xhr\", data);\n      addNetworkBreadcrumb(options.replay, result);\n    } catch (error) {\n      DEBUG_BUILD5 && logger.error(\"[Replay] Failed to capture xhr breadcrumb\", error);\n    }\n  }\n  function enrichXhrBreadcrumb(breadcrumb, hint) {\n    const { xhr, input } = hint;\n    if (!xhr) {\n      return;\n    }\n    const reqSize = getBodySize(input);\n    const resSize = xhr.getResponseHeader(\"content-length\") ? parseContentLengthHeader(xhr.getResponseHeader(\"content-length\")) : _getBodySize(xhr.response, xhr.responseType);\n    if (reqSize !== void 0) {\n      breadcrumb.data.request_body_size = reqSize;\n    }\n    if (resSize !== void 0) {\n      breadcrumb.data.response_body_size = resSize;\n    }\n  }\n  function _prepareXhrData(breadcrumb, hint, options) {\n    const now = Date.now();\n    const { startTimestamp = now, endTimestamp = now, input, xhr } = hint;\n    const {\n      url,\n      method,\n      status_code: statusCode = 0,\n      request_body_size: requestBodySize,\n      response_body_size: responseBodySize\n    } = breadcrumb.data;\n    if (!url) {\n      return null;\n    }\n    if (!xhr || !urlMatches(url, options.networkDetailAllowUrls) || urlMatches(url, options.networkDetailDenyUrls)) {\n      const request2 = buildSkippedNetworkRequestOrResponse(requestBodySize);\n      const response2 = buildSkippedNetworkRequestOrResponse(responseBodySize);\n      return {\n        startTimestamp,\n        endTimestamp,\n        url,\n        method,\n        statusCode,\n        request: request2,\n        response: response2\n      };\n    }\n    const xhrInfo = xhr[SENTRY_XHR_DATA_KEY];\n    const networkRequestHeaders = xhrInfo ? getAllowedHeaders(xhrInfo.request_headers, options.networkRequestHeaders) : {};\n    const networkResponseHeaders = getAllowedHeaders(getResponseHeaders(xhr), options.networkResponseHeaders);\n    const [requestBody, requestWarning] = options.networkCaptureBodies ? getBodyString(input) : [void 0];\n    const [responseBody, responseWarning] = options.networkCaptureBodies ? _getXhrResponseBody(xhr) : [void 0];\n    const request = buildNetworkRequestOrResponse(networkRequestHeaders, requestBodySize, requestBody);\n    const response = buildNetworkRequestOrResponse(networkResponseHeaders, responseBodySize, responseBody);\n    return {\n      startTimestamp,\n      endTimestamp,\n      url,\n      method,\n      statusCode,\n      request: requestWarning ? mergeWarning(request, requestWarning) : request,\n      response: responseWarning ? mergeWarning(response, responseWarning) : response\n    };\n  }\n  function getResponseHeaders(xhr) {\n    const headers = xhr.getAllResponseHeaders();\n    if (!headers) {\n      return {};\n    }\n    return headers.split(\"\\r\\n\").reduce((acc, line) => {\n      const [key, value] = line.split(\": \");\n      if (value) {\n        acc[key.toLowerCase()] = value;\n      }\n      return acc;\n    }, {});\n  }\n  function _getXhrResponseBody(xhr) {\n    const errors = [];\n    try {\n      return [xhr.responseText];\n    } catch (e2) {\n      errors.push(e2);\n    }\n    try {\n      return _parseXhrResponse(xhr.response, xhr.responseType);\n    } catch (e2) {\n      errors.push(e2);\n    }\n    DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to get xhr response body\", ...errors);\n    return [void 0];\n  }\n  function _parseXhrResponse(body, responseType) {\n    try {\n      if (typeof body === \"string\") {\n        return [body];\n      }\n      if (body instanceof Document) {\n        return [body.body.outerHTML];\n      }\n      if (responseType === \"json\" && body && typeof body === \"object\") {\n        return [JSON.stringify(body)];\n      }\n      if (!body) {\n        return [void 0];\n      }\n    } catch (e2) {\n      DEBUG_BUILD5 && logger.warn(\"[Replay] Failed to serialize body\", body);\n      return [void 0, \"BODY_PARSE_ERROR\"];\n    }\n    DEBUG_BUILD5 && logger.info(\"[Replay] Skipping network body because of body type\", body);\n    return [void 0, \"UNPARSEABLE_BODY_TYPE\"];\n  }\n  function _getBodySize(body, responseType) {\n    try {\n      const bodyStr = responseType === \"json\" && body && typeof body === \"object\" ? JSON.stringify(body) : body;\n      return getBodySize(bodyStr);\n    } catch (e3) {\n      return void 0;\n    }\n  }\n  function handleNetworkBreadcrumbs(replay) {\n    const client = getClient();\n    try {\n      const {\n        networkDetailAllowUrls,\n        networkDetailDenyUrls,\n        networkCaptureBodies,\n        networkRequestHeaders,\n        networkResponseHeaders\n      } = replay.getOptions();\n      const options = {\n        replay,\n        networkDetailAllowUrls,\n        networkDetailDenyUrls,\n        networkCaptureBodies,\n        networkRequestHeaders,\n        networkResponseHeaders\n      };\n      if (client) {\n        client.on(\"beforeAddBreadcrumb\", (breadcrumb, hint) => beforeAddNetworkBreadcrumb(options, breadcrumb, hint));\n      }\n    } catch (e2) {\n    }\n  }\n  function beforeAddNetworkBreadcrumb(options, breadcrumb, hint) {\n    if (!breadcrumb.data) {\n      return;\n    }\n    try {\n      if (_isXhrBreadcrumb(breadcrumb) && _isXhrHint(hint)) {\n        enrichXhrBreadcrumb(breadcrumb, hint);\n        captureXhrBreadcrumbToReplay(breadcrumb, hint, options);\n      }\n      if (_isFetchBreadcrumb(breadcrumb) && _isFetchHint(hint)) {\n        enrichFetchBreadcrumb(breadcrumb, hint);\n        captureFetchBreadcrumbToReplay(breadcrumb, hint, options);\n      }\n    } catch (e2) {\n      DEBUG_BUILD5 && logger.warn(\"Error when enriching network breadcrumb\");\n    }\n  }\n  function _isXhrBreadcrumb(breadcrumb) {\n    return breadcrumb.category === \"xhr\";\n  }\n  function _isFetchBreadcrumb(breadcrumb) {\n    return breadcrumb.category === \"fetch\";\n  }\n  function _isXhrHint(hint) {\n    return hint && hint.xhr;\n  }\n  function _isFetchHint(hint) {\n    return hint && hint.response;\n  }\n  function addGlobalListeners(replay) {\n    const client = getClient();\n    addClickKeypressInstrumentationHandler(handleDomListener(replay));\n    addHistoryInstrumentationHandler(handleHistorySpanListener(replay));\n    handleBreadcrumbs(replay);\n    handleNetworkBreadcrumbs(replay);\n    const eventProcessor = handleGlobalEventListener(replay);\n    addEventProcessor(eventProcessor);\n    if (client) {\n      client.on(\"beforeSendEvent\", handleBeforeSendEvent(replay));\n      client.on(\"afterSendEvent\", handleAfterSendEvent(replay));\n      client.on(\"createDsc\", (dsc) => {\n        const replayId = replay.getSessionId();\n        if (replayId && replay.isEnabled() && replay.recordingMode === \"session\") {\n          const isSessionActive = replay.checkAndHandleExpiredSession();\n          if (isSessionActive) {\n            dsc.replay_id = replayId;\n          }\n        }\n      });\n      client.on(\"spanStart\", (span) => {\n        replay.lastActiveSpan = span;\n      });\n      client.on(\"spanEnd\", (span) => {\n        replay.lastActiveSpan = span;\n      });\n      client.on(\"beforeSendFeedback\", (feedbackEvent, options) => {\n        const replayId = replay.getSessionId();\n        if (options && options.includeReplay && replay.isEnabled() && replayId) {\n          if (feedbackEvent.contexts && feedbackEvent.contexts.feedback) {\n            feedbackEvent.contexts.feedback.replay_id = replayId;\n          }\n        }\n      });\n    }\n  }\n  async function addMemoryEntry(replay) {\n    try {\n      return Promise.all(\n        createPerformanceSpans(replay, [\n          // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)\n          createMemoryEntry(WINDOW6.performance.memory)\n        ])\n      );\n    } catch (error) {\n      return [];\n    }\n  }\n  function createMemoryEntry(memoryEntry) {\n    const { jsHeapSizeLimit, totalJSHeapSize, usedJSHeapSize } = memoryEntry;\n    const time = Date.now() / 1e3;\n    return {\n      type: \"memory\",\n      name: \"memory\",\n      start: time,\n      end: time,\n      data: {\n        memory: {\n          jsHeapSizeLimit,\n          totalJSHeapSize,\n          usedJSHeapSize\n        }\n      }\n    };\n  }\n  function debounce3(func, wait, options) {\n    let callbackReturnValue;\n    let timerId;\n    let maxTimerId;\n    const maxWait = options && options.maxWait ? Math.max(options.maxWait, wait) : 0;\n    function invokeFunc() {\n      cancelTimers();\n      callbackReturnValue = func();\n      return callbackReturnValue;\n    }\n    function cancelTimers() {\n      timerId !== void 0 && clearTimeout(timerId);\n      maxTimerId !== void 0 && clearTimeout(maxTimerId);\n      timerId = maxTimerId = void 0;\n    }\n    function flush2() {\n      if (timerId !== void 0 || maxTimerId !== void 0) {\n        return invokeFunc();\n      }\n      return callbackReturnValue;\n    }\n    function debounced() {\n      if (timerId) {\n        clearTimeout(timerId);\n      }\n      timerId = setTimeout2(invokeFunc, wait);\n      if (maxWait && maxTimerId === void 0) {\n        maxTimerId = setTimeout2(invokeFunc, maxWait);\n      }\n      return callbackReturnValue;\n    }\n    debounced.cancel = cancelTimers;\n    debounced.flush = flush2;\n    return debounced;\n  }\n  function getHandleRecordingEmit(replay) {\n    let hadFirstEvent = false;\n    return (event, _isCheckout) => {\n      if (!replay.checkAndHandleExpiredSession()) {\n        DEBUG_BUILD5 && logger.warn(\"[Replay] Received replay event after session expired.\");\n        return;\n      }\n      const isCheckout = _isCheckout || !hadFirstEvent;\n      hadFirstEvent = true;\n      if (replay.clickDetector) {\n        updateClickDetectorForRecordingEvent(replay.clickDetector, event);\n      }\n      replay.addUpdate(() => {\n        if (replay.recordingMode === \"buffer\" && isCheckout) {\n          replay.setInitialState();\n        }\n        if (!addEventSync(replay, event, isCheckout)) {\n          return true;\n        }\n        if (!isCheckout) {\n          return false;\n        }\n        addSettingsEvent(replay, isCheckout);\n        if (replay.session && replay.session.previousSessionId) {\n          return true;\n        }\n        if (replay.recordingMode === \"buffer\" && replay.session && replay.eventBuffer) {\n          const earliestEvent = replay.eventBuffer.getEarliestTimestamp();\n          if (earliestEvent) {\n            logInfo(\n              `[Replay] Updating session start time to earliest event in buffer to ${new Date(earliestEvent)}`,\n              replay.getOptions()._experiments.traceInternals\n            );\n            replay.session.started = earliestEvent;\n            if (replay.getOptions().stickySession) {\n              saveSession(replay.session);\n            }\n          }\n        }\n        if (replay.recordingMode === \"session\") {\n          void replay.flush();\n        }\n        return true;\n      });\n    };\n  }\n  function createOptionsEvent(replay) {\n    const options = replay.getOptions();\n    return {\n      type: EventType.Custom,\n      timestamp: Date.now(),\n      data: {\n        tag: \"options\",\n        payload: {\n          shouldRecordCanvas: replay.isRecordingCanvas(),\n          sessionSampleRate: options.sessionSampleRate,\n          errorSampleRate: options.errorSampleRate,\n          useCompressionOption: options.useCompression,\n          blockAllMedia: options.blockAllMedia,\n          maskAllText: options.maskAllText,\n          maskAllInputs: options.maskAllInputs,\n          useCompression: replay.eventBuffer ? replay.eventBuffer.type === \"worker\" : false,\n          networkDetailHasUrls: options.networkDetailAllowUrls.length > 0,\n          networkCaptureBodies: options.networkCaptureBodies,\n          networkRequestHasHeaders: options.networkRequestHeaders.length > 0,\n          networkResponseHasHeaders: options.networkResponseHeaders.length > 0\n        }\n      }\n    };\n  }\n  function addSettingsEvent(replay, isCheckout) {\n    if (!isCheckout || !replay.session || replay.session.segmentId !== 0) {\n      return;\n    }\n    addEventSync(replay, createOptionsEvent(replay), false);\n  }\n  function createReplayEnvelope(replayEvent, recordingData, dsn, tunnel) {\n    return createEnvelope(\n      createEventEnvelopeHeaders(replayEvent, getSdkMetadataForEnvelopeHeader(replayEvent), tunnel, dsn),\n      [\n        [{ type: \"replay_event\" }, replayEvent],\n        [\n          {\n            type: \"replay_recording\",\n            // If string then we need to encode to UTF8, otherwise will have\n            // wrong size. TextEncoder has similar browser support to\n            // MutationObserver, although it does not accept IE11.\n            length: typeof recordingData === \"string\" ? new TextEncoder().encode(recordingData).length : recordingData.length\n          },\n          recordingData\n        ]\n      ]\n    );\n  }\n  function prepareRecordingData({\n    recordingData,\n    headers\n  }) {\n    let payloadWithSequence;\n    const replayHeaders = `${JSON.stringify(headers)}\n`;\n    if (typeof recordingData === \"string\") {\n      payloadWithSequence = `${replayHeaders}${recordingData}`;\n    } else {\n      const enc = new TextEncoder();\n      const sequence = enc.encode(replayHeaders);\n      payloadWithSequence = new Uint8Array(sequence.length + recordingData.length);\n      payloadWithSequence.set(sequence);\n      payloadWithSequence.set(recordingData, sequence.length);\n    }\n    return payloadWithSequence;\n  }\n  async function prepareReplayEvent({\n    client,\n    scope,\n    replayId: event_id,\n    event\n  }) {\n    const integrations = typeof client._integrations === \"object\" && client._integrations !== null && !Array.isArray(client._integrations) ? Object.keys(client._integrations) : void 0;\n    const eventHint = { event_id, integrations };\n    client.emit(\"preprocessEvent\", event, eventHint);\n    const preparedEvent = await prepareEvent(\n      client.getOptions(),\n      event,\n      eventHint,\n      scope,\n      client,\n      getIsolationScope()\n    );\n    if (!preparedEvent) {\n      return null;\n    }\n    preparedEvent.platform = preparedEvent.platform || \"javascript\";\n    const metadata = client.getSdkMetadata();\n    const { name: name2, version } = metadata && metadata.sdk || {};\n    preparedEvent.sdk = {\n      ...preparedEvent.sdk,\n      name: name2 || \"sentry.javascript.unknown\",\n      version: version || \"0.0.0\"\n    };\n    return preparedEvent;\n  }\n  async function sendReplayRequest({\n    recordingData,\n    replayId,\n    segmentId: segment_id,\n    eventContext,\n    timestamp,\n    session\n  }) {\n    const preparedRecordingData = prepareRecordingData({\n      recordingData,\n      headers: {\n        segment_id\n      }\n    });\n    const { urls, errorIds, traceIds, initialTimestamp } = eventContext;\n    const client = getClient();\n    const scope = getCurrentScope();\n    const transport = client && client.getTransport();\n    const dsn = client && client.getDsn();\n    if (!client || !transport || !dsn || !session.sampled) {\n      return resolvedSyncPromise({});\n    }\n    const baseEvent = {\n      type: REPLAY_EVENT_NAME,\n      replay_start_timestamp: initialTimestamp / 1e3,\n      timestamp: timestamp / 1e3,\n      error_ids: errorIds,\n      trace_ids: traceIds,\n      urls,\n      replay_id: replayId,\n      segment_id,\n      replay_type: session.sampled\n    };\n    const replayEvent = await prepareReplayEvent({ scope, client, replayId, event: baseEvent });\n    if (!replayEvent) {\n      client.recordDroppedEvent(\"event_processor\", \"replay\", baseEvent);\n      logInfo(\"An event processor returned `null`, will not send event.\");\n      return resolvedSyncPromise({});\n    }\n    delete replayEvent.sdkProcessingMetadata;\n    const envelope = createReplayEnvelope(replayEvent, preparedRecordingData, dsn, client.getOptions().tunnel);\n    let response;\n    try {\n      response = await transport.send(envelope);\n    } catch (err) {\n      const error = new Error(UNABLE_TO_SEND_REPLAY);\n      try {\n        error.cause = err;\n      } catch (e2) {\n      }\n      throw error;\n    }\n    if (typeof response.statusCode === \"number\" && (response.statusCode < 200 || response.statusCode >= 300)) {\n      throw new TransportStatusCodeError(response.statusCode);\n    }\n    const rateLimits = updateRateLimits({}, response);\n    if (isRateLimited(rateLimits, \"replay\")) {\n      throw new RateLimitError(rateLimits);\n    }\n    return response;\n  }\n  var TransportStatusCodeError = class extends Error {\n    constructor(statusCode) {\n      super(`Transport returned status code ${statusCode}`);\n    }\n  };\n  var RateLimitError = class extends Error {\n    constructor(rateLimits) {\n      super(\"Rate limit hit\");\n      this.rateLimits = rateLimits;\n    }\n  };\n  async function sendReplay(replayData, retryConfig = {\n    count: 0,\n    interval: RETRY_BASE_INTERVAL\n  }) {\n    const { recordingData, options } = replayData;\n    if (!recordingData.length) {\n      return;\n    }\n    try {\n      await sendReplayRequest(replayData);\n      return true;\n    } catch (err) {\n      if (err instanceof TransportStatusCodeError || err instanceof RateLimitError) {\n        throw err;\n      }\n      setContext(\"Replays\", {\n        _retryCount: retryConfig.count\n      });\n      if (DEBUG_BUILD5 && options._experiments && options._experiments.captureExceptions) {\n        captureException(err);\n      }\n      if (retryConfig.count >= RETRY_MAX_COUNT) {\n        const error = new Error(`${UNABLE_TO_SEND_REPLAY} - max retries exceeded`);\n        try {\n          error.cause = err;\n        } catch (e2) {\n        }\n        throw error;\n      }\n      retryConfig.interval *= ++retryConfig.count;\n      return new Promise((resolve, reject) => {\n        setTimeout2(async () => {\n          try {\n            await sendReplay(replayData, retryConfig);\n            resolve(true);\n          } catch (err2) {\n            reject(err2);\n          }\n        }, retryConfig.interval);\n      });\n    }\n  }\n  var THROTTLED = \"__THROTTLED\";\n  var SKIPPED = \"__SKIPPED\";\n  function throttle(fn2, maxCount, durationSeconds) {\n    const counter = /* @__PURE__ */ new Map();\n    const _cleanup = (now) => {\n      const threshold = now - durationSeconds;\n      counter.forEach((_value, key) => {\n        if (key < threshold) {\n          counter.delete(key);\n        }\n      });\n    };\n    const _getTotalCount = () => {\n      return [...counter.values()].reduce((a, b) => a + b, 0);\n    };\n    let isThrottled = false;\n    return (...rest) => {\n      const now = Math.floor(Date.now() / 1e3);\n      _cleanup(now);\n      if (_getTotalCount() >= maxCount) {\n        const wasThrottled = isThrottled;\n        isThrottled = true;\n        return wasThrottled ? SKIPPED : THROTTLED;\n      }\n      isThrottled = false;\n      const count = counter.get(now) || 0;\n      counter.set(now, count + 1);\n      return fn2(...rest);\n    };\n  }\n  var ReplayContainer = class {\n    /**\n     * Recording can happen in one of three modes:\n     *   - session: Record the whole session, sending it continuously\n     *   - buffer: Always keep the last 60s of recording, requires:\n     *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs\n     *     - or calling `flush()` to send the replay\n     */\n    /**\n     * The current or last active span.\n     * This is only available when performance is enabled.\n     */\n    /**\n     * These are here so we can overwrite them in tests etc.\n     * @hidden\n     */\n    /** The replay has to be manually started, because no sample rate (neither session or error) was provided. */\n    /**\n     * Options to pass to `rrweb.record()`\n     */\n    /**\n     * Timestamp of the last user activity. This lives across sessions.\n     */\n    /**\n     * Is the integration currently active?\n     */\n    /**\n     * Paused is a state where:\n     * - DOM Recording is not listening at all\n     * - Nothing will be added to event buffer (e.g. core SDK events)\n     */\n    /**\n     * Have we attached listeners to the core SDK?\n     * Note we have to track this as there is no way to remove instrumentation handlers.\n     */\n    /**\n     * Function to stop recording\n     */\n    /**\n     * Internal use for canvas recording options\n     */\n    constructor({\n      options,\n      recordingOptions\n    }) {\n      ReplayContainer.prototype.__init.call(this);\n      ReplayContainer.prototype.__init2.call(this);\n      ReplayContainer.prototype.__init3.call(this);\n      ReplayContainer.prototype.__init4.call(this);\n      ReplayContainer.prototype.__init5.call(this);\n      ReplayContainer.prototype.__init6.call(this);\n      this.eventBuffer = null;\n      this.performanceEntries = [];\n      this.replayPerformanceEntries = [];\n      this.recordingMode = \"session\";\n      this.timeouts = {\n        sessionIdlePause: SESSION_IDLE_PAUSE_DURATION,\n        sessionIdleExpire: SESSION_IDLE_EXPIRE_DURATION\n      };\n      this._lastActivity = Date.now();\n      this._isEnabled = false;\n      this._isPaused = false;\n      this._requiresManualStart = false;\n      this._hasInitializedCoreListeners = false;\n      this._context = {\n        errorIds: /* @__PURE__ */ new Set(),\n        traceIds: /* @__PURE__ */ new Set(),\n        urls: [],\n        initialTimestamp: Date.now(),\n        initialUrl: \"\"\n      };\n      this._recordingOptions = recordingOptions;\n      this._options = options;\n      this._debouncedFlush = debounce3(() => this._flush(), this._options.flushMinDelay, {\n        maxWait: this._options.flushMaxDelay\n      });\n      this._throttledAddEvent = throttle(\n        (event, isCheckout) => addEvent(this, event, isCheckout),\n        // Max 300 events...\n        300,\n        // ... per 5s\n        5\n      );\n      const { slowClickTimeout, slowClickIgnoreSelectors } = this.getOptions();\n      const slowClickConfig = slowClickTimeout ? {\n        threshold: Math.min(SLOW_CLICK_THRESHOLD, slowClickTimeout),\n        timeout: slowClickTimeout,\n        scrollTimeout: SLOW_CLICK_SCROLL_TIMEOUT,\n        ignoreSelector: slowClickIgnoreSelectors ? slowClickIgnoreSelectors.join(\",\") : \"\"\n      } : void 0;\n      if (slowClickConfig) {\n        this.clickDetector = new ClickDetector(this, slowClickConfig);\n      }\n    }\n    /** Get the event context. */\n    getContext() {\n      return this._context;\n    }\n    /** If recording is currently enabled. */\n    isEnabled() {\n      return this._isEnabled;\n    }\n    /** If recording is currently paused. */\n    isPaused() {\n      return this._isPaused;\n    }\n    /**\n     * Determine if canvas recording is enabled\n     */\n    isRecordingCanvas() {\n      return Boolean(this._canvas);\n    }\n    /** Get the replay integration options. */\n    getOptions() {\n      return this._options;\n    }\n    /**\n     * Initializes the plugin based on sampling configuration. Should not be\n     * called outside of constructor.\n     */\n    initializeSampling(previousSessionId) {\n      const { errorSampleRate, sessionSampleRate } = this._options;\n      const requiresManualStart = errorSampleRate <= 0 && sessionSampleRate <= 0;\n      this._requiresManualStart = requiresManualStart;\n      if (requiresManualStart) {\n        return;\n      }\n      this._initializeSessionForSampling(previousSessionId);\n      if (!this.session) {\n        this._handleException(new Error(\"Unable to initialize and create session\"));\n        return;\n      }\n      if (this.session.sampled === false) {\n        return;\n      }\n      this.recordingMode = this.session.sampled === \"buffer\" && this.session.segmentId === 0 ? \"buffer\" : \"session\";\n      logInfoNextTick(\n        `[Replay] Starting replay in ${this.recordingMode} mode`,\n        this._options._experiments.traceInternals\n      );\n      this._initializeRecording();\n    }\n    /**\n     * Start a replay regardless of sampling rate. Calling this will always\n     * create a new session. Will throw an error if replay is already in progress.\n     *\n     * Creates or loads a session, attaches listeners to varying events (DOM,\n     * _performanceObserver, Recording, Sentry SDK, etc)\n     */\n    start() {\n      if (this._isEnabled && this.recordingMode === \"session\") {\n        throw new Error(\"Replay recording is already in progress\");\n      }\n      if (this._isEnabled && this.recordingMode === \"buffer\") {\n        throw new Error(\"Replay buffering is in progress, call `flush()` to save the replay\");\n      }\n      logInfoNextTick(\"[Replay] Starting replay in session mode\", this._options._experiments.traceInternals);\n      this._updateUserActivity();\n      const session = loadOrCreateSession(\n        {\n          maxReplayDuration: this._options.maxReplayDuration,\n          sessionIdleExpire: this.timeouts.sessionIdleExpire,\n          traceInternals: this._options._experiments.traceInternals\n        },\n        {\n          stickySession: this._options.stickySession,\n          // This is intentional: create a new session-based replay when calling `start()`\n          sessionSampleRate: 1,\n          allowBuffering: false\n        }\n      );\n      this.session = session;\n      this._initializeRecording();\n    }\n    /**\n     * Start replay buffering. Buffers until `flush()` is called or, if\n     * `replaysOnErrorSampleRate` > 0, an error occurs.\n     */\n    startBuffering() {\n      if (this._isEnabled) {\n        throw new Error(\"Replay recording is already in progress\");\n      }\n      logInfoNextTick(\"[Replay] Starting replay in buffer mode\", this._options._experiments.traceInternals);\n      const session = loadOrCreateSession(\n        {\n          sessionIdleExpire: this.timeouts.sessionIdleExpire,\n          maxReplayDuration: this._options.maxReplayDuration,\n          traceInternals: this._options._experiments.traceInternals\n        },\n        {\n          stickySession: this._options.stickySession,\n          sessionSampleRate: 0,\n          allowBuffering: true\n        }\n      );\n      this.session = session;\n      this.recordingMode = \"buffer\";\n      this._initializeRecording();\n    }\n    /**\n     * Start recording.\n     *\n     * Note that this will cause a new DOM checkout\n     */\n    startRecording() {\n      try {\n        const canvasOptions = this._canvas;\n        this._stopRecording = record({\n          ...this._recordingOptions,\n          // When running in error sampling mode, we need to overwrite `checkoutEveryNms`\n          // Without this, it would record forever, until an error happens, which we don't want\n          // instead, we'll always keep the last 60 seconds of replay before an error happened\n          ...this.recordingMode === \"buffer\" && { checkoutEveryNms: BUFFER_CHECKOUT_TIME },\n          emit: getHandleRecordingEmit(this),\n          onMutation: this._onMutationHandler,\n          ...canvasOptions ? {\n            recordCanvas: canvasOptions.recordCanvas,\n            getCanvasManager: canvasOptions.getCanvasManager,\n            sampling: canvasOptions.sampling,\n            dataURLOptions: canvasOptions.dataURLOptions\n          } : {}\n        });\n      } catch (err) {\n        this._handleException(err);\n      }\n    }\n    /**\n     * Stops the recording, if it was running.\n     *\n     * Returns true if it was previously stopped, or is now stopped,\n     * otherwise false.\n     */\n    stopRecording() {\n      try {\n        if (this._stopRecording) {\n          this._stopRecording();\n          this._stopRecording = void 0;\n        }\n        return true;\n      } catch (err) {\n        this._handleException(err);\n        return false;\n      }\n    }\n    /**\n     * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n     * does not support a teardown\n     */\n    async stop({ forceFlush = false, reason } = {}) {\n      if (!this._isEnabled) {\n        return;\n      }\n      this._isEnabled = false;\n      try {\n        logInfo(\n          `[Replay] Stopping Replay${reason ? ` triggered by ${reason}` : \"\"}`,\n          this._options._experiments.traceInternals\n        );\n        this._removeListeners();\n        this.stopRecording();\n        this._debouncedFlush.cancel();\n        if (forceFlush) {\n          await this._flush({ force: true });\n        }\n        this.eventBuffer && this.eventBuffer.destroy();\n        this.eventBuffer = null;\n        clearSession(this);\n      } catch (err) {\n        this._handleException(err);\n      }\n    }\n    /**\n     * Pause some replay functionality. See comments for `_isPaused`.\n     * This differs from stop as this only stops DOM recording, it is\n     * not as thorough of a shutdown as `stop()`.\n     */\n    pause() {\n      if (this._isPaused) {\n        return;\n      }\n      this._isPaused = true;\n      this.stopRecording();\n      logInfo(\"[Replay] Pausing replay\", this._options._experiments.traceInternals);\n    }\n    /**\n     * Resumes recording, see notes for `pause().\n     *\n     * Note that calling `startRecording()` here will cause a\n     * new DOM checkout.`\n     */\n    resume() {\n      if (!this._isPaused || !this._checkSession()) {\n        return;\n      }\n      this._isPaused = false;\n      this.startRecording();\n      logInfo(\"[Replay] Resuming replay\", this._options._experiments.traceInternals);\n    }\n    /**\n     * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n     * Unless `continueRecording` is false, the replay will continue to record and\n     * behave as a \"session\"-based replay.\n     *\n     * Otherwise, queue up a flush.\n     */\n    async sendBufferedReplayOrFlush({ continueRecording = true } = {}) {\n      if (this.recordingMode === \"session\") {\n        return this.flushImmediate();\n      }\n      const activityTime = Date.now();\n      logInfo(\"[Replay] Converting buffer to session\", this._options._experiments.traceInternals);\n      await this.flushImmediate();\n      const hasStoppedRecording = this.stopRecording();\n      if (!continueRecording || !hasStoppedRecording) {\n        return;\n      }\n      if (this.recordingMode === \"session\") {\n        return;\n      }\n      this.recordingMode = \"session\";\n      if (this.session) {\n        this._updateUserActivity(activityTime);\n        this._updateSessionActivity(activityTime);\n        this._maybeSaveSession();\n      }\n      this.startRecording();\n    }\n    /**\n     * We want to batch uploads of replay events. Save events only if\n     * `<flushMinDelay>` milliseconds have elapsed since the last event\n     * *OR* if `<flushMaxDelay>` milliseconds have elapsed.\n     *\n     * Accepts a callback to perform side-effects and returns true to stop batch\n     * processing and hand back control to caller.\n     */\n    addUpdate(cb) {\n      const cbResult = cb();\n      if (this.recordingMode === \"buffer\") {\n        return;\n      }\n      if (cbResult === true) {\n        return;\n      }\n      this._debouncedFlush();\n    }\n    /**\n     * Updates the user activity timestamp and resumes recording. This should be\n     * called in an event handler for a user action that we consider as the user\n     * being \"active\" (e.g. a mouse click).\n     */\n    triggerUserActivity() {\n      this._updateUserActivity();\n      if (!this._stopRecording) {\n        if (!this._checkSession()) {\n          return;\n        }\n        this.resume();\n        return;\n      }\n      this.checkAndHandleExpiredSession();\n      this._updateSessionActivity();\n    }\n    /**\n     * Updates the user activity timestamp *without* resuming\n     * recording. Some user events (e.g. keydown) can be create\n     * low-value replays that only contain the keypress as a\n     * breadcrumb. Instead this would require other events to\n     * create a new replay after a session has expired.\n     */\n    updateUserActivity() {\n      this._updateUserActivity();\n      this._updateSessionActivity();\n    }\n    /**\n     * Only flush if `this.recordingMode === 'session'`\n     */\n    conditionalFlush() {\n      if (this.recordingMode === \"buffer\") {\n        return Promise.resolve();\n      }\n      return this.flushImmediate();\n    }\n    /**\n     * Flush using debounce flush\n     */\n    flush() {\n      return this._debouncedFlush();\n    }\n    /**\n     * Always flush via `_debouncedFlush` so that we do not have flushes triggered\n     * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be\n     * cases of mulitple flushes happening closely together.\n     */\n    flushImmediate() {\n      this._debouncedFlush();\n      return this._debouncedFlush.flush();\n    }\n    /**\n     * Cancels queued up flushes.\n     */\n    cancelFlush() {\n      this._debouncedFlush.cancel();\n    }\n    /** Get the current sesion (=replay) ID */\n    getSessionId() {\n      return this.session && this.session.id;\n    }\n    /**\n     * Checks if recording should be stopped due to user inactivity. Otherwise\n     * check if session is expired and create a new session if so. Triggers a new\n     * full snapshot on new session.\n     *\n     * Returns true if session is not expired, false otherwise.\n     * @hidden\n     */\n    checkAndHandleExpiredSession() {\n      if (this._lastActivity && isExpired(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === \"session\") {\n        this.pause();\n        return;\n      }\n      if (!this._checkSession()) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Capture some initial state that can change throughout the lifespan of the\n     * replay. This is required because otherwise they would be captured at the\n     * first flush.\n     */\n    setInitialState() {\n      const urlPath = `${WINDOW6.location.pathname}${WINDOW6.location.hash}${WINDOW6.location.search}`;\n      const url = `${WINDOW6.location.origin}${urlPath}`;\n      this.performanceEntries = [];\n      this.replayPerformanceEntries = [];\n      this._clearContext();\n      this._context.initialUrl = url;\n      this._context.initialTimestamp = Date.now();\n      this._context.urls.push(url);\n    }\n    /**\n     * Add a breadcrumb event, that may be throttled.\n     * If it was throttled, we add a custom breadcrumb to indicate that.\n     */\n    throttledAddEvent(event, isCheckout) {\n      const res = this._throttledAddEvent(event, isCheckout);\n      if (res === THROTTLED) {\n        const breadcrumb = createBreadcrumb({\n          category: \"replay.throttled\"\n        });\n        this.addUpdate(() => {\n          return !addEventSync(this, {\n            type: ReplayEventTypeCustom,\n            timestamp: breadcrumb.timestamp || 0,\n            data: {\n              tag: \"breadcrumb\",\n              payload: breadcrumb,\n              metric: true\n            }\n          });\n        });\n      }\n      return res;\n    }\n    /**\n     * This will get the parametrized route name of the current page.\n     * This is only available if performance is enabled, and if an instrumented router is used.\n     */\n    getCurrentRoute() {\n      const lastActiveSpan = this.lastActiveSpan || getActiveSpan();\n      const lastRootSpan = lastActiveSpan && getRootSpan(lastActiveSpan);\n      const attributes = lastRootSpan && spanToJSON(lastRootSpan).data || {};\n      const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n      if (!lastRootSpan || !source || ![\"route\", \"custom\"].includes(source)) {\n        return void 0;\n      }\n      return spanToJSON(lastRootSpan).description;\n    }\n    /**\n     * Initialize and start all listeners to varying events (DOM,\n     * Performance Observer, Recording, Sentry SDK, etc)\n     */\n    _initializeRecording() {\n      this.setInitialState();\n      this._updateSessionActivity();\n      this.eventBuffer = createEventBuffer({\n        useCompression: this._options.useCompression,\n        workerUrl: this._options.workerUrl\n      });\n      this._removeListeners();\n      this._addListeners();\n      this._isEnabled = true;\n      this._isPaused = false;\n      this.startRecording();\n    }\n    /** A wrapper to conditionally capture exceptions. */\n    _handleException(error) {\n      DEBUG_BUILD5 && logger.error(\"[Replay]\", error);\n      if (DEBUG_BUILD5 && this._options._experiments && this._options._experiments.captureExceptions) {\n        captureException(error);\n      }\n    }\n    /**\n     * Loads (or refreshes) the current session.\n     */\n    _initializeSessionForSampling(previousSessionId) {\n      const allowBuffering = this._options.errorSampleRate > 0;\n      const session = loadOrCreateSession(\n        {\n          sessionIdleExpire: this.timeouts.sessionIdleExpire,\n          maxReplayDuration: this._options.maxReplayDuration,\n          traceInternals: this._options._experiments.traceInternals,\n          previousSessionId\n        },\n        {\n          stickySession: this._options.stickySession,\n          sessionSampleRate: this._options.sessionSampleRate,\n          allowBuffering\n        }\n      );\n      this.session = session;\n    }\n    /**\n     * Checks and potentially refreshes the current session.\n     * Returns false if session is not recorded.\n     */\n    _checkSession() {\n      if (!this.session) {\n        return false;\n      }\n      const currentSession = this.session;\n      if (shouldRefreshSession(currentSession, {\n        sessionIdleExpire: this.timeouts.sessionIdleExpire,\n        maxReplayDuration: this._options.maxReplayDuration\n      })) {\n        this._refreshSession(currentSession);\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Refresh a session with a new one.\n     * This stops the current session (without forcing a flush, as that would never work since we are expired),\n     * and then does a new sampling based on the refreshed session.\n     */\n    async _refreshSession(session) {\n      if (!this._isEnabled) {\n        return;\n      }\n      await this.stop({ reason: \"refresh session\" });\n      this.initializeSampling(session.id);\n    }\n    /**\n     * Adds listeners to record events for the replay\n     */\n    _addListeners() {\n      try {\n        WINDOW6.document.addEventListener(\"visibilitychange\", this._handleVisibilityChange);\n        WINDOW6.addEventListener(\"blur\", this._handleWindowBlur);\n        WINDOW6.addEventListener(\"focus\", this._handleWindowFocus);\n        WINDOW6.addEventListener(\"keydown\", this._handleKeyboardEvent);\n        if (this.clickDetector) {\n          this.clickDetector.addListeners();\n        }\n        if (!this._hasInitializedCoreListeners) {\n          addGlobalListeners(this);\n          this._hasInitializedCoreListeners = true;\n        }\n      } catch (err) {\n        this._handleException(err);\n      }\n      this._performanceCleanupCallback = setupPerformanceObserver(this);\n    }\n    /**\n     * Cleans up listeners that were created in `_addListeners`\n     */\n    _removeListeners() {\n      try {\n        WINDOW6.document.removeEventListener(\"visibilitychange\", this._handleVisibilityChange);\n        WINDOW6.removeEventListener(\"blur\", this._handleWindowBlur);\n        WINDOW6.removeEventListener(\"focus\", this._handleWindowFocus);\n        WINDOW6.removeEventListener(\"keydown\", this._handleKeyboardEvent);\n        if (this.clickDetector) {\n          this.clickDetector.removeListeners();\n        }\n        if (this._performanceCleanupCallback) {\n          this._performanceCleanupCallback();\n        }\n      } catch (err) {\n        this._handleException(err);\n      }\n    }\n    /**\n     * Handle when visibility of the page content changes. Opening a new tab will\n     * cause the state to change to hidden because of content of current page will\n     * be hidden. Likewise, moving a different window to cover the contents of the\n     * page will also trigger a change to a hidden state.\n     */\n    __init() {\n      this._handleVisibilityChange = () => {\n        if (WINDOW6.document.visibilityState === \"visible\") {\n          this._doChangeToForegroundTasks();\n        } else {\n          this._doChangeToBackgroundTasks();\n        }\n      };\n    }\n    /**\n     * Handle when page is blurred\n     */\n    __init2() {\n      this._handleWindowBlur = () => {\n        const breadcrumb = createBreadcrumb({\n          category: \"ui.blur\"\n        });\n        this._doChangeToBackgroundTasks(breadcrumb);\n      };\n    }\n    /**\n     * Handle when page is focused\n     */\n    __init3() {\n      this._handleWindowFocus = () => {\n        const breadcrumb = createBreadcrumb({\n          category: \"ui.focus\"\n        });\n        this._doChangeToForegroundTasks(breadcrumb);\n      };\n    }\n    /** Ensure page remains active when a key is pressed. */\n    __init4() {\n      this._handleKeyboardEvent = (event) => {\n        handleKeyboardEvent(this, event);\n      };\n    }\n    /**\n     * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)\n     */\n    _doChangeToBackgroundTasks(breadcrumb) {\n      if (!this.session) {\n        return;\n      }\n      const expired = isSessionExpired(this.session, {\n        maxReplayDuration: this._options.maxReplayDuration,\n        sessionIdleExpire: this.timeouts.sessionIdleExpire\n      });\n      if (expired) {\n        return;\n      }\n      if (breadcrumb) {\n        this._createCustomBreadcrumb(breadcrumb);\n      }\n      void this.conditionalFlush();\n    }\n    /**\n     * Tasks to run when we consider a page to be visible (via focus and/or visibility)\n     */\n    _doChangeToForegroundTasks(breadcrumb) {\n      if (!this.session) {\n        return;\n      }\n      const isSessionActive = this.checkAndHandleExpiredSession();\n      if (!isSessionActive) {\n        logInfo(\"[Replay] Document has become active, but session has expired\");\n        return;\n      }\n      if (breadcrumb) {\n        this._createCustomBreadcrumb(breadcrumb);\n      }\n    }\n    /**\n     * Update user activity (across session lifespans)\n     */\n    _updateUserActivity(_lastActivity = Date.now()) {\n      this._lastActivity = _lastActivity;\n    }\n    /**\n     * Updates the session's last activity timestamp\n     */\n    _updateSessionActivity(_lastActivity = Date.now()) {\n      if (this.session) {\n        this.session.lastActivity = _lastActivity;\n        this._maybeSaveSession();\n      }\n    }\n    /**\n     * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb\n     */\n    _createCustomBreadcrumb(breadcrumb) {\n      this.addUpdate(() => {\n        this.throttledAddEvent({\n          type: EventType.Custom,\n          timestamp: breadcrumb.timestamp || 0,\n          data: {\n            tag: \"breadcrumb\",\n            payload: breadcrumb\n          }\n        });\n      });\n    }\n    /**\n     * Observed performance events are added to `this.performanceEntries`. These\n     * are included in the replay event before it is finished and sent to Sentry.\n     */\n    _addPerformanceEntries() {\n      const performanceEntries = createPerformanceEntries(this.performanceEntries).concat(this.replayPerformanceEntries);\n      this.performanceEntries = [];\n      this.replayPerformanceEntries = [];\n      return Promise.all(createPerformanceSpans(this, performanceEntries));\n    }\n    /**\n     * Clear _context\n     */\n    _clearContext() {\n      this._context.errorIds.clear();\n      this._context.traceIds.clear();\n      this._context.urls = [];\n    }\n    /** Update the initial timestamp based on the buffer content. */\n    _updateInitialTimestampFromEventBuffer() {\n      const { session, eventBuffer } = this;\n      if (!session || !eventBuffer || this._requiresManualStart) {\n        return;\n      }\n      if (session.segmentId) {\n        return;\n      }\n      const earliestEvent = eventBuffer.getEarliestTimestamp();\n      if (earliestEvent && earliestEvent < this._context.initialTimestamp) {\n        this._context.initialTimestamp = earliestEvent;\n      }\n    }\n    /**\n     * Return and clear _context\n     */\n    _popEventContext() {\n      const _context = {\n        initialTimestamp: this._context.initialTimestamp,\n        initialUrl: this._context.initialUrl,\n        errorIds: Array.from(this._context.errorIds),\n        traceIds: Array.from(this._context.traceIds),\n        urls: this._context.urls\n      };\n      this._clearContext();\n      return _context;\n    }\n    /**\n     * Flushes replay event buffer to Sentry.\n     *\n     * Performance events are only added right before flushing - this is\n     * due to the buffered performance observer events.\n     *\n     * Should never be called directly, only by `flush`\n     */\n    async _runFlush() {\n      const replayId = this.getSessionId();\n      if (!this.session || !this.eventBuffer || !replayId) {\n        DEBUG_BUILD5 && logger.error(\"[Replay] No session or eventBuffer found to flush.\");\n        return;\n      }\n      await this._addPerformanceEntries();\n      if (!this.eventBuffer || !this.eventBuffer.hasEvents) {\n        return;\n      }\n      await addMemoryEntry(this);\n      if (!this.eventBuffer) {\n        return;\n      }\n      if (replayId !== this.getSessionId()) {\n        return;\n      }\n      try {\n        this._updateInitialTimestampFromEventBuffer();\n        const timestamp = Date.now();\n        if (timestamp - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4) {\n          throw new Error(\"Session is too long, not sending replay\");\n        }\n        const eventContext = this._popEventContext();\n        const segmentId = this.session.segmentId++;\n        this._maybeSaveSession();\n        const recordingData = await this.eventBuffer.finish();\n        await sendReplay({\n          replayId,\n          recordingData,\n          segmentId,\n          eventContext,\n          session: this.session,\n          options: this.getOptions(),\n          timestamp\n        });\n      } catch (err) {\n        this._handleException(err);\n        this.stop({ reason: \"sendReplay\" });\n        const client = getClient();\n        if (client) {\n          client.recordDroppedEvent(\"send_error\", \"replay\");\n        }\n      }\n    }\n    /**\n     * Flush recording data to Sentry. Creates a lock so that only a single flush\n     * can be active at a time. Do not call this directly.\n     */\n    __init5() {\n      this._flush = async ({\n        force = false\n      } = {}) => {\n        if (!this._isEnabled && !force) {\n          return;\n        }\n        if (!this.checkAndHandleExpiredSession()) {\n          DEBUG_BUILD5 && logger.error(\"[Replay] Attempting to finish replay event after session expired.\");\n          return;\n        }\n        if (!this.session) {\n          return;\n        }\n        const start2 = this.session.started;\n        const now = Date.now();\n        const duration = now - start2;\n        this._debouncedFlush.cancel();\n        const tooShort = duration < this._options.minReplayDuration;\n        const tooLong = duration > this._options.maxReplayDuration + 5e3;\n        if (tooShort || tooLong) {\n          logInfo(\n            `[Replay] Session duration (${Math.floor(duration / 1e3)}s) is too ${tooShort ? \"short\" : \"long\"}, not sending replay.`,\n            this._options._experiments.traceInternals\n          );\n          if (tooShort) {\n            this._debouncedFlush();\n          }\n          return;\n        }\n        const eventBuffer = this.eventBuffer;\n        if (eventBuffer && this.session.segmentId === 0 && !eventBuffer.hasCheckout) {\n          logInfo(\"[Replay] Flushing initial segment without checkout.\", this._options._experiments.traceInternals);\n        }\n        if (!this._flushLock) {\n          this._flushLock = this._runFlush();\n          await this._flushLock;\n          this._flushLock = void 0;\n          return;\n        }\n        try {\n          await this._flushLock;\n        } catch (err) {\n          DEBUG_BUILD5 && logger.error(err);\n        } finally {\n          this._debouncedFlush();\n        }\n      };\n    }\n    /** Save the session, if it is sticky */\n    _maybeSaveSession() {\n      if (this.session && this._options.stickySession) {\n        saveSession(this.session);\n      }\n    }\n    /** Handler for rrweb.record.onMutation */\n    __init6() {\n      this._onMutationHandler = (mutations) => {\n        const count = mutations.length;\n        const mutationLimit = this._options.mutationLimit;\n        const mutationBreadcrumbLimit = this._options.mutationBreadcrumbLimit;\n        const overMutationLimit = mutationLimit && count > mutationLimit;\n        if (count > mutationBreadcrumbLimit || overMutationLimit) {\n          const breadcrumb = createBreadcrumb({\n            category: \"replay.mutations\",\n            data: {\n              count,\n              limit: overMutationLimit\n            }\n          });\n          this._createCustomBreadcrumb(breadcrumb);\n        }\n        if (overMutationLimit) {\n          this.stop({ reason: \"mutationLimit\", forceFlush: this.recordingMode === \"session\" });\n          return false;\n        }\n        return true;\n      };\n    }\n  };\n  function getOption(selectors, defaultSelectors) {\n    return [\n      ...selectors,\n      // sentry defaults\n      ...defaultSelectors\n    ].join(\",\");\n  }\n  function getPrivacyOptions({ mask, unmask, block, unblock, ignore }) {\n    const defaultBlockedElements = ['base[href=\"/\"]'];\n    const maskSelector = getOption(mask, [\".sentry-mask\", \"[data-sentry-mask]\"]);\n    const unmaskSelector = getOption(unmask, []);\n    const options = {\n      // We are making the decision to make text and input selectors the same\n      maskTextSelector: maskSelector,\n      unmaskTextSelector: unmaskSelector,\n      blockSelector: getOption(block, [\".sentry-block\", \"[data-sentry-block]\", ...defaultBlockedElements]),\n      unblockSelector: getOption(unblock, []),\n      ignoreSelector: getOption(ignore, [\".sentry-ignore\", \"[data-sentry-ignore]\", 'input[type=\"file\"]'])\n    };\n    return options;\n  }\n  function maskAttribute({\n    el,\n    key,\n    maskAttributes,\n    maskAllText,\n    privacyOptions,\n    value\n  }) {\n    if (!maskAllText) {\n      return value;\n    }\n    if (privacyOptions.unmaskTextSelector && el.matches(privacyOptions.unmaskTextSelector)) {\n      return value;\n    }\n    if (maskAttributes.includes(key) || // Need to mask `value` attribute for `<input>` if it's a button-like\n    // type\n    key === \"value\" && el.tagName === \"INPUT\" && [\"submit\", \"button\"].includes(el.getAttribute(\"type\") || \"\")) {\n      return value.replace(/[\\S]/g, \"*\");\n    }\n    return value;\n  }\n  var MEDIA_SELECTORS = 'img,image,svg,video,object,picture,embed,map,audio,link[rel=\"icon\"],link[rel=\"apple-touch-icon\"]';\n  var DEFAULT_NETWORK_HEADERS = [\"content-length\", \"content-type\", \"accept\"];\n  var _initialized = false;\n  var replayIntegration = (options) => {\n    return new Replay(options);\n  };\n  var Replay = class {\n    /**\n     * @inheritDoc\n     */\n    static __initStatic() {\n      this.id = \"Replay\";\n    }\n    /**\n     * @inheritDoc\n     */\n    /**\n     * Options to pass to `rrweb.record()`\n     */\n    /**\n     * Initial options passed to the replay integration, merged with default values.\n     * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they\n     * can only be finally set when setupOnce() is called.\n     *\n     * @private\n     */\n    constructor({\n      flushMinDelay = DEFAULT_FLUSH_MIN_DELAY,\n      flushMaxDelay = DEFAULT_FLUSH_MAX_DELAY,\n      minReplayDuration = MIN_REPLAY_DURATION,\n      maxReplayDuration = MAX_REPLAY_DURATION,\n      stickySession = true,\n      useCompression = true,\n      workerUrl,\n      _experiments = {},\n      maskAllText = true,\n      maskAllInputs = true,\n      blockAllMedia = true,\n      mutationBreadcrumbLimit = 750,\n      mutationLimit = 1e4,\n      slowClickTimeout = 7e3,\n      slowClickIgnoreSelectors = [],\n      networkDetailAllowUrls = [],\n      networkDetailDenyUrls = [],\n      networkCaptureBodies = true,\n      networkRequestHeaders = [],\n      networkResponseHeaders = [],\n      mask = [],\n      maskAttributes = [\"title\", \"placeholder\"],\n      unmask = [],\n      block = [],\n      unblock = [],\n      ignore = [],\n      maskFn,\n      beforeAddRecordingEvent,\n      beforeErrorSampling\n    } = {}) {\n      this.name = Replay.id;\n      const privacyOptions = getPrivacyOptions({\n        mask,\n        unmask,\n        block,\n        unblock,\n        ignore\n      });\n      this._recordingOptions = {\n        maskAllInputs,\n        maskAllText,\n        maskInputOptions: { password: true },\n        maskTextFn: maskFn,\n        maskInputFn: maskFn,\n        maskAttributeFn: (key, value, el) => maskAttribute({\n          maskAttributes,\n          maskAllText,\n          privacyOptions,\n          key,\n          value,\n          el\n        }),\n        ...privacyOptions,\n        // Our defaults\n        slimDOMOptions: \"all\",\n        inlineStylesheet: true,\n        // Disable inline images as it will increase segment/replay size\n        inlineImages: false,\n        // collect fonts, but be aware that `sentry.io` needs to be an allowed\n        // origin for playback\n        collectFonts: true,\n        errorHandler: (err) => {\n          try {\n            err.__rrweb__ = true;\n          } catch (error) {\n          }\n        }\n      };\n      this._initialOptions = {\n        flushMinDelay,\n        flushMaxDelay,\n        minReplayDuration: Math.min(minReplayDuration, MIN_REPLAY_DURATION_LIMIT),\n        maxReplayDuration: Math.min(maxReplayDuration, MAX_REPLAY_DURATION),\n        stickySession,\n        useCompression,\n        workerUrl,\n        blockAllMedia,\n        maskAllInputs,\n        maskAllText,\n        mutationBreadcrumbLimit,\n        mutationLimit,\n        slowClickTimeout,\n        slowClickIgnoreSelectors,\n        networkDetailAllowUrls,\n        networkDetailDenyUrls,\n        networkCaptureBodies,\n        networkRequestHeaders: _getMergedNetworkHeaders(networkRequestHeaders),\n        networkResponseHeaders: _getMergedNetworkHeaders(networkResponseHeaders),\n        beforeAddRecordingEvent,\n        beforeErrorSampling,\n        _experiments\n      };\n      if (this._initialOptions.blockAllMedia) {\n        this._recordingOptions.blockSelector = !this._recordingOptions.blockSelector ? MEDIA_SELECTORS : `${this._recordingOptions.blockSelector},${MEDIA_SELECTORS}`;\n      }\n      if (this._isInitialized && isBrowser2()) {\n        throw new Error(\"Multiple Sentry Session Replay instances are not supported\");\n      }\n      this._isInitialized = true;\n    }\n    /** If replay has already been initialized */\n    get _isInitialized() {\n      return _initialized;\n    }\n    /** Update _isInitialized */\n    set _isInitialized(value) {\n      _initialized = value;\n    }\n    /**\n     * Setup and initialize replay container\n     */\n    setupOnce() {\n      if (!isBrowser2()) {\n        return;\n      }\n      this._setup();\n      setTimeout(() => this._initialize());\n    }\n    /**\n     * Start a replay regardless of sampling rate. Calling this will always\n     * create a new session. Will throw an error if replay is already in progress.\n     *\n     * Creates or loads a session, attaches listeners to varying events (DOM,\n     * PerformanceObserver, Recording, Sentry SDK, etc)\n     */\n    start() {\n      if (!this._replay) {\n        return;\n      }\n      this._replay.start();\n    }\n    /**\n     * Start replay buffering. Buffers until `flush()` is called or, if\n     * `replaysOnErrorSampleRate` > 0, until an error occurs.\n     */\n    startBuffering() {\n      if (!this._replay) {\n        return;\n      }\n      this._replay.startBuffering();\n    }\n    /**\n     * Currently, this needs to be manually called (e.g. for tests). Sentry SDK\n     * does not support a teardown\n     */\n    stop() {\n      if (!this._replay) {\n        return Promise.resolve();\n      }\n      return this._replay.stop({ forceFlush: this._replay.recordingMode === \"session\" });\n    }\n    /**\n     * If not in \"session\" recording mode, flush event buffer which will create a new replay.\n     * Unless `continueRecording` is false, the replay will continue to record and\n     * behave as a \"session\"-based replay.\n     *\n     * Otherwise, queue up a flush.\n     */\n    flush(options) {\n      if (!this._replay || !this._replay.isEnabled()) {\n        return Promise.resolve();\n      }\n      return this._replay.sendBufferedReplayOrFlush(options);\n    }\n    /**\n     * Get the current session ID.\n     */\n    getReplayId() {\n      if (!this._replay || !this._replay.isEnabled()) {\n        return;\n      }\n      return this._replay.getSessionId();\n    }\n    /**\n     * Initializes replay.\n     */\n    _initialize() {\n      if (!this._replay) {\n        return;\n      }\n      this._maybeLoadFromReplayCanvasIntegration();\n      this._replay.initializeSampling();\n    }\n    /** Setup the integration. */\n    _setup() {\n      const finalOptions = loadReplayOptionsFromClient(this._initialOptions);\n      this._replay = new ReplayContainer({\n        options: finalOptions,\n        recordingOptions: this._recordingOptions\n      });\n    }\n    /** Get canvas options from ReplayCanvas integration, if it is also added. */\n    _maybeLoadFromReplayCanvasIntegration() {\n      try {\n        const client = getClient();\n        const canvasIntegration = client.getIntegrationByName(\"ReplayCanvas\");\n        if (!canvasIntegration) {\n          return;\n        }\n        this._replay[\"_canvas\"] = canvasIntegration.getOptions();\n      } catch (e2) {\n      }\n    }\n  };\n  Replay.__initStatic();\n  function loadReplayOptionsFromClient(initialOptions) {\n    const client = getClient();\n    const opt = client && client.getOptions();\n    const finalOptions = {\n      sessionSampleRate: 0,\n      errorSampleRate: 0,\n      ...dropUndefinedKeys(initialOptions)\n    };\n    if (!opt) {\n      consoleSandbox(() => {\n        console.warn(\"SDK client is not available.\");\n      });\n      return finalOptions;\n    }\n    const replaysSessionSampleRate = parseSampleRate(opt.replaysSessionSampleRate);\n    const replaysOnErrorSampleRate = parseSampleRate(opt.replaysOnErrorSampleRate);\n    if (replaysSessionSampleRate == null && replaysOnErrorSampleRate == null) {\n      consoleSandbox(() => {\n        console.warn(\n          \"Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.\"\n        );\n      });\n    }\n    if (replaysSessionSampleRate != null) {\n      finalOptions.sessionSampleRate = replaysSessionSampleRate;\n    }\n    if (replaysOnErrorSampleRate != null) {\n      finalOptions.errorSampleRate = replaysOnErrorSampleRate;\n    }\n    return finalOptions;\n  }\n  function _getMergedNetworkHeaders(headers) {\n    return [...DEFAULT_NETWORK_HEADERS, ...headers.map((header) => header.toLowerCase())];\n  }\n\n  // node_modules/@sentry/browser/esm/tracing/request.js\n  var defaultRequestInstrumentationOptions = {\n    traceFetch: true,\n    traceXHR: true,\n    enableHTTPTimings: true\n  };\n  function instrumentOutgoingRequests(_options) {\n    const { traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, tracePropagationTargets } = {\n      traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n      traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n      ..._options\n    };\n    const shouldCreateSpan = typeof shouldCreateSpanForRequest === \"function\" ? shouldCreateSpanForRequest : (_) => true;\n    const shouldAttachHeadersWithTargets = (url) => shouldAttachHeaders(url, tracePropagationTargets);\n    const spans = {};\n    if (traceFetch) {\n      addFetchInstrumentationHandler((handlerData) => {\n        const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n        if (createdSpan) {\n          const fullUrl = getFullURL2(handlerData.fetchData.url);\n          const host = fullUrl ? parseUrl(fullUrl).host : void 0;\n          createdSpan.setAttributes({\n            \"http.url\": fullUrl,\n            \"server.address\": host\n          });\n        }\n        if (enableHTTPTimings && createdSpan) {\n          addHTTPTimings(createdSpan);\n        }\n      });\n    }\n    if (traceXHR) {\n      addXhrInstrumentationHandler((handlerData) => {\n        const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n        if (enableHTTPTimings && createdSpan) {\n          addHTTPTimings(createdSpan);\n        }\n      });\n    }\n  }\n  function isPerformanceResourceTiming(entry) {\n    return entry.entryType === \"resource\" && \"initiatorType\" in entry && typeof entry.nextHopProtocol === \"string\" && (entry.initiatorType === \"fetch\" || entry.initiatorType === \"xmlhttprequest\");\n  }\n  function addHTTPTimings(span) {\n    const { url } = spanToJSON(span).data || {};\n    if (!url || typeof url !== \"string\") {\n      return;\n    }\n    const cleanup = addPerformanceInstrumentationHandler(\"resource\", ({ entries }) => {\n      entries.forEach((entry) => {\n        if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n          const spanData = resourceTimingEntryToSpanData(entry);\n          spanData.forEach((data) => span.setAttribute(...data));\n          setTimeout(cleanup);\n        }\n      });\n    });\n  }\n  function extractNetworkProtocol(nextHopProtocol) {\n    let name2 = \"unknown\";\n    let version = \"unknown\";\n    let _name = \"\";\n    for (const char of nextHopProtocol) {\n      if (char === \"/\") {\n        [name2, version] = nextHopProtocol.split(\"/\");\n        break;\n      }\n      if (!isNaN(Number(char))) {\n        name2 = _name === \"h\" ? \"http\" : _name;\n        version = nextHopProtocol.split(_name)[1];\n        break;\n      }\n      _name += char;\n    }\n    if (_name === nextHopProtocol) {\n      name2 = _name;\n    }\n    return { name: name2, version };\n  }\n  function getAbsoluteTime2(time = 0) {\n    return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1e3;\n  }\n  function resourceTimingEntryToSpanData(resourceTiming) {\n    const { name: name2, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n    const timingSpanData = [];\n    timingSpanData.push([\"network.protocol.version\", version], [\"network.protocol.name\", name2]);\n    if (!browserPerformanceTimeOrigin) {\n      return timingSpanData;\n    }\n    return [\n      ...timingSpanData,\n      [\"http.request.redirect_start\", getAbsoluteTime2(resourceTiming.redirectStart)],\n      [\"http.request.fetch_start\", getAbsoluteTime2(resourceTiming.fetchStart)],\n      [\"http.request.domain_lookup_start\", getAbsoluteTime2(resourceTiming.domainLookupStart)],\n      [\"http.request.domain_lookup_end\", getAbsoluteTime2(resourceTiming.domainLookupEnd)],\n      [\"http.request.connect_start\", getAbsoluteTime2(resourceTiming.connectStart)],\n      [\"http.request.secure_connection_start\", getAbsoluteTime2(resourceTiming.secureConnectionStart)],\n      [\"http.request.connection_end\", getAbsoluteTime2(resourceTiming.connectEnd)],\n      [\"http.request.request_start\", getAbsoluteTime2(resourceTiming.requestStart)],\n      [\"http.request.response_start\", getAbsoluteTime2(resourceTiming.responseStart)],\n      [\"http.request.response_end\", getAbsoluteTime2(resourceTiming.responseEnd)]\n    ];\n  }\n  function shouldAttachHeaders(targetUrl, tracePropagationTargets) {\n    const href = WINDOW4.location && WINDOW4.location.href;\n    if (!href) {\n      const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n      if (!tracePropagationTargets) {\n        return isRelativeSameOriginRequest;\n      } else {\n        return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n      }\n    } else {\n      let resolvedUrl;\n      let currentOrigin;\n      try {\n        resolvedUrl = new URL(targetUrl, href);\n        currentOrigin = new URL(href).origin;\n      } catch (e2) {\n        return false;\n      }\n      const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n      if (!tracePropagationTargets) {\n        return isSameOriginRequest;\n      } else {\n        return stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) || isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets);\n      }\n    }\n  }\n  function xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeaders2, spans) {\n    const xhr = handlerData.xhr;\n    const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n    if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n      return void 0;\n    }\n    const shouldCreateSpanResult = hasTracingEnabled() && shouldCreateSpan(sentryXhrData.url);\n    if (handlerData.endTimestamp && shouldCreateSpanResult) {\n      const spanId = xhr.__sentry_xhr_span_id__;\n      if (!spanId)\n        return;\n      const span2 = spans[spanId];\n      if (span2 && sentryXhrData.status_code !== void 0) {\n        setHttpStatus(span2, sentryXhrData.status_code);\n        span2.end();\n        delete spans[spanId];\n      }\n      return void 0;\n    }\n    const fullUrl = getFullURL2(sentryXhrData.url);\n    const host = fullUrl ? parseUrl(fullUrl).host : void 0;\n    const hasParent = !!getActiveSpan();\n    const span = shouldCreateSpanResult && hasParent ? startInactiveSpan({\n      name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n      attributes: {\n        type: \"xhr\",\n        \"http.method\": sentryXhrData.method,\n        \"http.url\": fullUrl,\n        url: sentryXhrData.url,\n        \"server.address\": host,\n        [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.http.browser\",\n        [SEMANTIC_ATTRIBUTE_SENTRY_OP]: \"http.client\"\n      }\n    }) : new SentryNonRecordingSpan();\n    xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n    spans[xhr.__sentry_xhr_span_id__] = span;\n    const client = getClient();\n    if (xhr.setRequestHeader && shouldAttachHeaders2(sentryXhrData.url) && client) {\n      addTracingHeadersToXhrRequest(\n        xhr,\n        client,\n        // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n        // we do not want to use the span as base for the trace headers,\n        // which means that the headers will be generated from the scope and the sampling decision is deferred\n        hasTracingEnabled() && hasParent ? span : void 0\n      );\n    }\n    return span;\n  }\n  function addTracingHeadersToXhrRequest(xhr, client, span) {\n    const scope = getCurrentScope();\n    const isolationScope = getIsolationScope();\n    const { traceId, spanId, sampled, dsc } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext()\n    };\n    const sentryTraceHeader = span && hasTracingEnabled() ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n    const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n      dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client))\n    );\n    setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n  }\n  function setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader) {\n    try {\n      xhr.setRequestHeader(\"sentry-trace\", sentryTraceHeader);\n      if (sentryBaggageHeader) {\n        xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n      }\n    } catch (_) {\n    }\n  }\n  function getFullURL2(url) {\n    try {\n      const parsed = new URL(url, WINDOW4.location.origin);\n      return parsed.href;\n    } catch (e2) {\n      return void 0;\n    }\n  }\n\n  // node_modules/@sentry/browser/esm/tracing/backgroundtab.js\n  function registerBackgroundTabDetection() {\n    if (WINDOW4 && WINDOW4.document) {\n      WINDOW4.document.addEventListener(\"visibilitychange\", () => {\n        const activeSpan = getActiveSpan();\n        if (!activeSpan) {\n          return;\n        }\n        const rootSpan = getRootSpan(activeSpan);\n        if (WINDOW4.document.hidden && rootSpan) {\n          const cancelledStatus = \"cancelled\";\n          const { op, status } = spanToJSON(rootSpan);\n          if (DEBUG_BUILD3) {\n            logger.log(`[Tracing] Transaction: ${cancelledStatus} -> since tab moved to the background, op: ${op}`);\n          }\n          if (!status) {\n            rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message: cancelledStatus });\n          }\n          rootSpan.setAttribute(\"sentry.cancellation_reason\", \"document.hidden\");\n          rootSpan.end();\n        }\n      });\n    } else {\n      DEBUG_BUILD3 && logger.warn(\"[Tracing] Could not set up background tab detection due to lack of global document\");\n    }\n  }\n\n  // node_modules/@sentry/browser/esm/tracing/browserTracingIntegration.js\n  var BROWSER_TRACING_INTEGRATION_ID = \"BrowserTracing\";\n  var DEFAULT_BROWSER_TRACING_OPTIONS = {\n    ...TRACING_DEFAULTS,\n    instrumentNavigation: true,\n    instrumentPageLoad: true,\n    markBackgroundSpan: true,\n    enableLongTask: true,\n    enableInp: true,\n    _experiments: {},\n    ...defaultRequestInstrumentationOptions\n  };\n  var browserTracingIntegration = (_options = {}) => {\n    registerSpanErrorInstrumentation();\n    const {\n      enableInp,\n      enableLongTask,\n      _experiments: { enableInteractions },\n      beforeStartSpan,\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      markBackgroundSpan,\n      traceFetch,\n      traceXHR,\n      shouldCreateSpanForRequest,\n      enableHTTPTimings,\n      instrumentPageLoad,\n      instrumentNavigation\n    } = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options\n    };\n    const _collectWebVitals = startTrackingWebVitals();\n    if (enableInp) {\n      startTrackingINP();\n    }\n    if (enableLongTask) {\n      startTrackingLongTasks();\n    }\n    if (enableInteractions) {\n      startTrackingInteractions();\n    }\n    const latestRoute = {\n      name: void 0,\n      source: void 0\n    };\n    function _createRouteSpan(client, startSpanOptions) {\n      const isPageloadTransaction = startSpanOptions.op === \"pageload\";\n      const finalStartSpanOptions = beforeStartSpan ? beforeStartSpan(startSpanOptions) : startSpanOptions;\n      const attributes = finalStartSpanOptions.attributes || {};\n      if (startSpanOptions.name !== finalStartSpanOptions.name) {\n        attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = \"custom\";\n        finalStartSpanOptions.attributes = attributes;\n      }\n      latestRoute.name = finalStartSpanOptions.name;\n      latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n      const idleSpan = startIdleSpan(finalStartSpanOptions, {\n        idleTimeout,\n        finalTimeout,\n        childSpanTimeout,\n        // should wait for finish signal if it's a pageload transaction\n        disableAutoFinish: isPageloadTransaction,\n        beforeSpanEnd: (span) => {\n          _collectWebVitals();\n          addPerformanceEntries(span);\n        }\n      });\n      function emitFinish() {\n        if ([\"interactive\", \"complete\"].includes(WINDOW4.document.readyState)) {\n          client.emit(\"idleSpanEnableAutoFinish\", idleSpan);\n        }\n      }\n      if (isPageloadTransaction && WINDOW4.document) {\n        WINDOW4.document.addEventListener(\"readystatechange\", () => {\n          emitFinish();\n        });\n        emitFinish();\n      }\n      return idleSpan;\n    }\n    return {\n      name: BROWSER_TRACING_INTEGRATION_ID,\n      afterAllSetup(client) {\n        let activeSpan;\n        let startingUrl = WINDOW4.location && WINDOW4.location.href;\n        client.on(\"startNavigationSpan\", (startSpanOptions) => {\n          if (getClient() !== client) {\n            return;\n          }\n          if (activeSpan) {\n            DEBUG_BUILD3 && logger.log(`[Tracing] Finishing current root span with op: ${spanToJSON(activeSpan).op}`);\n            activeSpan.end();\n          }\n          activeSpan = _createRouteSpan(client, {\n            op: \"navigation\",\n            ...startSpanOptions\n          });\n        });\n        client.on(\"startPageLoadSpan\", (startSpanOptions, traceOptions = {}) => {\n          if (getClient() !== client) {\n            return;\n          }\n          if (activeSpan) {\n            DEBUG_BUILD3 && logger.log(`[Tracing] Finishing current root span with op: ${spanToJSON(activeSpan).op}`);\n            activeSpan.end();\n          }\n          const sentryTrace = traceOptions.sentryTrace || getMetaContent(\"sentry-trace\");\n          const baggage = traceOptions.baggage || getMetaContent(\"baggage\");\n          const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n          getCurrentScope().setPropagationContext(propagationContext);\n          activeSpan = _createRouteSpan(client, {\n            op: \"pageload\",\n            ...startSpanOptions\n          });\n        });\n        client.on(\"spanEnd\", (span) => {\n          const op = spanToJSON(span).op;\n          if (span !== getRootSpan(span) || op !== \"navigation\" && op !== \"pageload\") {\n            return;\n          }\n          const scope = getCurrentScope();\n          const oldPropagationContext = scope.getPropagationContext();\n          scope.setPropagationContext({\n            ...oldPropagationContext,\n            sampled: oldPropagationContext.sampled !== void 0 ? oldPropagationContext.sampled : spanIsSampled(span),\n            dsc: oldPropagationContext.dsc || getDynamicSamplingContextFromSpan(span)\n          });\n        });\n        if (WINDOW4.location) {\n          if (instrumentPageLoad) {\n            startBrowserTracingPageLoadSpan(client, {\n              name: WINDOW4.location.pathname,\n              // pageload should always start at timeOrigin (and needs to be in s, not ms)\n              startTime: browserPerformanceTimeOrigin ? browserPerformanceTimeOrigin / 1e3 : void 0,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: \"url\",\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.pageload.browser\"\n              }\n            });\n          }\n          if (instrumentNavigation) {\n            addHistoryInstrumentationHandler(({ to, from }) => {\n              if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {\n                startingUrl = void 0;\n                return;\n              }\n              if (from !== to) {\n                startingUrl = void 0;\n                startBrowserTracingNavigationSpan(client, {\n                  name: WINDOW4.location.pathname,\n                  attributes: {\n                    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: \"url\",\n                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: \"auto.navigation.browser\"\n                  }\n                });\n              }\n            });\n          }\n        }\n        if (markBackgroundSpan) {\n          registerBackgroundTabDetection();\n        }\n        if (enableInteractions) {\n          registerInteractionListener(idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n        }\n        if (enableInp) {\n          registerInpInteractionListener(latestRoute);\n        }\n        instrumentOutgoingRequests({\n          traceFetch,\n          traceXHR,\n          tracePropagationTargets: client.getOptions().tracePropagationTargets,\n          shouldCreateSpanForRequest,\n          enableHTTPTimings\n        });\n      }\n    };\n  };\n  function startBrowserTracingPageLoadSpan(client, spanOptions, traceOptions) {\n    client.emit(\"startPageLoadSpan\", spanOptions, traceOptions);\n    getCurrentScope().setTransactionName(spanOptions.name);\n    const span = getActiveSpan();\n    const op = span && spanToJSON(span).op;\n    return op === \"pageload\" ? span : void 0;\n  }\n  function startBrowserTracingNavigationSpan(client, spanOptions) {\n    getIsolationScope().setPropagationContext(generatePropagationContext());\n    getCurrentScope().setPropagationContext(generatePropagationContext());\n    client.emit(\"startNavigationSpan\", spanOptions);\n    getCurrentScope().setTransactionName(spanOptions.name);\n    const span = getActiveSpan();\n    const op = span && spanToJSON(span).op;\n    return op === \"navigation\" ? span : void 0;\n  }\n  function getMetaContent(metaName) {\n    const metaTag = getDomElement(`meta[name=${metaName}]`);\n    return metaTag ? metaTag.getAttribute(\"content\") : void 0;\n  }\n  function registerInteractionListener(idleTimeout, finalTimeout, childSpanTimeout, latestRoute) {\n    let inflightInteractionSpan;\n    const registerInteractionTransaction = () => {\n      const op = \"ui.action.click\";\n      const activeSpan = getActiveSpan();\n      const rootSpan = activeSpan && getRootSpan(activeSpan);\n      if (rootSpan) {\n        const currentRootSpanOp = spanToJSON(rootSpan).op;\n        if ([\"navigation\", \"pageload\"].includes(currentRootSpanOp)) {\n          DEBUG_BUILD3 && logger.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n          return void 0;\n        }\n      }\n      if (inflightInteractionSpan) {\n        inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, \"interactionInterrupted\");\n        inflightInteractionSpan.end();\n        inflightInteractionSpan = void 0;\n      }\n      if (!latestRoute.name) {\n        DEBUG_BUILD3 && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n        return void 0;\n      }\n      inflightInteractionSpan = startIdleSpan(\n        {\n          name: latestRoute.name,\n          op,\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || \"url\"\n          }\n        },\n        {\n          idleTimeout,\n          finalTimeout,\n          childSpanTimeout\n        }\n      );\n    };\n    if (WINDOW4.document) {\n      addEventListener(\"click\", registerInteractionTransaction, { once: false, capture: true });\n    }\n  }\n\n  // node_modules/highlight.js/es/core.js\n  var import_core20 = __toESM(require_core(), 1);\n  var core_default = import_core20.default;\n\n  // node_modules/highlight.js/es/languages/yaml.js\n  function yaml(hljs) {\n    const LITERALS2 = \"true false yes no null\";\n    const URI_CHARACTERS = \"[\\\\w#;/?:@&=+$,.~*'()[\\\\]]+\";\n    const KEY = {\n      className: \"attr\",\n      variants: [\n        { begin: \"\\\\w[\\\\w :\\\\/.-]*:(?=[ \t]|$)\" },\n        {\n          // double quoted keys\n          begin: '\"\\\\w[\\\\w :\\\\/.-]*\":(?=[ \t]|$)'\n        },\n        {\n          // single quoted keys\n          begin: \"'\\\\w[\\\\w :\\\\/.-]*':(?=[ \t]|$)\"\n        }\n      ]\n    };\n    const TEMPLATE_VARIABLES = {\n      className: \"template-variable\",\n      variants: [\n        {\n          // jinja templates Ansible\n          begin: /\\{\\{/,\n          end: /\\}\\}/\n        },\n        {\n          // Ruby i18n\n          begin: /%\\{/,\n          end: /\\}/\n        }\n      ]\n    };\n    const STRING = {\n      className: \"string\",\n      relevance: 0,\n      variants: [\n        {\n          begin: /'/,\n          end: /'/\n        },\n        {\n          begin: /\"/,\n          end: /\"/\n        },\n        { begin: /\\S+/ }\n      ],\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        TEMPLATE_VARIABLES\n      ]\n    };\n    const CONTAINER_STRING = hljs.inherit(STRING, { variants: [\n      {\n        begin: /'/,\n        end: /'/\n      },\n      {\n        begin: /\"/,\n        end: /\"/\n      },\n      { begin: /[^\\s,{}[\\]]+/ }\n    ] });\n    const DATE_RE = \"[0-9]{4}(-[0-9][0-9]){0,2}\";\n    const TIME_RE = \"([Tt \\\\t][0-9][0-9]?(:[0-9][0-9]){2})?\";\n    const FRACTION_RE = \"(\\\\.[0-9]*)?\";\n    const ZONE_RE = \"([ \\\\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\";\n    const TIMESTAMP = {\n      className: \"number\",\n      begin: \"\\\\b\" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + \"\\\\b\"\n    };\n    const VALUE_CONTAINER = {\n      end: \",\",\n      endsWithParent: true,\n      excludeEnd: true,\n      keywords: LITERALS2,\n      relevance: 0\n    };\n    const OBJECT = {\n      begin: /\\{/,\n      end: /\\}/,\n      contains: [VALUE_CONTAINER],\n      illegal: \"\\\\n\",\n      relevance: 0\n    };\n    const ARRAY = {\n      begin: \"\\\\[\",\n      end: \"\\\\]\",\n      contains: [VALUE_CONTAINER],\n      illegal: \"\\\\n\",\n      relevance: 0\n    };\n    const MODES = [\n      KEY,\n      {\n        className: \"meta\",\n        begin: \"^---\\\\s*$\",\n        relevance: 10\n      },\n      {\n        // multi line string\n        // Blocks start with a | or > followed by a newline\n        //\n        // Indentation of subsequent lines must be the same to\n        // be considered part of the block\n        className: \"string\",\n        begin: \"[\\\\|>]([1-9]?[+-])?[ ]*\\\\n( +)[^ ][^\\\\n]*\\\\n(\\\\2[^\\\\n]+\\\\n?)*\"\n      },\n      {\n        // Ruby/Rails erb\n        begin: \"<%[%=-]?\",\n        end: \"[%-]?%>\",\n        subLanguage: \"ruby\",\n        excludeBegin: true,\n        excludeEnd: true,\n        relevance: 0\n      },\n      {\n        // named tags\n        className: \"type\",\n        begin: \"!\\\\w+!\" + URI_CHARACTERS\n      },\n      // https://yaml.org/spec/1.2/spec.html#id2784064\n      {\n        // verbatim tags\n        className: \"type\",\n        begin: \"!<\" + URI_CHARACTERS + \">\"\n      },\n      {\n        // primary tags\n        className: \"type\",\n        begin: \"!\" + URI_CHARACTERS\n      },\n      {\n        // secondary tags\n        className: \"type\",\n        begin: \"!!\" + URI_CHARACTERS\n      },\n      {\n        // fragment id &ref\n        className: \"meta\",\n        begin: \"&\" + hljs.UNDERSCORE_IDENT_RE + \"$\"\n      },\n      {\n        // fragment reference *ref\n        className: \"meta\",\n        begin: \"\\\\*\" + hljs.UNDERSCORE_IDENT_RE + \"$\"\n      },\n      {\n        // array listing\n        className: \"bullet\",\n        // TODO: remove |$ hack when we have proper look-ahead support\n        begin: \"-(?=[ ]|$)\",\n        relevance: 0\n      },\n      hljs.HASH_COMMENT_MODE,\n      {\n        beginKeywords: LITERALS2,\n        keywords: { literal: LITERALS2 }\n      },\n      TIMESTAMP,\n      // numbers are any valid C-style number that\n      // sit isolated from other words\n      {\n        className: \"number\",\n        begin: hljs.C_NUMBER_RE + \"\\\\b\",\n        relevance: 0\n      },\n      OBJECT,\n      ARRAY,\n      STRING\n    ];\n    const VALUE_MODES = [...MODES];\n    VALUE_MODES.pop();\n    VALUE_MODES.push(CONTAINER_STRING);\n    VALUE_CONTAINER.contains = VALUE_MODES;\n    return {\n      name: \"YAML\",\n      case_insensitive: true,\n      aliases: [\"yml\"],\n      contains: MODES\n    };\n  }\n\n  // node_modules/highlight.js/es/languages/json.js\n  function json(hljs) {\n    const ATTRIBUTE = {\n      className: \"attr\",\n      begin: /\"(\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n      relevance: 1.01\n    };\n    const PUNCTUATION = {\n      match: /[{}[\\],:]/,\n      className: \"punctuation\",\n      relevance: 0\n    };\n    const LITERALS2 = [\n      \"true\",\n      \"false\",\n      \"null\"\n    ];\n    const LITERALS_MODE = {\n      scope: \"literal\",\n      beginKeywords: LITERALS2.join(\" \")\n    };\n    return {\n      name: \"JSON\",\n      keywords: {\n        literal: LITERALS2\n      },\n      contains: [\n        ATTRIBUTE,\n        PUNCTUATION,\n        hljs.QUOTE_STRING_MODE,\n        LITERALS_MODE,\n        hljs.C_NUMBER_MODE,\n        hljs.C_LINE_COMMENT_MODE,\n        hljs.C_BLOCK_COMMENT_MODE\n      ],\n      illegal: \"\\\\S\"\n    };\n  }\n\n  // node_modules/highlight.js/es/languages/php.js\n  function php(hljs) {\n    const regex = hljs.regex;\n    const NOT_PERL_ETC = /(?![A-Za-z0-9])(?![$])/;\n    const IDENT_RE2 = regex.concat(\n      /[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*/,\n      NOT_PERL_ETC\n    );\n    const PASCAL_CASE_CLASS_NAME_RE = regex.concat(\n      /(\\\\?[A-Z][a-z0-9_\\x7f-\\xff]+|\\\\?[A-Z]+(?=[A-Z][a-z0-9_\\x7f-\\xff])){1,}/,\n      NOT_PERL_ETC\n    );\n    const VARIABLE = {\n      scope: \"variable\",\n      match: \"\\\\$+\" + IDENT_RE2\n    };\n    const PREPROCESSOR = {\n      scope: \"meta\",\n      variants: [\n        { begin: /<\\?php/, relevance: 10 },\n        // boost for obvious PHP\n        { begin: /<\\?=/ },\n        // less relevant per PSR-1 which says not to use short-tags\n        { begin: /<\\?/, relevance: 0.1 },\n        { begin: /\\?>/ }\n        // end php tag\n      ]\n    };\n    const SUBST = {\n      scope: \"subst\",\n      variants: [\n        { begin: /\\$\\w+/ },\n        {\n          begin: /\\{\\$/,\n          end: /\\}/\n        }\n      ]\n    };\n    const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, { illegal: null });\n    const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n      illegal: null,\n      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)\n    });\n    const HEREDOC = hljs.END_SAME_AS_BEGIN({\n      begin: /<<<[ \\t]*(\\w+)\\n/,\n      end: /[ \\t]*(\\w+)\\b/,\n      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST)\n    });\n    const WHITESPACE2 = \"[ \t\\n]\";\n    const STRING = {\n      scope: \"string\",\n      variants: [\n        DOUBLE_QUOTED,\n        SINGLE_QUOTED,\n        HEREDOC\n      ]\n    };\n    const NUMBER = {\n      scope: \"number\",\n      variants: [\n        { begin: `\\\\b0[bB][01]+(?:_[01]+)*\\\\b` },\n        // Binary w/ underscore support\n        { begin: `\\\\b0[oO][0-7]+(?:_[0-7]+)*\\\\b` },\n        // Octals w/ underscore support\n        { begin: `\\\\b0[xX][\\\\da-fA-F]+(?:_[\\\\da-fA-F]+)*\\\\b` },\n        // Hex w/ underscore support\n        // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.\n        { begin: `(?:\\\\b\\\\d+(?:_\\\\d+)*(\\\\.(?:\\\\d+(?:_\\\\d+)*))?|\\\\B\\\\.\\\\d+)(?:[eE][+-]?\\\\d+)?` }\n      ],\n      relevance: 0\n    };\n    const LITERALS2 = [\n      \"false\",\n      \"null\",\n      \"true\"\n    ];\n    const KWS = [\n      // Magic constants:\n      // <https://www.php.net/manual/en/language.constants.predefined.php>\n      \"__CLASS__\",\n      \"__DIR__\",\n      \"__FILE__\",\n      \"__FUNCTION__\",\n      \"__COMPILER_HALT_OFFSET__\",\n      \"__LINE__\",\n      \"__METHOD__\",\n      \"__NAMESPACE__\",\n      \"__TRAIT__\",\n      // Function that look like language construct or language construct that look like function:\n      // List of keywords that may not require parenthesis\n      \"die\",\n      \"echo\",\n      \"exit\",\n      \"include\",\n      \"include_once\",\n      \"print\",\n      \"require\",\n      \"require_once\",\n      // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table\n      // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +\n      // Other keywords:\n      // <https://www.php.net/manual/en/reserved.php>\n      // <https://www.php.net/manual/en/language.types.type-juggling.php>\n      \"array\",\n      \"abstract\",\n      \"and\",\n      \"as\",\n      \"binary\",\n      \"bool\",\n      \"boolean\",\n      \"break\",\n      \"callable\",\n      \"case\",\n      \"catch\",\n      \"class\",\n      \"clone\",\n      \"const\",\n      \"continue\",\n      \"declare\",\n      \"default\",\n      \"do\",\n      \"double\",\n      \"else\",\n      \"elseif\",\n      \"empty\",\n      \"enddeclare\",\n      \"endfor\",\n      \"endforeach\",\n      \"endif\",\n      \"endswitch\",\n      \"endwhile\",\n      \"enum\",\n      \"eval\",\n      \"extends\",\n      \"final\",\n      \"finally\",\n      \"float\",\n      \"for\",\n      \"foreach\",\n      \"from\",\n      \"global\",\n      \"goto\",\n      \"if\",\n      \"implements\",\n      \"instanceof\",\n      \"insteadof\",\n      \"int\",\n      \"integer\",\n      \"interface\",\n      \"isset\",\n      \"iterable\",\n      \"list\",\n      \"match|0\",\n      \"mixed\",\n      \"new\",\n      \"never\",\n      \"object\",\n      \"or\",\n      \"private\",\n      \"protected\",\n      \"public\",\n      \"readonly\",\n      \"real\",\n      \"return\",\n      \"string\",\n      \"switch\",\n      \"throw\",\n      \"trait\",\n      \"try\",\n      \"unset\",\n      \"use\",\n      \"var\",\n      \"void\",\n      \"while\",\n      \"xor\",\n      \"yield\"\n    ];\n    const BUILT_INS2 = [\n      // Standard PHP library:\n      // <https://www.php.net/manual/en/book.spl.php>\n      \"Error|0\",\n      \"AppendIterator\",\n      \"ArgumentCountError\",\n      \"ArithmeticError\",\n      \"ArrayIterator\",\n      \"ArrayObject\",\n      \"AssertionError\",\n      \"BadFunctionCallException\",\n      \"BadMethodCallException\",\n      \"CachingIterator\",\n      \"CallbackFilterIterator\",\n      \"CompileError\",\n      \"Countable\",\n      \"DirectoryIterator\",\n      \"DivisionByZeroError\",\n      \"DomainException\",\n      \"EmptyIterator\",\n      \"ErrorException\",\n      \"Exception\",\n      \"FilesystemIterator\",\n      \"FilterIterator\",\n      \"GlobIterator\",\n      \"InfiniteIterator\",\n      \"InvalidArgumentException\",\n      \"IteratorIterator\",\n      \"LengthException\",\n      \"LimitIterator\",\n      \"LogicException\",\n      \"MultipleIterator\",\n      \"NoRewindIterator\",\n      \"OutOfBoundsException\",\n      \"OutOfRangeException\",\n      \"OuterIterator\",\n      \"OverflowException\",\n      \"ParentIterator\",\n      \"ParseError\",\n      \"RangeException\",\n      \"RecursiveArrayIterator\",\n      \"RecursiveCachingIterator\",\n      \"RecursiveCallbackFilterIterator\",\n      \"RecursiveDirectoryIterator\",\n      \"RecursiveFilterIterator\",\n      \"RecursiveIterator\",\n      \"RecursiveIteratorIterator\",\n      \"RecursiveRegexIterator\",\n      \"RecursiveTreeIterator\",\n      \"RegexIterator\",\n      \"RuntimeException\",\n      \"SeekableIterator\",\n      \"SplDoublyLinkedList\",\n      \"SplFileInfo\",\n      \"SplFileObject\",\n      \"SplFixedArray\",\n      \"SplHeap\",\n      \"SplMaxHeap\",\n      \"SplMinHeap\",\n      \"SplObjectStorage\",\n      \"SplObserver\",\n      \"SplPriorityQueue\",\n      \"SplQueue\",\n      \"SplStack\",\n      \"SplSubject\",\n      \"SplTempFileObject\",\n      \"TypeError\",\n      \"UnderflowException\",\n      \"UnexpectedValueException\",\n      \"UnhandledMatchError\",\n      // Reserved interfaces:\n      // <https://www.php.net/manual/en/reserved.interfaces.php>\n      \"ArrayAccess\",\n      \"BackedEnum\",\n      \"Closure\",\n      \"Fiber\",\n      \"Generator\",\n      \"Iterator\",\n      \"IteratorAggregate\",\n      \"Serializable\",\n      \"Stringable\",\n      \"Throwable\",\n      \"Traversable\",\n      \"UnitEnum\",\n      \"WeakReference\",\n      \"WeakMap\",\n      // Reserved classes:\n      // <https://www.php.net/manual/en/reserved.classes.php>\n      \"Directory\",\n      \"__PHP_Incomplete_Class\",\n      \"parent\",\n      \"php_user_filter\",\n      \"self\",\n      \"static\",\n      \"stdClass\"\n    ];\n    const dualCase = (items) => {\n      const result = [];\n      items.forEach((item) => {\n        result.push(item);\n        if (item.toLowerCase() === item) {\n          result.push(item.toUpperCase());\n        } else {\n          result.push(item.toLowerCase());\n        }\n      });\n      return result;\n    };\n    const KEYWORDS2 = {\n      keyword: KWS,\n      literal: dualCase(LITERALS2),\n      built_in: BUILT_INS2\n    };\n    const normalizeKeywords = (items) => {\n      return items.map((item) => {\n        return item.replace(/\\|\\d+$/, \"\");\n      });\n    };\n    const CONSTRUCTOR_CALL = { variants: [\n      {\n        match: [\n          /new/,\n          regex.concat(WHITESPACE2, \"+\"),\n          // to prevent built ins from being confused as the class constructor call\n          regex.concat(\"(?!\", normalizeKeywords(BUILT_INS2).join(\"\\\\b|\"), \"\\\\b)\"),\n          PASCAL_CASE_CLASS_NAME_RE\n        ],\n        scope: {\n          1: \"keyword\",\n          4: \"title.class\"\n        }\n      }\n    ] };\n    const CONSTANT_REFERENCE = regex.concat(IDENT_RE2, \"\\\\b(?!\\\\()\");\n    const LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON = { variants: [\n      {\n        match: [\n          regex.concat(\n            /::/,\n            regex.lookahead(/(?!class\\b)/)\n          ),\n          CONSTANT_REFERENCE\n        ],\n        scope: { 2: \"variable.constant\" }\n      },\n      {\n        match: [\n          /::/,\n          /class/\n        ],\n        scope: { 2: \"variable.language\" }\n      },\n      {\n        match: [\n          PASCAL_CASE_CLASS_NAME_RE,\n          regex.concat(\n            /::/,\n            regex.lookahead(/(?!class\\b)/)\n          ),\n          CONSTANT_REFERENCE\n        ],\n        scope: {\n          1: \"title.class\",\n          3: \"variable.constant\"\n        }\n      },\n      {\n        match: [\n          PASCAL_CASE_CLASS_NAME_RE,\n          regex.concat(\n            \"::\",\n            regex.lookahead(/(?!class\\b)/)\n          )\n        ],\n        scope: { 1: \"title.class\" }\n      },\n      {\n        match: [\n          PASCAL_CASE_CLASS_NAME_RE,\n          /::/,\n          /class/\n        ],\n        scope: {\n          1: \"title.class\",\n          3: \"variable.language\"\n        }\n      }\n    ] };\n    const NAMED_ARGUMENT = {\n      scope: \"attr\",\n      match: regex.concat(IDENT_RE2, regex.lookahead(\":\"), regex.lookahead(/(?!::)/))\n    };\n    const PARAMS_MODE = {\n      relevance: 0,\n      begin: /\\(/,\n      end: /\\)/,\n      keywords: KEYWORDS2,\n      contains: [\n        NAMED_ARGUMENT,\n        VARIABLE,\n        LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,\n        hljs.C_BLOCK_COMMENT_MODE,\n        STRING,\n        NUMBER,\n        CONSTRUCTOR_CALL\n      ]\n    };\n    const FUNCTION_INVOKE = {\n      relevance: 0,\n      match: [\n        /\\b/,\n        // to prevent keywords from being confused as the function title\n        regex.concat(\"(?!fn\\\\b|function\\\\b|\", normalizeKeywords(KWS).join(\"\\\\b|\"), \"|\", normalizeKeywords(BUILT_INS2).join(\"\\\\b|\"), \"\\\\b)\"),\n        IDENT_RE2,\n        regex.concat(WHITESPACE2, \"*\"),\n        regex.lookahead(/(?=\\()/)\n      ],\n      scope: { 3: \"title.function.invoke\" },\n      contains: [PARAMS_MODE]\n    };\n    PARAMS_MODE.contains.push(FUNCTION_INVOKE);\n    const ATTRIBUTE_CONTAINS = [\n      NAMED_ARGUMENT,\n      LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,\n      hljs.C_BLOCK_COMMENT_MODE,\n      STRING,\n      NUMBER,\n      CONSTRUCTOR_CALL\n    ];\n    const ATTRIBUTES = {\n      begin: regex.concat(/#\\[\\s*/, PASCAL_CASE_CLASS_NAME_RE),\n      beginScope: \"meta\",\n      end: /]/,\n      endScope: \"meta\",\n      keywords: {\n        literal: LITERALS2,\n        keyword: [\n          \"new\",\n          \"array\"\n        ]\n      },\n      contains: [\n        {\n          begin: /\\[/,\n          end: /]/,\n          keywords: {\n            literal: LITERALS2,\n            keyword: [\n              \"new\",\n              \"array\"\n            ]\n          },\n          contains: [\n            \"self\",\n            ...ATTRIBUTE_CONTAINS\n          ]\n        },\n        ...ATTRIBUTE_CONTAINS,\n        {\n          scope: \"meta\",\n          match: PASCAL_CASE_CLASS_NAME_RE\n        }\n      ]\n    };\n    return {\n      case_insensitive: false,\n      keywords: KEYWORDS2,\n      contains: [\n        ATTRIBUTES,\n        hljs.HASH_COMMENT_MODE,\n        hljs.COMMENT(\"//\", \"$\"),\n        hljs.COMMENT(\n          \"/\\\\*\",\n          \"\\\\*/\",\n          { contains: [\n            {\n              scope: \"doctag\",\n              match: \"@[A-Za-z]+\"\n            }\n          ] }\n        ),\n        {\n          match: /__halt_compiler\\(\\);/,\n          keywords: \"__halt_compiler\",\n          starts: {\n            scope: \"comment\",\n            end: hljs.MATCH_NOTHING_RE,\n            contains: [\n              {\n                match: /\\?>/,\n                scope: \"meta\",\n                endsParent: true\n              }\n            ]\n          }\n        },\n        PREPROCESSOR,\n        {\n          scope: \"variable.language\",\n          match: /\\$this\\b/\n        },\n        VARIABLE,\n        FUNCTION_INVOKE,\n        LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,\n        {\n          match: [\n            /const/,\n            /\\s/,\n            IDENT_RE2\n          ],\n          scope: {\n            1: \"keyword\",\n            3: \"variable.constant\"\n          }\n        },\n        CONSTRUCTOR_CALL,\n        {\n          scope: \"function\",\n          relevance: 0,\n          beginKeywords: \"fn function\",\n          end: /[;{]/,\n          excludeEnd: true,\n          illegal: \"[$%\\\\[]\",\n          contains: [\n            { beginKeywords: \"use\" },\n            hljs.UNDERSCORE_TITLE_MODE,\n            {\n              begin: \"=>\",\n              // No markup, just a relevance booster\n              endsParent: true\n            },\n            {\n              scope: \"params\",\n              begin: \"\\\\(\",\n              end: \"\\\\)\",\n              excludeBegin: true,\n              excludeEnd: true,\n              keywords: KEYWORDS2,\n              contains: [\n                \"self\",\n                VARIABLE,\n                LEFT_AND_RIGHT_SIDE_OF_DOUBLE_COLON,\n                hljs.C_BLOCK_COMMENT_MODE,\n                STRING,\n                NUMBER\n              ]\n            }\n          ]\n        },\n        {\n          scope: \"class\",\n          variants: [\n            {\n              beginKeywords: \"enum\",\n              illegal: /[($\"]/\n            },\n            {\n              beginKeywords: \"class interface trait\",\n              illegal: /[:($\"]/\n            }\n          ],\n          relevance: 0,\n          end: /\\{/,\n          excludeEnd: true,\n          contains: [\n            { beginKeywords: \"extends implements\" },\n            hljs.UNDERSCORE_TITLE_MODE\n          ]\n        },\n        // both use and namespace still use \"old style\" rules (vs multi-match)\n        // because the namespace name can include `\\` and we still want each\n        // element to be treated as its own *individual* title\n        {\n          beginKeywords: \"namespace\",\n          relevance: 0,\n          end: \";\",\n          illegal: /[.']/,\n          contains: [hljs.inherit(hljs.UNDERSCORE_TITLE_MODE, { scope: \"title.class\" })]\n        },\n        {\n          beginKeywords: \"use\",\n          relevance: 0,\n          end: \";\",\n          contains: [\n            // TODO: title.function vs title.class\n            {\n              match: /\\b(as|const|function)\\b/,\n              scope: \"keyword\"\n            },\n            // TODO: could be title.class or title.function\n            hljs.UNDERSCORE_TITLE_MODE\n          ]\n        },\n        STRING,\n        NUMBER\n      ]\n    };\n  }\n\n  // node_modules/highlight.js/es/languages/xml.js\n  function xml(hljs) {\n    const regex = hljs.regex;\n    const TAG_NAME_RE = regex.concat(/[\\p{L}_]/u, regex.optional(/[\\p{L}0-9_.-]*:/u), /[\\p{L}0-9_.-]*/u);\n    const XML_IDENT_RE = /[\\p{L}0-9._:-]+/u;\n    const XML_ENTITIES = {\n      className: \"symbol\",\n      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n      begin: /\\s/,\n      contains: [\n        {\n          className: \"keyword\",\n          begin: /#?[a-z_][a-z1-9_-]+/,\n          illegal: /\\n/\n        }\n      ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n      begin: /\\(/,\n      end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: \"string\" });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: \"string\" });\n    const TAG_INTERNALS = {\n      endsWithParent: true,\n      illegal: /</,\n      relevance: 0,\n      contains: [\n        {\n          className: \"attr\",\n          begin: XML_IDENT_RE,\n          relevance: 0\n        },\n        {\n          begin: /=\\s*/,\n          relevance: 0,\n          contains: [\n            {\n              className: \"string\",\n              endsParent: true,\n              variants: [\n                {\n                  begin: /\"/,\n                  end: /\"/,\n                  contains: [XML_ENTITIES]\n                },\n                {\n                  begin: /'/,\n                  end: /'/,\n                  contains: [XML_ENTITIES]\n                },\n                { begin: /[^\\s\"'=<>`]+/ }\n              ]\n            }\n          ]\n        }\n      ]\n    };\n    return {\n      name: \"HTML, XML\",\n      aliases: [\n        \"html\",\n        \"xhtml\",\n        \"rss\",\n        \"atom\",\n        \"xjb\",\n        \"xsd\",\n        \"xsl\",\n        \"plist\",\n        \"wsf\",\n        \"svg\"\n      ],\n      case_insensitive: true,\n      unicodeRegex: true,\n      contains: [\n        {\n          className: \"meta\",\n          begin: /<![a-z]/,\n          end: />/,\n          relevance: 10,\n          contains: [\n            XML_META_KEYWORDS,\n            QUOTE_META_STRING_MODE,\n            APOS_META_STRING_MODE,\n            XML_META_PAR_KEYWORDS,\n            {\n              begin: /\\[/,\n              end: /\\]/,\n              contains: [\n                {\n                  className: \"meta\",\n                  begin: /<![a-z]/,\n                  end: />/,\n                  contains: [\n                    XML_META_KEYWORDS,\n                    XML_META_PAR_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        hljs.COMMENT(\n          /<!--/,\n          /-->/,\n          { relevance: 10 }\n        ),\n        {\n          begin: /<!\\[CDATA\\[/,\n          end: /\\]\\]>/,\n          relevance: 10\n        },\n        XML_ENTITIES,\n        // xml processing instructions\n        {\n          className: \"meta\",\n          end: /\\?>/,\n          variants: [\n            {\n              begin: /<\\?xml/,\n              relevance: 10,\n              contains: [\n                QUOTE_META_STRING_MODE\n              ]\n            },\n            {\n              begin: /<\\?[a-z][a-z0-9]+/\n            }\n          ]\n        },\n        {\n          className: \"tag\",\n          /*\n          The lookahead pattern (?=...) ensures that 'begin' only matches\n          '<style' as a single word, followed by a whitespace or an\n          ending bracket.\n          */\n          begin: /<style(?=\\s|>)/,\n          end: />/,\n          keywords: { name: \"style\" },\n          contains: [TAG_INTERNALS],\n          starts: {\n            end: /<\\/style>/,\n            returnEnd: true,\n            subLanguage: [\n              \"css\",\n              \"xml\"\n            ]\n          }\n        },\n        {\n          className: \"tag\",\n          // See the comment in the <style tag about the lookahead pattern\n          begin: /<script(?=\\s|>)/,\n          end: />/,\n          keywords: { name: \"script\" },\n          contains: [TAG_INTERNALS],\n          starts: {\n            end: /<\\/script>/,\n            returnEnd: true,\n            subLanguage: [\n              \"javascript\",\n              \"handlebars\",\n              \"xml\"\n            ]\n          }\n        },\n        // we need this for now for jSX\n        {\n          className: \"tag\",\n          begin: /<>|<\\/>/\n        },\n        // open tag\n        {\n          className: \"tag\",\n          begin: regex.concat(\n            /</,\n            regex.lookahead(regex.concat(\n              TAG_NAME_RE,\n              // <tag/>\n              // <tag>\n              // <tag ...\n              regex.either(/\\/>/, />/, /\\s/)\n            ))\n          ),\n          end: /\\/?>/,\n          contains: [\n            {\n              className: \"name\",\n              begin: TAG_NAME_RE,\n              relevance: 0,\n              starts: TAG_INTERNALS\n            }\n          ]\n        },\n        // close tag\n        {\n          className: \"tag\",\n          begin: regex.concat(\n            /<\\//,\n            regex.lookahead(regex.concat(\n              TAG_NAME_RE,\n              />/\n            ))\n          ),\n          contains: [\n            {\n              className: \"name\",\n              begin: TAG_NAME_RE,\n              relevance: 0\n            },\n            {\n              begin: />/,\n              relevance: 0,\n              endsParent: true\n            }\n          ]\n        }\n      ]\n    };\n  }\n\n  // node_modules/highlight.js/es/languages/shell.js\n  function shell(hljs) {\n    return {\n      name: \"Shell Session\",\n      aliases: [\n        \"console\",\n        \"shellsession\"\n      ],\n      contains: [\n        {\n          className: \"meta.prompt\",\n          // We cannot add \\s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.\n          // For instance, in the following example, it would match \"echo /path/to/home >\" as a prompt:\n          // echo /path/to/home > t.exe\n          begin: /^\\s{0,3}[/~\\w\\d[\\]()@-]*[>%$#][ ]?/,\n          starts: {\n            end: /[^\\\\](?=\\s*$)/,\n            subLanguage: \"bash\"\n          }\n        }\n      ]\n    };\n  }\n\n  // node_modules/highlight.js/es/languages/javascript.js\n  var IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\n  var KEYWORDS = [\n    \"as\",\n    // for exports\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    // JS handles these with a special rule\n    // \"get\",\n    // \"set\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n  ];\n  var LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n    \"NaN\",\n    \"Infinity\"\n  ];\n  var TYPES = [\n    // Fundamental objects\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    // numbers and dates\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    // text\n    \"String\",\n    \"RegExp\",\n    // Indexed collections\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    // Keyed collections\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    // Structured data\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    // Control abstraction objects\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    // Reflection\n    \"Reflect\",\n    \"Proxy\",\n    // Internationalization\n    \"Intl\",\n    // WebAssembly\n    \"WebAssembly\"\n  ];\n  var ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n  ];\n  var BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n  ];\n  var BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"module\",\n    \"global\"\n    // Node.js\n  ];\n  var BUILT_INS = [].concat(\n    BUILT_IN_GLOBALS,\n    TYPES,\n    ERROR_TYPES\n  );\n  function javascript(hljs) {\n    const regex = hljs.regex;\n    const hasClosingTag = (match, { after }) => {\n      const tag = \"</\" + match[0].slice(1);\n      const pos = match.input.indexOf(tag, after);\n      return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n      begin: \"<>\",\n      end: \"</>\"\n    };\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n      begin: /<[A-Za-z0-9\\\\._:-]+/,\n      end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n      /**\n       * @param {RegExpMatchArray} match\n       * @param {CallbackResponse} response\n       */\n      isTrulyOpeningTag: (match, response) => {\n        const afterMatchIndex = match[0].length + match.index;\n        const nextChar = match.input[afterMatchIndex];\n        if (\n          // HTML should not include another raw `<` inside a tag\n          // nested type?\n          // `<Array<Array<number>>`, etc.\n          nextChar === \"<\" || // the , gives away that this is not HTML\n          // `<T, A extends keyof T, V>`\n          nextChar === \",\"\n        ) {\n          response.ignoreMatch();\n          return;\n        }\n        if (nextChar === \">\") {\n          if (!hasClosingTag(match, { after: afterMatchIndex })) {\n            response.ignoreMatch();\n          }\n        }\n        let m;\n        const afterMatch = match.input.substring(afterMatchIndex);\n        if (m = afterMatch.match(/^\\s*=/)) {\n          response.ignoreMatch();\n          return;\n        }\n        if (m = afterMatch.match(/^\\s+extends\\s+/)) {\n          if (m.index === 0) {\n            response.ignoreMatch();\n            return;\n          }\n        }\n      }\n    };\n    const KEYWORDS$1 = {\n      $pattern: IDENT_RE,\n      keyword: KEYWORDS,\n      literal: LITERALS,\n      built_in: BUILT_INS,\n      \"variable.language\": BUILT_IN_VARIABLES\n    };\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n      className: \"number\",\n      variants: [\n        // DecimalLiteral\n        { begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\\\b` },\n        { begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b` },\n        // DecimalBigIntegerLiteral\n        { begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b` },\n        // NonDecimalIntegerLiteral\n        { begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\" },\n        { begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\" },\n        { begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\" },\n        // LegacyOctalIntegerLiteral (does not include underscore separators)\n        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n        { begin: \"\\\\b0[0-7]+n?\\\\b\" }\n      ],\n      relevance: 0\n    };\n    const SUBST = {\n      className: \"subst\",\n      begin: \"\\\\$\\\\{\",\n      end: \"\\\\}\",\n      keywords: KEYWORDS$1,\n      contains: []\n      // defined later\n    };\n    const HTML_TEMPLATE = {\n      begin: \"html`\",\n      end: \"\",\n      starts: {\n        end: \"`\",\n        returnEnd: false,\n        contains: [\n          hljs.BACKSLASH_ESCAPE,\n          SUBST\n        ],\n        subLanguage: \"xml\"\n      }\n    };\n    const CSS_TEMPLATE = {\n      begin: \"css`\",\n      end: \"\",\n      starts: {\n        end: \"`\",\n        returnEnd: false,\n        contains: [\n          hljs.BACKSLASH_ESCAPE,\n          SUBST\n        ],\n        subLanguage: \"css\"\n      }\n    };\n    const TEMPLATE_STRING = {\n      className: \"string\",\n      begin: \"`\",\n      end: \"`\",\n      contains: [\n        hljs.BACKSLASH_ESCAPE,\n        SUBST\n      ]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(\n      /\\/\\*\\*(?!\\/)/,\n      \"\\\\*/\",\n      {\n        relevance: 0,\n        contains: [\n          {\n            begin: \"(?=@[A-Za-z]+)\",\n            relevance: 0,\n            contains: [\n              {\n                className: \"doctag\",\n                begin: \"@[A-Za-z]+\"\n              },\n              {\n                className: \"type\",\n                begin: \"\\\\{\",\n                end: \"\\\\}\",\n                excludeEnd: true,\n                excludeBegin: true,\n                relevance: 0\n              },\n              {\n                className: \"variable\",\n                begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                endsParent: true,\n                relevance: 0\n              },\n              // eat spaces (not newlines) so we can find\n              // types or variables\n              {\n                begin: /(?=[^\\n])\\s/,\n                relevance: 0\n              }\n            ]\n          }\n        ]\n      }\n    );\n    const COMMENT = {\n      className: \"comment\",\n      variants: [\n        JSDOC_COMMENT,\n        hljs.C_BLOCK_COMMENT_MODE,\n        hljs.C_LINE_COMMENT_MODE\n      ]\n    };\n    const SUBST_INTERNALS = [\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      HTML_TEMPLATE,\n      CSS_TEMPLATE,\n      TEMPLATE_STRING,\n      // Skip numbers when they are part of a variable name\n      { match: /\\$\\d+/ },\n      NUMBER\n      // This is intentional:\n      // See https://github.com/highlightjs/highlight.js/issues/3288\n      // hljs.REGEXP_MODE\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n      // we need to pair up {} inside our subst to prevent\n      // it from ending too early by matching another }\n      begin: /\\{/,\n      end: /\\}/,\n      keywords: KEYWORDS$1,\n      contains: [\n        \"self\"\n      ].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n      // eat recursive parens in sub expressions\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        keywords: KEYWORDS$1,\n        contains: [\"self\"].concat(SUBST_AND_COMMENTS)\n      }\n    ]);\n    const PARAMS = {\n      className: \"params\",\n      begin: /\\(/,\n      end: /\\)/,\n      excludeBegin: true,\n      excludeEnd: true,\n      keywords: KEYWORDS$1,\n      contains: PARAMS_CONTAINS\n    };\n    const CLASS_OR_EXTENDS = {\n      variants: [\n        // class Car extends vehicle\n        {\n          match: [\n            /class/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s+/,\n            /extends/,\n            /\\s+/,\n            regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n          ],\n          scope: {\n            1: \"keyword\",\n            3: \"title.class\",\n            5: \"keyword\",\n            7: \"title.class.inherited\"\n          }\n        },\n        // class Car\n        {\n          match: [\n            /class/,\n            /\\s+/,\n            IDENT_RE$1\n          ],\n          scope: {\n            1: \"keyword\",\n            3: \"title.class\"\n          }\n        }\n      ]\n    };\n    const CLASS_REFERENCE = {\n      relevance: 0,\n      match: regex.either(\n        // Hard coded exceptions\n        /\\bJSON/,\n        // Float32Array, OutT\n        /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/,\n        // CSSFactory, CSSFactoryT\n        /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/,\n        // FPs, FPsT\n        /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/\n        // P\n        // single letters are not highlighted\n        // BLAH\n        // this will be flagged as a UPPER_CASE_CONSTANT instead\n      ),\n      className: \"title.class\",\n      keywords: {\n        _: [\n          // se we still get relevance credit for JS library classes\n          ...TYPES,\n          ...ERROR_TYPES\n        ]\n      }\n    };\n    const USE_STRICT = {\n      label: \"use_strict\",\n      className: \"meta\",\n      relevance: 10,\n      begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n      variants: [\n        {\n          match: [\n            /function/,\n            /\\s+/,\n            IDENT_RE$1,\n            /(?=\\s*\\()/\n          ]\n        },\n        // anonymous function\n        {\n          match: [\n            /function/,\n            /\\s*(?=\\()/\n          ]\n        }\n      ],\n      className: {\n        1: \"keyword\",\n        3: \"title.function\"\n      },\n      label: \"func.def\",\n      contains: [PARAMS],\n      illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n      relevance: 0,\n      match: /\\b[A-Z][A-Z_0-9]+\\b/,\n      className: \"variable.constant\"\n    };\n    function noneOf(list) {\n      return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n      match: regex.concat(\n        /\\b/,\n        noneOf([\n          ...BUILT_IN_GLOBALS,\n          \"super\",\n          \"import\"\n        ]),\n        IDENT_RE$1,\n        regex.lookahead(/\\(/)\n      ),\n      className: \"title.function\",\n      relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n      begin: regex.concat(/\\./, regex.lookahead(\n        regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/)\n      )),\n      end: IDENT_RE$1,\n      excludeBegin: true,\n      keywords: \"prototype\",\n      className: \"property\",\n      relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n      match: [\n        /get|set/,\n        /\\s+/,\n        IDENT_RE$1,\n        /(?=\\()/\n      ],\n      className: {\n        1: \"keyword\",\n        3: \"title.function\"\n      },\n      contains: [\n        {\n          // eat to avoid empty params\n          begin: /\\(\\)/\n        },\n        PARAMS\n      ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\([^()]*(\\\\([^()]*(\\\\([^()]*\\\\)[^()]*)*\\\\)[^()]*)*\\\\)|\" + hljs.UNDERSCORE_IDENT_RE + \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n      match: [\n        /const|var|let/,\n        /\\s+/,\n        IDENT_RE$1,\n        /\\s*/,\n        /=\\s*/,\n        /(async\\s*)?/,\n        // async is optional\n        regex.lookahead(FUNC_LEAD_IN_RE)\n      ],\n      keywords: \"async\",\n      className: {\n        1: \"keyword\",\n        3: \"title.function\"\n      },\n      contains: [\n        PARAMS\n      ]\n    };\n    return {\n      name: \"Javascript\",\n      aliases: [\"js\", \"jsx\", \"mjs\", \"cjs\"],\n      keywords: KEYWORDS$1,\n      // this will be extended by TypeScript\n      exports: { PARAMS_CONTAINS, CLASS_REFERENCE },\n      illegal: /#(?![$_A-z])/,\n      contains: [\n        hljs.SHEBANG({\n          label: \"shebang\",\n          binary: \"node\",\n          relevance: 5\n        }),\n        USE_STRICT,\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        TEMPLATE_STRING,\n        COMMENT,\n        // Skip numbers when they are part of a variable name\n        { match: /\\$\\d+/ },\n        NUMBER,\n        CLASS_REFERENCE,\n        {\n          className: \"attr\",\n          begin: IDENT_RE$1 + regex.lookahead(\":\"),\n          relevance: 0\n        },\n        FUNCTION_VARIABLE,\n        {\n          // \"value\" container\n          begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n          keywords: \"return throw case\",\n          relevance: 0,\n          contains: [\n            COMMENT,\n            hljs.REGEXP_MODE,\n            {\n              className: \"function\",\n              // we have to count the parens to make sure we actually have the\n              // correct bounding ( ) before the =>.  There could be any number of\n              // sub-expressions inside also surrounded by parens.\n              begin: FUNC_LEAD_IN_RE,\n              returnBegin: true,\n              end: \"\\\\s*=>\",\n              contains: [\n                {\n                  className: \"params\",\n                  variants: [\n                    {\n                      begin: hljs.UNDERSCORE_IDENT_RE,\n                      relevance: 0\n                    },\n                    {\n                      className: null,\n                      begin: /\\(\\s*\\)/,\n                      skip: true\n                    },\n                    {\n                      begin: /\\(/,\n                      end: /\\)/,\n                      excludeBegin: true,\n                      excludeEnd: true,\n                      keywords: KEYWORDS$1,\n                      contains: PARAMS_CONTAINS\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              // could be a comma delimited list of params to a function call\n              begin: /,/,\n              relevance: 0\n            },\n            {\n              match: /\\s+/,\n              relevance: 0\n            },\n            {\n              // JSX\n              variants: [\n                { begin: FRAGMENT.begin, end: FRAGMENT.end },\n                { match: XML_SELF_CLOSING },\n                {\n                  begin: XML_TAG.begin,\n                  // we carefully check the opening tag to see if it truly\n                  // is a tag and not a false positive\n                  \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                  end: XML_TAG.end\n                }\n              ],\n              subLanguage: \"xml\",\n              contains: [\n                {\n                  begin: XML_TAG.begin,\n                  end: XML_TAG.end,\n                  skip: true,\n                  contains: [\"self\"]\n                }\n              ]\n            }\n          ]\n        },\n        FUNCTION_DEFINITION,\n        {\n          // prevent this from getting swallowed up by function\n          // since they appear \"function like\"\n          beginKeywords: \"while if switch catch for\"\n        },\n        {\n          // we have to count the parens to make sure we actually have the correct\n          // bounding ( ).  There could be any number of sub-expressions inside\n          // also surrounded by parens.\n          begin: \"\\\\b(?!function)\" + hljs.UNDERSCORE_IDENT_RE + \"\\\\([^()]*(\\\\([^()]*(\\\\([^()]*\\\\)[^()]*)*\\\\)[^()]*)*\\\\)\\\\s*\\\\{\",\n          // end parens\n          returnBegin: true,\n          label: \"func.def\",\n          contains: [\n            PARAMS,\n            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1, className: \"title.function\" })\n          ]\n        },\n        // catch ... so it won't trigger the property rule below\n        {\n          match: /\\.\\.\\./,\n          relevance: 0\n        },\n        PROPERTY_ACCESS,\n        // hack: prevents detection of keywords in some circumstances\n        // .keyword()\n        // $keyword = x\n        {\n          match: \"\\\\$\" + IDENT_RE$1,\n          relevance: 0\n        },\n        {\n          match: [/\\bconstructor(?=\\s*\\()/],\n          className: { 1: \"title.function\" },\n          contains: [PARAMS]\n        },\n        FUNCTION_CALL,\n        UPPER_CASE_CONSTANT,\n        CLASS_OR_EXTENDS,\n        GETTER_OR_SETTER,\n        {\n          match: /\\$[(.]/\n          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n        }\n      ]\n    };\n  }\n\n  // js/highlight.ts\n  core_default.registerLanguage(\"iok\", yaml);\n  core_default.registerLanguage(\"yaml\", yaml);\n  core_default.registerLanguage(\"json\", json);\n  core_default.registerLanguage(\"php\", php);\n  core_default.registerLanguage(\"html\", xml);\n  core_default.registerLanguage(\"javascript\", javascript);\n  core_default.registerLanguage(\"css\", javascript);\n  core_default.registerLanguage(\"shell\", shell);\n  core_default.registerLanguage(\"yara\", function(hljs) {\n    return {\n      name: \"YARA\",\n      aliases: [\"yara\", \"yar\"],\n      case_insensitive: false,\n      keywords: {\n        built_in: \"all and any ascii at base64 base64wide condition contains endswith entrypoint false filesize for fullword global icontains iendswith import in include int16 int16be int32 int32be int8 int8be istartswith matches meta nocase not of or private rule startswith strings them true uint16 uint16be uint32 uint32be uint8 uint8be wide xor\",\n        literal: \"true false\"\n      },\n      contains: [\n        hljs.C_LINE_COMMENT_MODE,\n        hljs.QUOTE_STRING_MODE,\n        // HEX string,\n        {\n          className: \"string\",\n          begin: \"=\\\\s*{\",\n          end: \"}\",\n          excludeBegin: true,\n          excludeEnd: true\n        },\n        // Regexp string\n        {\n          className: \"string\",\n          begin: \"\\\\/.*?[^\\\\\\\\]/(i|c|x|t|s|m|p|w|n|J|U|d|b|e|q|x)*\"\n        },\n        // HEX number,\n        {\n          className: \"number\",\n          begin: \"\\\\b0x[a-fA-F0-9]+\\\\b\"\n        },\n        // Decimal number,\n        {\n          className: \"number\",\n          begin: \"\\\\b[0-9]+(MB|KB)?\\\\b\"\n        },\n        // string identifier\n        {\n          className: \"symbol\",\n          begin: \"(\\\\$|\\\\#|\\\\@)[a-zA-Z0-9_]+\"\n        }\n      ]\n    };\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"pre code\").forEach((e2) => {\n      if (e2.querySelector(\"[class^=hljs-string]\")) {\n        return;\n      }\n      core_default.highlightElement(e2);\n    });\n  });\n  htmx_esm_default.onLoad(() => {\n    if (!window.mermaid) {\n      return;\n    }\n    mermaid.initialize({\n      startOnLoad: true,\n      flowchart: {\n        useMaxWidth: true\n      }\n    });\n  });\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/utils/events.js\n  var EventEmitter = class {\n    /**\n     * Construct EventEmitter\n     * \n     * @param {Array} listeners \n     */\n    constructor(listeners = []) {\n      this._listeners = new Map(listeners);\n      this._events = /* @__PURE__ */ new Map();\n    }\n    /**\n        * Destroys EventEmitter\n        */\n    destroy() {\n      this._listeners = {};\n      this.events = [];\n    }\n    /**\n     * Count listeners registered for the provided eventName\n     * \n     * @param {string} eventName \n     */\n    listenerCount(eventName) {\n      if (!this._listeners.has(eventName)) {\n        return 0;\n      }\n      return this._listeners.get(eventName).length;\n    }\n    /**\n        * Subscribes on event eventName specified function\n     * \n        * @param {string} eventName\n        * @param {function} listener\n        */\n    on(eventName, listener) {\n      this._addListener(eventName, listener, false);\n    }\n    /**\n        * Subscribes on event name specified function to fire only once\n     * \n        * @param {string} eventName\n        * @param {function} listener\n        */\n    once(eventName, listener) {\n      this._addListener(eventName, listener, true);\n    }\n    /**\n        * Removes event with specified eventName.\n     * \n        * @param {string} eventName\n        */\n    off(eventName) {\n      this._removeListeners(eventName);\n    }\n    /**\n        * Emits event with specified name and params.\n     * \n        * @param {string} eventName\n        * @param eventArgs\n        */\n    emit(eventName, ...eventArgs) {\n      return this._applyEvents(eventName, eventArgs);\n    }\n    /**\n     * Register a new listener\n     * \n     * @param {string} eventName \n     * @param {function} listener \n     * @param {bool} once \n     */\n    _addListener(eventName, listener, once = false) {\n      if (Array.isArray(eventName)) {\n        eventName.forEach((e2) => this._addListener(e2, listener, once));\n      } else {\n        eventName = eventName.toString();\n        const split = eventName.split(/,|, | /);\n        if (split.length > 1) {\n          split.forEach((e2) => this._addListener(e2, listener, once));\n        } else {\n          if (!Array.isArray(this._listeners.get(eventName))) {\n            this._listeners.set(eventName, []);\n          }\n          this._listeners.get(eventName).push({\n            once,\n            fn: listener\n          });\n        }\n      }\n    }\n    /**\n     * \n     * @param {string|null} eventName \n     */\n    _removeListeners(eventName = null) {\n      if (eventName !== null) {\n        if (Array.isArray(eventName)) {\n          name.forEach((e2) => this.removeListeners(e2));\n        } else {\n          eventName = eventName.toString();\n          const split = eventName.split(/,|, | /);\n          if (split.length > 1) {\n            split.forEach((e2) => this.removeListeners(e2));\n          } else {\n            this._listeners.delete(eventName);\n          }\n        }\n      } else {\n        this._listeners = /* @__PURE__ */ new Map();\n      }\n    }\n    /**\n        * Applies arguments to specified event\n     * \n        * @param {string} eventName\n        * @param {*[]} eventArguments\n        * @protected\n        */\n    _applyEvents(eventName, eventArguments) {\n      let result = eventArguments;\n      if (this._listeners.has(eventName)) {\n        const listeners = this._listeners.get(eventName);\n        let removableListeners = [];\n        listeners.forEach((listener, index) => {\n          if (result = listener.fn.apply(null, eventArguments)) {\n            if (listener.once) {\n              removableListeners.unshift(index);\n            }\n          }\n        });\n        removableListeners.forEach((index) => {\n          listeners.splice(index, 1);\n        });\n        return result;\n      }\n      return result[0];\n    }\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/utils/type.js\n  var isFunction2 = (unknown) => typeof unknown === \"function\";\n  var isString2 = (unknown) => typeof unknown === \"string\" || !!unknown && typeof unknown === \"object\" && Object.prototype.toString.call(unknown) === \"[object String]\";\n  var isObject = (unknown) => (typeof unknown === \"function\" || typeof unknown === \"object\" && !!unknown) && !Array.isArray(unknown);\n  var isPromise = (value) => Boolean(value && typeof value.then === \"function\");\n  var isNode = (unknown) => {\n    try {\n      Node.prototype.cloneNode.call(unknown, false);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n  var BooleanParse = function(val) {\n    const falsy = /^(?:f(?:alse)?|no?|0+)$/i;\n    return !falsy.test(val) && !!val;\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/utils/dom.js\n  var querySelector = (selector, node) => {\n    if (isFunction2(selector)) {\n      return selector(node);\n    }\n    if (isNode(selector)) {\n      return selector;\n    }\n    if (isString2(selector)) {\n      if (!node || !isNode(node) || node.nodeType !== 1) {\n        node = document;\n      }\n      return node.querySelector(selector);\n    }\n    if (Array.isArray(selector) || typeof NodeList !== \"undefined\" && NodeList.prototype.isPrototypeOf(selector)) {\n      return selector[0];\n    }\n  };\n  var querySelectorAll = (selector, node) => {\n    if (isFunction2(selector)) {\n      return selector(node);\n    }\n    if (isNode(selector)) {\n      return [selector];\n    }\n    if (isString2(selector)) {\n      if (!node || !isNode(node) || node.nodeType !== 1) {\n        node = document;\n      }\n      return node.querySelectorAll(selector);\n    }\n    if (typeof NodeList !== \"undefined\" && NodeList.prototype.isPrototypeOf(selector)) {\n      return selector;\n    } else {\n      return [];\n    }\n  };\n  var optionsFromDataset = (node, defaultOptions2 = {}) => {\n    if (isNode(node)) {\n      return node.dataset ? Object.keys(node.dataset).filter((key) => Object.keys(defaultOptions2).includes(key)).reduce((obj, key) => {\n        return {\n          ...obj,\n          [key]: node.dataset[key]\n        };\n      }, {}) : {};\n    } else {\n      return {};\n    }\n  };\n  var cloneAttributes2 = (target, source, except = null) => {\n    if (except !== null) {\n      except = except.split(\" \");\n    }\n    [...source.attributes].forEach((attr) => {\n      if (!except.includes(attr.nodeName)) {\n        target.setAttribute(attr.nodeName === \"id\" ? \"data-id\" : attr.nodeName, attr.nodeValue);\n      }\n    });\n  };\n  var escape = (string) => {\n    return isString2(string) ? string.replace(/(['\"<>])/g, (char) => {\n      return {\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n      }[char];\n    }) : string;\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/utils/uuid.js\n  var uuid_default = (prefix = \"\") => prefix + ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/utils/component.js\n  var Component = class extends EventEmitter {\n    constructor(element, options = {}, defaultOptions2 = {}) {\n      super();\n      this.element = querySelector(element, document);\n      if (!this.element) {\n        throw new Error(`An invalid selector or non-DOM node has been provided for ${this.constructor.name}.`);\n      }\n      this.element[this.constructor.name] = this.constructor._interface.bind(this);\n      this.element[this.constructor.name].Constructor = this.constructor.name;\n      this.id = uuid_default(this.constructor.name + \"-\");\n      this.options = {\n        ...defaultOptions2,\n        ...options,\n        ...optionsFromDataset(this.element, defaultOptions2)\n        // Use Element dataset values to override options\n      };\n    }\n    /**\n     * Initiate all DOM element corresponding to selector\n     * @method\n     * @return {Array} Array of all Plugin instances\n     */\n    static attach(selector = null, options = {}, node = null) {\n      let instances = new Array();\n      if (selector !== null) {\n        querySelectorAll(selector, node).forEach((element) => {\n          if (typeof element[this.name] === \"undefined\") {\n            instances.push(new this(element, {\n              selector,\n              ...options\n            }));\n          } else {\n            instances.push(element[this.name]);\n          }\n        });\n        if (typeof window[this.name] === \"undefined\") {\n          window[this.name] = {\n            \"observers\": []\n          };\n        }\n        if (window[this.name][\"observers\"] && !window[this.name][\"observers\"].includes(selector)) {\n          this.observeDom(selector, options);\n          window[this.name][\"observers\"].push(selector);\n        }\n      }\n      return instances;\n    }\n    /**\n     * Observe DOM mutations to automatically initialize plugin on new elements when added to the DOM\n     * \n     * @param {string} selector \n     * @param {Object} options \n     */\n    static observeDom(selector, options) {\n      const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          for (let i = 0; i < mutation.addedNodes.length; i++) {\n            if (typeof window[this.name] !== \"undefined\") {\n              this.attach(selector, options, mutation.addedNodes[i]);\n            }\n          }\n        });\n      });\n      if (typeof document !== \"undefined\") {\n        observer.observe(document, {\n          childList: true,\n          subtree: true\n        });\n      }\n    }\n    static _interface(name2 = null, options = {}) {\n      if (typeof name2 === \"string\") {\n        if (typeof this[name2] === \"undefined\") {\n          throw new TypeError(`No method named \"${name2}\"`);\n        }\n        return this[name2](options);\n      }\n      return this;\n    }\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/templates/tag.js\n  var tag_default = (data) => {\n    return `<span class=\"tag ${escape(data.style)}\" data-value=\"${escape(data.value)}\">\n        ${escape(data.text)}\n        ${data.removable ? '<div class=\"delete is-small\" data-tag=\"delete\"></div>' : \"\"}\n    </span>`;\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/defaultOptions.js\n  var defaultOptions = {\n    allowDuplicates: false,\n    // Are duplicate tags allowed ?\n    caseSensitive: true,\n    // Is duplicate tags identification case sensitive ?\n    clearSelectionOnTyping: false,\n    // Should selected tag be cleared when typing a new input ?\n    closeDropdownOnItemSelect: true,\n    // Should dropdown be closed once an item has been clicked ?\n    delimiter: \",\",\n    // Multiple tags delimiter\n    freeInput: true,\n    // Should user be able to input new tag manually ?\n    highlightDuplicate: true,\n    // Should we temporarly highlight identified duplicate tags ?\n    highlightMatchesString: true,\n    // Should we highlight identified matches strings when searching ?\n    itemValue: void 0,\n    // What is the object property to use as value when we work with Object tags ?\n    itemText: void 0,\n    // What is the object property to use as text when we work with Object tags ?\n    maxTags: void 0,\n    // Maximum number of tags allowed\n    maxChars: void 0,\n    // Maximum of characters allowed for a single tag\n    minChars: 1,\n    // Minimum of characters before processing a new tag\n    noResultsLabel: \"No results found\",\n    // Customize the dropdown placecholer when no results found\n    placeholder: \"\",\n    // Customize the input placholder\n    removable: true,\n    // Are tags removable ?\n    searchMinChars: 1,\n    // How many characters should we enter before starting dynamic search ?\n    searchOn: \"text\",\n    // On what dropdown item data do we search the entered value : 'value' or 'text' ?\n    selectable: true,\n    // Are tags selectable ?\n    source: void 0,\n    // Array/Function/Promise to get external data\n    tagClass: \"is-rounded\",\n    // Customize tags style by passing classes - They will be added to the tag element\n    trim: true\n    // Should we trim value before processing them ?\n  };\n  var defaultOptions_default = defaultOptions;\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/templates/wrapper.js\n  var wrapper_default = (data) => {\n    return `<div class=\"tags-input\">\n        <input class=\"input\" type=\"text\" placeholder=\"${escape(data.placeholder)}\">\n        <div id=\"${escape(data.uuid)}-list\" class=\"dropdown-menu\" role=\"menu\">\n            <div class=\"dropdown-content\">\n                <span class=\"dropdown-item empty-title\">${escape(data.emptyTitle)}</span>\n            </div>\n        </div>\n    </div>`;\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/templates/dropdown-item.js\n  var dropdown_item_default = (data) => {\n    return `<a href=\"javascript:void(0);\" class=\"dropdown-item\" data-value=\"${escape(data.value)}\" data-text=\"${escape(data.text)}\">${escape(data.text)}</a>`;\n  };\n\n  // node_modules/@creativebulma/bulma-tagsinput/src/js/index.js\n  var BulmaTagsInput = class extends Component {\n    constructor(element, options = {}) {\n      super(element, options, defaultOptions_default);\n      this.options.allowDuplicates = BooleanParse(this.options.allowDuplicates);\n      this.options.caseSensitive = BooleanParse(this.options.caseSensitive);\n      this.options.clearSelectionOnTyping = BooleanParse(this.options.clearSelectionOnTyping);\n      this.options.closeDropdownOnItemSelect = BooleanParse(this.options.closeDropdownOnItemSelect);\n      this.options.freeInput = BooleanParse(this.options.freeInput);\n      this.options.highlightDuplicate = BooleanParse(this.options.highlightDuplicate);\n      this.options.highlightMatchesString = BooleanParse(this.options.highlightMatchesString);\n      this.options.removable = BooleanParse(this.options.removable);\n      this.options.searchOn = this.options.searchOn.toLowerCase();\n      this.options.selectable = BooleanParse(this.options.selectable);\n      this.options.trim = BooleanParse(this.options.trim);\n      this._onDocumentClick = this._onDocumentClick.bind(this);\n      this._onInputChange = this._onInputChange.bind(this);\n      this._onInputClick = this._onInputClick.bind(this);\n      this._onInputFocusOut = this._onInputFocusOut.bind(this);\n      this._onInputFocusIn = this._onInputFocusIn.bind(this);\n      this._onInputKeyDown = this._onInputKeyDown.bind(this);\n      this._onInputKeyPress = this._onInputKeyPress.bind(this);\n      this._onOriginalInputChange = this._onOriginalInputChange.bind(this);\n      this._onTagDeleteClick = this._onTagDeleteClick.bind(this);\n      this._onTagClick = this._onTagClick.bind(this);\n      this._onDropdownItemClick = this._onDropdownItemClick.bind(this);\n      this.items = [];\n      this._selected = -1;\n      this._init();\n    }\n    /**\n     * Initiate all DOM element corresponding to selector\n     * @method\n     * @return {Array} Array of all Plugin instances\n     */\n    static attach(selector = 'input[data-type=\"tags\"], input[type=\"tags\"], select[data-type=\"tags\"], select[type=\"tags\"]', options = {}, container = null) {\n      return super.attach(selector, options, container);\n    }\n    /**\n     * Initiate plugin\n     * @method init\n     * @return {void}\n     */\n    _init() {\n      this._isSelect = this.element.tagName === \"SELECT\";\n      this._isMultiple = this._isSelect && this.element.hasAttribute(\"multiple\");\n      this._objectItems = typeof this.options.itemValue !== \"undefined\" || this._isSelect;\n      this.options.itemValue = this.options.itemValue ? this.options.itemValue : this._isSelect ? \"value\" : void 0;\n      this.options.itemText = this.options.itemText ? this.options.itemText : this._isSelect ? \"text\" : void 0;\n      if (typeof this.options.itemText === \"undefined\") {\n        this.options.itemText = this.options.itemValue;\n      }\n      this.options.freeInput = this._objectItems ? false : this.options.freeInput;\n      this.source = null;\n      if (typeof this.options.source !== \"undefined\") {\n        if (![\"value\", \"text\"].includes(this.options.searchOn)) {\n          this.options.searchOn = defaultOptions_default.searchOn;\n        }\n        if (isPromise(this.options.source)) {\n          this.source = this.options.source;\n        } else if (isFunction2(this.options.source)) {\n          this.source = (value) => Promise.resolve(this.options.source(value));\n        } else if (Array.isArray(this.options.source)) {\n          this.source = (value) => Promise.resolve(this.options.source.filter((i) => {\n            const val = this._objectItems ? i[this.options.itemValue] : i;\n            return this.options.caseSensitive ? val.includes(value) : val.toLowerCase().includes(value.toLowerCase());\n          }));\n        }\n      }\n      this._manualInputAllowed = !this._isSelect && this.options.freeInput;\n      this._filterInputAllowed = this._isSelect || this.source;\n      this._build();\n    }\n    /**\n     * Build TagsInput DOM elements\n     */\n    _build() {\n      const containerFragment = document.createRange().createContextualFragment(wrapper_default({\n        emptyTitle: typeof this.options.noResultsLabel !== \"undefined\" ? this.options.noResultsLabel : \"No results found\",\n        placeholder: this.element.placeholder ? this.element.placeholder : this.options.placeholder,\n        uuid: this.id\n      }));\n      this.container = containerFragment.firstElementChild;\n      this.input = this.container.querySelector(\"input\");\n      this.dropdown = this.container.querySelector(`#${this.id}-list .dropdown-content`);\n      this.dropdownEmptyOption = this.dropdown.querySelector(\".empty-title\");\n      cloneAttributes2(this.input, this.element, \"data-type multiple name type value\");\n      if (this.element.disabled) {\n        this.container.setAttribute(\"disabled\", \"disabled\");\n        this.options.removable = false;\n        this.options.selectable = false;\n      }\n      if (this.input.getAttribute(\"disabled\") || this.input.classList.contains(\"is-disabled\")) {\n        this.container.setAttribute(\"disabled\", \"disabled\");\n      }\n      if (!this._manualInputAllowed) {\n        this.container.classList.add(this._filterInputAllowed ? \"is-filter\" : \"no-input\");\n      }\n      if (!this._isSelect && typeof this.options.source === \"undefined\") {\n        this.dropdown.remove();\n        this.dropdown = null;\n        this.input.setAttribute(\"list\", null);\n      }\n      if (this._isSelect) {\n        Array.from(this.element.options).forEach((option) => {\n          if (option.selected) {\n            this.add(option.value ? option : {\n              value: option.text,\n              text: option.text\n            }, true);\n          }\n          this._createDropdownItem(option);\n        });\n      } else {\n        if (this.element.value.length) {\n          this.add(this._objectItems ? JSON.parse(this.element.value) : this.element.value, true);\n        }\n      }\n      this._bindEvents();\n      this.element.parentNode.insertBefore(this.container, this.element);\n      this.element.style.display = \"none\";\n    }\n    /**\n     * Bind all events listener\n     */\n    _bindEvents() {\n      document.addEventListener(\"click\", this._onDocumentClick);\n      this.element.addEventListener(\"change\", this._onOriginalInputChange);\n      this.input.addEventListener(\"input\", this._onInputChange);\n      this.input.addEventListener(\"click\", this._onInputClick);\n      this.input.addEventListener(\"keydown\", this._onInputKeyDown);\n      this.input.addEventListener(\"keypress\", this._onInputKeyPress);\n      this.input.addEventListener(\"focusout\", this._onInputFocusOut);\n      this.input.addEventListener(\"focusin\", this._onInputFocusIn);\n    }\n    /**\n     * Check if caret is at the beginning of the input value\n     */\n    _caretAtStart() {\n      try {\n        return this.input.selectionStart === 0 && this.input.selectionEnd === 0;\n      } catch (e2) {\n        return this.input.value === \"\";\n      }\n    }\n    /**\n     * Check value length constraint if option activated\n     * @param {string|object} item \n     */\n    _checkLength(item) {\n      const value = this._objectItems ? item[this.options.itemValue] : item;\n      if (!isString2(value)) {\n        return true;\n      }\n      return value.length >= this.options.minChars && (typeof this.options.maxChars === \"undefined\" || value.length <= this.options.maxChars);\n    }\n    /**\n     * Close dropdown\n     */\n    _closeDropdown() {\n      if (this.dropdown) {\n        this.emit(\"before.dropdown.close\", this);\n        this.container.classList.remove(\"is-active\");\n        this.emit(\"after.dropdown.close\", this);\n      }\n    }\n    /**\n     * Create a new dropdown item based on given item data\n     * @param {String|Object} item \n     */\n    _createDropdownItem(item) {\n      if (this.dropdown) {\n        const dropdownItemFragment = document.createRange().createContextualFragment(dropdown_item_default({\n          text: item.text,\n          value: item.value\n        }));\n        const dropdownItem = dropdownItemFragment.firstElementChild;\n        dropdownItem.dataset.value = item.value;\n        dropdownItem.dataset.text = item.text;\n        dropdownItem.addEventListener(\"click\", this._onDropdownItemClick);\n        this.dropdown.append(dropdownItem);\n      }\n    }\n    /**\n     * Create a new tag and add it to the DOM\n     * @param string value \n     */\n    _createTag(item) {\n      const tagFragment = document.createRange().createContextualFragment(tag_default({\n        removable: this.options.removable,\n        style: this.options.tagClass,\n        text: item.text,\n        value: item.value\n      }));\n      const tag = tagFragment.firstElementChild;\n      tag.addEventListener(\"click\", this._onTagClick);\n      if (this.options.removable) {\n        const deleteButton = tag.querySelector(\".delete\");\n        if (deleteButton) {\n          deleteButton.addEventListener(\"click\", this._onTagDeleteClick);\n        }\n      }\n      this.container.insertBefore(tag, this.input);\n    }\n    /**\n     * Remove all dropdown items except the empty title\n     */\n    _emptyDropdown() {\n      if (this.dropdown) {\n        Array.from(this.dropdown.children).filter((child) => !child.classList.contains(\"empty-title\")).forEach((child) => {\n          child.remove();\n        });\n      }\n    }\n    /**\n     * Find needle into a string and wrap it with <mark> HTML tag\n     * @param {String} string \n     * @param {String} needle \n     */\n    _highlightMatchesInString(string, needle) {\n      const reg = \"(\" + needle + \")(?![^<]*>|[^<>]*</)\";\n      const regex = new RegExp(reg, \"i\");\n      if (!string.match(regex)) {\n        return string;\n      }\n      const matchStartPosition = string.match(regex).index;\n      const matchEndPosition = matchStartPosition + string.match(regex)[0].toString().length;\n      const originalTextFoundByRegex = string.substring(matchStartPosition, matchEndPosition);\n      string = string.replace(regex, `<mark class=\"is-highlighted\">${originalTextFoundByRegex}</mark>`);\n      return string;\n    }\n    /**\n     * Open dropdown\n     */\n    _openDropdown() {\n      if (this.dropdown) {\n        this.container.classList.add(\"is-active\");\n      }\n    }\n    /**\n     * Propagate internal input changes to the original input\n     */\n    _propagateChange() {\n      if (!this._isSelect) {\n        this.element.value = this.value;\n      } else {\n        Array.from(this.element.options).forEach((option) => {\n          option.setAttribute(\"selected\", void 0);\n          option.selected = false;\n          if (typeof option.dataset.source !== \"undefined\") {\n            option.remove();\n          }\n        });\n        this.items.forEach((item) => {\n          this._updateSelectOptions({\n            value: this._objectItems ? item[this.options.itemValue] : item,\n            text: this._objectItems ? item[this.options.itemText] : item\n          });\n        });\n      }\n      const changeEvent = new CustomEvent(\"change\", {\n        \"detail\": this.constructor.name\n      });\n      this.element.dispatchEvent(changeEvent);\n    }\n    /**\n     * Trim value if option activated\n     * @param {string|object} item \n     */\n    _trim(item) {\n      if (this.options.trim) {\n        if (this._objectItems) {\n          if (isString2(item[this.options.itemValue])) {\n            item[this.options.itemValue] = item[this.options.itemValue].trim();\n          }\n          if (isString2(item[this.options.itemText])) {\n            item[this.options.itemText] = item[this.options.itemText].trim();\n          }\n        } else {\n          item = item.trim();\n        }\n      }\n      return item;\n    }\n    /**\n     * Filter Dropdown items to be compliant with already selected items and current input value\n     * Filtering is made on Text by default (can be changed with option)\n     */\n    _filterDropdownItems(value = null) {\n      if (this.dropdown) {\n        if (this.emit(\"before.dropdown.filter\", this)) {\n          Array.from(this.dropdown.children).filter((child) => !child.classList.contains(\"empty-title\")).forEach((child) => {\n            const childValue = child.dataset[this.options.searchOn];\n            if (this.options.highlightMatchesString) {\n              child.textContent = child.textContent.replace(/<\\/?(mark\\s?(class=\"is\\-highlighted\")?)?>]*>?/gm, \"\");\n            }\n            if (value && value.length) {\n              if (this.options.caseSensitive) {\n                child.style.display = childValue.includes(value) ? \"block\" : \"none\";\n              } else {\n                child.style.display = childValue.toLowerCase().includes(value.toLowerCase()) ? \"block\" : \"none\";\n              }\n              if (this.options.highlightMatchesString) {\n                child.innerHTML = this._highlightMatchesInString(child.innerHTML, value);\n              }\n            } else {\n              child.style.display = \"block\";\n            }\n            if (!this.options.allowDuplicates || this._isSelect && !this._isMultiple) {\n              const hasValue = this.options.searchOn === \"value\" ? this.hasValue(childValue) : this.hasText(childValue);\n              child.style.display = hasValue ? \"none\" : child.style.display;\n            }\n          });\n          const hasActiveItems = Array.from(this.dropdown.children).filter((child) => !child.classList.contains(\"empty-title\")).some((child) => child.style.display !== \"none\");\n          if (hasActiveItems) {\n            this.dropdownEmptyOption.style.display = \"none\";\n          } else {\n            this.dropdownEmptyOption.style.display = \"block\";\n          }\n          this.emit(\"after.dropdown.filter\", this);\n          return hasActiveItems;\n        }\n      }\n      return true;\n    }\n    /**\n     * Update original select option based on given item\n     * @param {String|Object} item \n     */\n    _updateSelectOptions(item) {\n      if (this._isSelect) {\n        let option = this.element.querySelector(`option[value=\"${encodeURIComponent(item.value)}\"]`) || this.element.querySelector(`option[value=\"${item.value}\"]`);\n        if (!option) {\n          const optionFragment = document.createRange().createContextualFragment(`<option value=\"${item.value}\" data-source=\"${this.id}\" selected>${item.text}</option>`);\n          option = optionFragment.firstElementChild;\n          this.element.add(option);\n        }\n        option.setAttribute(\"selected\", \"selected\");\n        option.selected = true;\n      }\n    }\n    /**\n     * Add given item\n     * item = 'john'\n     * item = 'john,jane'\n     * item = ['john', 'jane']\n     * item = [{\n     *  \"value\": \"1\",\n     *  \"text\": \"John\"\n     * }, {\n     *  \"value\": \"2\",\n     *  \"text\": \"Jane\"\n     * }]\n     * @param {String|Object} item \n     * @param {Boolean} silently Should the change be propagated to the original element\n     */\n    add(items, silently = false) {\n      if (typeof this.options.maxTags !== \"undefined\" && this.items.length >= this.options.maxTags) {\n        return this;\n      }\n      items = Array.isArray(items) ? items : isObject(items) ? [items] : items.split(this.options.delimiter);\n      if (!this._objectItems && items.filter((item) => isString2(item)).length !== items.length) {\n        throw \"Item must be a string or an array of strings\";\n      }\n      if (this._objectItems && items.filter((item) => isObject(item)).length !== items.length) {\n        throw \"Item must be an object or an array of objects\";\n      }\n      items.forEach((item) => {\n        item = this._trim(item);\n        if (this._checkLength(item)) {\n          if (this._isSelect && !this._isMultiple && this.items.length > 0) {\n            this.removeAtIndex(0);\n            this.element.remove(this.element.selectedIndex);\n          }\n          if (item = this.emit(\"before.add\", item)) {\n            if (this.options.allowDuplicates || !this.has(item)) {\n              const itemData = {\n                value: this._objectItems ? item[this.options.itemValue] : item,\n                text: this._objectItems ? item[this.options.itemText] : item\n              };\n              const tag = this._createTag(itemData);\n              this.items.push(item);\n              if (!silently) {\n                this._propagateChange();\n                this.emit(\"after.add\", {\n                  item,\n                  tag\n                });\n              }\n            } else {\n              if (this.options.highlightDuplicate) {\n                const duplicateTag = Array.from(this.container.children).filter((child) => child.classList.contains(\"tag\"))[this.indexOf(item)];\n                if (duplicateTag) {\n                  duplicateTag.classList.add(\"is-duplicate\");\n                  setTimeout(() => {\n                    duplicateTag.classList.remove(\"is-duplicate\");\n                  }, 1250);\n                }\n              }\n              this.emit(\"item.duplicate\", item);\n            }\n          }\n        }\n      });\n      return this;\n    }\n    /**\n     * Unselect the selected item\n     */\n    clearSelection() {\n      if (this._selected >= 0) {\n        const item = this.items[this._selected];\n        const tag = Array.from(this.container.children).filter((child) => child.classList.contains(\"tag\"))[this._selected];\n        if (this.emit(\"before.unselect\", {\n          item,\n          tag\n        })) {\n          if (tag) {\n            tag.classList.remove(\"is-selected\");\n          }\n          this._selected = -1;\n          this.emit(\"after.unselect\", {\n            item,\n            tag\n          });\n        }\n      }\n      return this;\n    }\n    /**\n     * Shortcut to removeAll method\n     */\n    flush() {\n      return this.removeAll();\n    }\n    /**\n     * Sets focus on the input\n     */\n    focus() {\n      this.container.classList.add(\"is-focused\");\n      this.input.focus();\n      return this;\n    }\n    /**\n     * Check if given item is present\n     * @param {String} item \n     */\n    has(item) {\n      item = this._trim(item);\n      if (this._objectItems) {\n        return this.items.some((i) => this.options.caseSensitive || !isString2(i[this.options.itemValue]) ? i[this.options.itemValue] === item[this.options.itemValue] : i[this.options.itemValue].toLowerCase() === item[this.options.itemValue].toLowerCase());\n      } else {\n        return this.hasValue(item);\n      }\n    }\n    /**\n     * Check if given text is present\n     * @param {String} value \n     */\n    hasText(value) {\n      if (this.options.trim) {\n        value = value.trim();\n      }\n      return this.items.some((i) => {\n        const val = this._objectItems ? i[this.options.itemText] : i;\n        return this.options.caseSensitive ? val === value : val.toLowerCase() === value.toLowerCase();\n      });\n    }\n    /**\n     * Check if given value is present\n     * @param {String} value \n     */\n    hasValue(value) {\n      if (this.options.trim) {\n        value = value.trim();\n      }\n      return this.items.some((i) => {\n        const val = this._objectItems ? i[this.options.itemValue] : i;\n        return this.options.caseSensitive ? val === value : val.toLowerCase() === value.toLowerCase();\n      });\n    }\n    /**\n     * Get index of given item\n     * @param {string} item \n     */\n    indexOf(item) {\n      item = this._trim(item);\n      if (this._objectItems) {\n        if (!isObject(item)) {\n          throw \"Item must be an object\";\n        }\n        return this.items.map(function(e2) {\n          return e2.value;\n        }).indexOf(item.value);\n      } else {\n        return this.items.indexOf(item);\n      }\n    }\n    /**\n     * Returns the internal input element\n     */\n    input() {\n      return this.input;\n    }\n    /**\n     * Get items\n     */\n    items() {\n      return this.items;\n    }\n    /**\n     * Remove given item\n     * item = 'john'\n     * item = 'john,jane'\n     * @param String item \n     */\n    remove(items) {\n      if (this.options.removable) {\n        items = Array.isArray(items) ? items : isObject(items) ? [items] : items.split(this.options.delimiter);\n        if (!this._objectItems && items.filter((item) => isString2(item)).length !== items.length) {\n          throw \"Item must be a string or an array of strings\";\n        }\n        if (this._objectItems && items.filter((item) => isObject(item)).length !== items.length) {\n          throw \"Item must be an object or an array of objects\";\n        }\n        items.forEach((item) => {\n          let index = this.indexOf(item);\n          while (index >= 0) {\n            this.removeAtIndex(index);\n            index = this.indexOf(item);\n          }\n        });\n      }\n      return this;\n    }\n    /**\n     * Remove all tags at once\n     */\n    removeAll() {\n      if (this.options.removable) {\n        if (this.emit(\"before.flush\", this.items)) {\n          this.clearSelection();\n          Array.from(this.container.children).filter((child) => child.classList.contains(\"tag\")).forEach((tag) => tag.remove());\n          this.items = [];\n          this._filterDropdownItems();\n          this._propagateChange();\n          this.emit(\"after.flush\", this.items);\n        }\n      }\n      return this;\n    }\n    /**\n     * Remove item at given index\n     * @param Integer index \n     */\n    removeAtIndex(index, clearSelection = true) {\n      if (this.options.removable && !isNaN(index) && index >= 0 && index < this.items.length) {\n        const tag = Array.from(this.container.children).filter((child) => child.classList.contains(\"tag\"))[index];\n        const item = this.items[index];\n        if (this.emit(\"before.remove\", item)) {\n          if (clearSelection) {\n            this.clearSelection();\n          }\n          if (tag) {\n            tag.remove();\n          }\n          if (this._isSelect) {\n            this.element.options[index].selected = false;\n          }\n          if (this._selected == index) {\n            this._selected = -1;\n          } else if (this._selected >= 0) {\n            this._selected -= 1;\n          }\n          this.items.splice(index, 1);\n          this._filterDropdownItems();\n          this._propagateChange();\n          this.emit(\"after.remove\", item);\n        }\n      }\n      return this;\n    }\n    /**\n     * Select given item\n     * @param {string} item \n     */\n    select(items) {\n      if (this.options.selectable) {\n        items = Array.isArray(items) ? items : isObject(items) ? [items] : items.split(this.options.delimiter);\n        if (!this._objectItems && items.filter((item) => isString2(item)).length !== items.length) {\n          throw \"Item must be a string or an array of strings\";\n        }\n        if (this._objectItems && items.filter((item) => isObject(item)).length !== items.length) {\n          throw \"Item must be an object or an array of objects\";\n        }\n        items.forEach((item) => {\n          this.selectAtIndex(this.indexOf(item));\n        });\n      }\n      return this;\n    }\n    /**\n     * Select tag at given index\n     * @param Integer index \n     */\n    selectAtIndex(index) {\n      if (this.options.selectable) {\n        this.clearSelection();\n        if (!isNaN(index) && index >= 0 && index < this.items.length) {\n          const tag = Array.from(this.container.children).filter((child) => child.classList.contains(\"tag\"))[index];\n          const item = this.items[index];\n          if (this.emit(\"before.select\", {\n            item,\n            tag\n          })) {\n            if (tag) {\n              tag.classList.add(\"is-selected\");\n            }\n            this._selected = index;\n            this.emit(\"after.select\", {\n              item,\n              tag\n            });\n          }\n        }\n      }\n      return this;\n    }\n    /**\n     * Get selected item\n     */\n    get selected() {\n      if (this._selected >= 0) {\n        return this.items[this._selected];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Get selected item index\n     */\n    get selectedIndex() {\n      return this._selected;\n    }\n    /**\n     * Get value\n     */\n    get value() {\n      if (!this._isSelect) {\n        if (this._objectItems) {\n          return this.items.map((item) => item.value).join(this.options.delimiter);\n        } else {\n          return this.items.join(this.options.delimiter);\n        }\n      } else {\n        return Array.from(this.element.options).filter((option) => option.selected).map((option) => option.value);\n      }\n    }\n    /**\n     * Set value\n     */\n    set value(string) {\n      this.removeAll();\n      this.add(string);\n    }\n    /**\n     * Document click event handler\n     * @param {Event} e \n     */\n    _onDocumentClick(e2) {\n      if (this.dropdown) {\n        if (this.container.contains(e2.target)) {\n          return;\n        }\n        if (e2.target.dataset.tag && e2.target.dataset.tag === \"delete\") {\n          return;\n        }\n        this._closeDropdown();\n      }\n    }\n    /**\n     * Input focus lost event handler\n     * @param {Event} e \n     */\n    _onDropdownItemClick(e2) {\n      e2.preventDefault();\n      if (this.dropdown) {\n        if (this._objectItems) {\n          let item = {};\n          item[this.options.itemText] = e2.currentTarget.dataset.text;\n          item[this.options.itemValue] = e2.currentTarget.dataset.value;\n          this.add(item);\n        } else {\n          this.add(e2.currentTarget.dataset.value);\n        }\n        this._filterDropdownItems();\n        this.input.value = \"\";\n        this.input.focus();\n        if (this.options.closeDropdownOnItemSelect) {\n          this._closeDropdown();\n        }\n      }\n    }\n    /**\n     * Input change event handler\n     * @param {Event} e \n     */\n    _onInputChange(e2) {\n      this._filterDropdownItems(this.input.value);\n    }\n    /**\n     * Input click event handler\n     * @param {Event} e \n     */\n    _onInputClick(e2) {\n      e2.preventDefault();\n      if (!this.source || this.input.value.length >= this.options.searchMinChars) {\n        this._openDropdown();\n        this._filterDropdownItems();\n      }\n    }\n    /**\n     * Input focus event handler\n     * \n     * @param {Event} e \n     */\n    _onInputFocusIn(e2) {\n      e2.preventDefault();\n      if (this.container.getAttribute(\"disabled\") !== null || this.container.classList.contains(\"is-disabled\")) {\n        this.input.blur();\n        return false;\n      }\n      this.container.classList.add(\"is-focused\");\n    }\n    /**\n     * Input focus lost event handler\n     * @param {Event} e \n     */\n    _onInputFocusOut(e2) {\n      e2.preventDefault();\n      this.container.classList.remove(\"is-focused\");\n    }\n    /**\n     * Input Keydown event handler\n     * \n     * @param {Event} e \n     */\n    _onInputKeyDown(e2) {\n      const key = e2.charCode || e2.keyCode || e2.which;\n      switch (key) {\n        case 8:\n          if (this.options.removable) {\n            if (this._caretAtStart() && this._selected >= 0) {\n              const currentItemIndex = this._selected;\n              if (currentItemIndex >= 0) {\n                this.selectAtIndex(currentItemIndex + 1 < this.items.length ? currentItemIndex + 1 : currentItemIndex - 1);\n              }\n              this.removeAtIndex(currentItemIndex, false);\n            }\n          }\n          if (this.source && this.input.value.length < this.options.searchMinChars) {\n            this._closeDropdown();\n          }\n          break;\n        case 27:\n          if (this._selected >= 0) {\n            this.clearSelection();\n          }\n          this._closeDropdown();\n          break;\n        case 46:\n          if (this.options.removable) {\n            if (this._caretAtStart() && this._selected >= 0) {\n              const currentItemIndex = this._selected;\n              if (currentItemIndex >= 0) {\n                this.selectAtIndex(currentItemIndex + 1 < this.items.length ? currentItemIndex + 1 : currentItemIndex - 1);\n              }\n              this.removeAtIndex(currentItemIndex, false);\n            }\n          }\n          if (this.source && this.input.value.length < this.options.searchMinChars) {\n            this._closeDropdown();\n          }\n          break;\n        case 37:\n          if (!this.input.value.length) {\n            if (this._selected < 0) {\n              this.selectAtIndex(this.items.length - 1);\n            } else {\n              this.selectAtIndex(this._selected - 1 >= 0 ? this._selected - 1 : this.items.length - 1);\n            }\n          }\n          break;\n        case 39:\n          if (!this.input.value.length) {\n            if (this._selected < 0) {\n              this.selectAtIndex(0);\n            } else {\n              this.selectAtIndex(this._selected + 1 >= this.items.length ? 0 : this._selected + 1);\n            }\n          }\n          break;\n        default:\n          if (this.options.clearSelectionOnTyping) {\n            this.clearSelection();\n          }\n      }\n    }\n    /**\n     * Input Keypress event handler\n     * \n     * @param {Event} e \n     */\n    _onInputKeyPress(e2) {\n      const key = e2.charCode || e2.keyCode || e2.which;\n      let value = this._trim(this.input.value) + String.fromCharCode(key);\n      if (!this._manualInputAllowed && !this._filterInputAllowed) {\n        e2.preventDefault();\n        return false;\n      }\n      if (!value.length && key !== 13) {\n        return false;\n      }\n      if (this._filterInputAllowed) {\n        this._filterDropdownItems(value);\n      }\n      if (this._filterInputAllowed && this.source && value.length >= this.options.searchMinChars && key !== 13) {\n        this._openDropdown();\n        this.dropdown.classList.add(\"is-loading\");\n        this._emptyDropdown();\n        this.source(value).then((results) => {\n          results = this.emit(\"on.results.received\", results);\n          if (results.length) {\n            results.forEach((result) => {\n              let item = {\n                value: null,\n                text: null\n              };\n              if (!isObject(result)) {\n                item.value = result;\n                item.text = result;\n              } else {\n                item.value = result[this.options.itemValue];\n                item.text = result[this.options.itemText];\n              }\n              this._createDropdownItem(item);\n            });\n          }\n          this._filterDropdownItems(value);\n          this.dropdown.classList.remove(\"is-loading\");\n        }).catch((error) => {\n          console.log(error);\n        });\n      }\n      if (this._manualInputAllowed && (value.includes(this.options.delimiter) || key == 13)) {\n        e2.preventDefault();\n        const values = value.split(this.options.delimiter);\n        values.forEach((value2) => {\n          if ((value2 = value2.replace(this.options.delimiter, \"\")) != \"\") {\n            this.add(value2);\n          }\n        });\n        value = \"\";\n        this.input.value = \"\";\n        this._closeDropdown();\n        return false;\n      }\n    }\n    /**\n     * Original input change event handler\n     * CAUTION: because original input is now hidden the change event must be triggered manually on change\n     * Example how to trigger change event manually\n     * var changeEvent = new Event('change');\n     * input.dispatchEvent(changeEvent);\n     * \n     * @param {Event} e \n     */\n    _onOriginalInputChange(e2) {\n      if (!e2.detail || isString2(e2.detail) && e2.detail !== this.constructor.name) {\n        this.value = e2.currentTarget.value;\n      }\n    }\n    /**\n     * Tag click event handler\n     * \n     * @param {Event} e \n     */\n    _onTagClick(e2) {\n      e2.preventDefault();\n      if (e2.currentTarget.classList.contains(\"delete\")) {\n        return false;\n      }\n      if (this.container.getAttribute(\"disabled\") !== null || this.container.classList.contains(\"is-disabled\")) {\n        return false;\n      }\n      this.input.focus();\n      if (this.options.selectable) {\n        const tag = e2.currentTarget.closest(\".tag\");\n        if (tag) {\n          const tagIndex = Array.from(this.container.children).indexOf(tag);\n          if (tagIndex === this._selected) {\n            this.clearSelection();\n          } else {\n            this.selectAtIndex(tagIndex);\n          }\n        }\n      }\n    }\n    /**\n     * Delete tag button click event handler\n     * \n     * @param {Event} e \n     */\n    _onTagDeleteClick(e2) {\n      e2.preventDefault();\n      if (this.container.getAttribute(\"disabled\") !== null || this.container.classList.contains(\"is-disabled\")) {\n        return false;\n      }\n      const tag = e2.currentTarget.closest(\".tag\");\n      if (tag) {\n        this.removeAtIndex(Array.from(this.container.children).indexOf(tag));\n      }\n    }\n  };\n\n  // js/base.ts\n  var import_sparkline = __toESM(require_sparkline_commonjs2());\n  window.htmx = htmx_esm_default;\n  if (window.location.host == \"phish.report\") {\n    setUser({ id: document.querySelector(\"[data-user-or-session-id]\").getAttribute(\"data-user-or-session-id\") });\n    init({\n      dsn: \"https://ad1737fd7be74a7fa051d5db6fa198d9@o1040987.ingest.sentry.io/6216154\",\n      integrations: [browserTracingIntegration(), replayIntegration()],\n      tracesSampleRate: 0.1,\n      // If the entire session is not sampled, use the below sample rate to sample\n      // sessions when an error occurs.\n      replaysOnErrorSampleRate: 1\n    });\n  }\n  window.plausible = window.plausible || function() {\n    (window.plausible.q = window.plausible.q || []).push(arguments);\n  };\n  htmx_esm_default.on(\"htmx:configRequest\", (evt) => {\n    if (evt.detail.path.startsWith(\"./\")) {\n      evt.detail.path = window.location.pathname + evt.detail.path.slice(1);\n    }\n    if (evt.detail.path.startsWith(\"//\")) {\n      evt.detail.path = evt.detail.path.slice(1);\n    }\n  });\n  htmx_esm_default.on(\"htmx:beforeSwap\", (evt) => {\n    let papercupsWidget = evt.target.querySelector(\"#PapercupsChatWidget\");\n    if (papercupsWidget) {\n      papercupsWidget.setAttribute(\"hx-preserve\", \"true\");\n    }\n  });\n  htmx_esm_default.on(\"htmx:responseError\", (evt) => {\n    if (evt.detail.xhr.status == 204) {\n      return;\n    }\n    (0, import_bulma_toast.toast)({\n      duration: 2e4,\n      closeOnClick: false,\n      message: `Error (${evt.detail.xhr.status}): ${evt.detail.xhr.response}`,\n      dismissible: true,\n      position: \"top-right\",\n      type: \"is-danger\"\n    });\n  });\n  document.getElementsByTagName(\"html\")[0].classList.add(\"jsEnabled\");\n  document.body.addEventListener(\"openProviderForm\", function(evt) {\n    (getPreference(\"autoCopyURL\") == \"true\" ? navigator.clipboard.writeText(evt.detail.reportedURL) : Promise.resolve()).then(\n      () => window.open(evt.detail.formURL, \"_blank\")\n    );\n  });\n  document.body.addEventListener(\"openTab\", function(evt) {\n    if (evt.detail.copyString) {\n      navigator.clipboard.writeText(evt.detail.copyString);\n    }\n    window.open(evt.detail.url, \"_blank\");\n  });\n  document.body.addEventListener(\"openTemplatedEmail\", function(evt) {\n    let url = \"mailto:\" + evt.detail.abuseEmail;\n    let urlParams = [];\n    let ccAddresses = [];\n    if (getPreference(\"ccEmail\")) {\n      ccAddresses.push(getPreference(\"ccEmail\"));\n    }\n    if (evt.detail.params.CaseEmailCC) {\n      ccAddresses.push(evt.detail.params.CaseEmailCC);\n    }\n    if (ccAddresses.length > 0) {\n      urlParams.push(\"cc=\" + encodeURIComponent(ccAddresses.join(\";\")));\n    }\n    urlParams.push(\"subject=\" + encodeURIComponent(mustache(getPreference(\"emailSubject\"), evt.detail.params)));\n    urlParams.push(\"body=\" + encodeURIComponent(mustache(getPreference(\"emailBody\"), evt.detail.params)));\n    window.open(url + \"?\" + urlParams.join(\"&\"), \"_blank\");\n  });\n  document.body.addEventListener(\"toast\", function(evt) {\n    (0, import_bulma_toast.toast)({\n      duration: evt.detail.duration || 2e4,\n      closeOnClick: false,\n      message: evt.detail.message,\n      dismissible: true,\n      position: \"top-right\",\n      type: evt.detail.type || \"is-danger\"\n    });\n  });\n  var hash3 = window.location.href.split(\"#\")[1];\n  var reportedURL = new URLSearchParams(window.location.search).get(\"url\") + (hash3 ? \"#\" + hash3 : \"\");\n  htmx_esm_default.onLoad(() => {\n    hash3 = window.location.href.split(\"#\")[1];\n    const url = document.getElementById(\"url\");\n    if (!url) {\n      return;\n    }\n    reportedURL = url.innerText + (hash3 ? \"#\" + hash3 : \"\");\n    url.innerText = reportedURL;\n  });\n  document.addEventListener(\"htmx:configRequest\", function(evt) {\n    const analysisID = document.getElementById(\"analysis-id\");\n    if (analysisID) {\n      evt.detail.parameters[\"analysisID\"] = analysisID.innerText;\n    }\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[data-hide-element]\").forEach((e2) => {\n      e2.addEventListener(\"click\", () => {\n        e2.closest(e2.getAttribute(\"data-hide-element\")).classList.add(\"is-hidden\");\n      });\n    });\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    tippy_esm_default(fragment.querySelectorAll(\"[data-tippy-content]\"), {\n      interactive: true,\n      // allow users to select the text within\n      interactiveBorder: 15\n      // give users a 15px border, so they don't have to be super accurate when selecting text\n    });\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\".tags-input\").forEach((el) => {\n      htmx_esm_default.remove(el);\n    });\n    fragment.querySelectorAll('[data-type=\"tags\"]').forEach((el) => {\n      el.removeAttribute(\"style\");\n      const tagOptions = JSON.parse(el.dataset[\"tagOptions\"]).map((t) => t.text);\n      const tags = new BulmaTagsInput(el, {\n        source: function(input) {\n          if (tagOptions.indexOf(input) == -1) {\n            return [input, ...tagOptions];\n          } else {\n            return [...tagOptions];\n          }\n        }\n      });\n      el.BulmaTagsInput().add(JSON.parse(el.dataset[\"tagValues\"]));\n      let syncValues = () => {\n        el.dataset[\"tagValues\"] = JSON.stringify(el.BulmaTagsInput().items);\n        htmx_esm_default.trigger(el, \"sync-tags\", null);\n      };\n      el.BulmaTagsInput().on(\"before.remove\", (tag) => {\n        return !tag.system;\n      });\n      el.BulmaTagsInput().on(\"after.add\", syncValues);\n      el.BulmaTagsInput().on(\"after.remove\", syncValues);\n    });\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    let comments = fragment.querySelector(\"#discourse-comments\");\n    if (!comments) {\n      return;\n    }\n    if (window.DiscourseEmbed) {\n      return;\n    }\n    window.DiscourseEmbed = {\n      discourseUrl: \"https://community.phish.report/\",\n      discourseEmbedUrl: document.querySelector(\"link[rel='canonical']\").getAttribute(\"href\"),\n      discourseReferrerPolicy: \"strict-origin-when-cross-origin\",\n      discourseUsername: \"bradleyjkemp\"\n    };\n    (function() {\n      var d = document.createElement(\"script\");\n      d.type = \"text/javascript\";\n      d.async = true;\n      d.src = window.DiscourseEmbed.discourseUrl + \"javascripts/embed.js\";\n      (document.getElementsByTagName(\"head\")[0] || document.getElementsByTagName(\"body\")[0]).appendChild(d);\n    })();\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[data-clear-field]\").forEach((el) => {\n      el.addEventListener(\"click\", () => {\n        var searchParams = new URLSearchParams(window.location.search);\n        searchParams.delete(el.dataset.clearField);\n        window.location.search = searchParams.toString();\n      });\n    });\n  });\n  document.addEventListener(\"keyup\", (e2) => {\n    if (!document.activeElement.matches(\"body\")) {\n      return;\n    }\n    if (e2.key == \"/\") {\n      document.querySelector(\"input[type=search]\")?.focus();\n    }\n  });\n  htmx_esm_default.onLoad((fragment) => {\n    fragment.querySelectorAll(\"[data-sparkline]\").forEach((el) => {\n      (0, import_sparkline.default)(el, JSON.parse(el.dataset.sparkline));\n    });\n  });\n})();\n/*! Bundled license information:\n\nbulma-toast/dist/bulma-toast.min.js:\n  (*!\n   * bulma-toast 2.4.2 \n   * (c) 2018-present @rfoel <rafaelfr@outlook.com> \n   * Released under the MIT License.\n   *)\n\nstore2/dist/store2.js:\n  (*! store2 - v2.12.0 - 2020-08-12\n  * Copyright (c) 2020 Nathan Bubna; Licensed (MIT OR GPL-3.0) *)\n*/\n"
      },
      CSS: ([]string) <nil>,
      Cookies: ([]string) (len=1) {
        (string) (len=260) "phishreport_session=MTcyMTkxNzYwOXxleUpoZWlJNlptRnNjMlVzSW1Ob0lqb2lJaXdpWlNJNklpSXNJbWxrSWpvaWMyVnpjMmx2Ymw5a2MzUnphSGhyWW1wcGJUZ2lMQ0pzYjJkcGJsSmxaR2x5WldOMElqcGJJaTh2ZEdGclpXUnZkMjR1Y0docGMyZ3VjbVZ3YjNKMEx5SmRmUW89fEr9_ra86LN-goqT2zFur_AFsSaPYGiixMffBS7izuFz"
      },
      Headers: ([]string) (len=16) {
        (string) (len=28) "Alt-Svc: h3=\":443\"; ma=86400",
        (string) (len=24) "Cf-Cache-Status: DYNAMIC",
        (string) (len=28) "Cf-Ray: 8a8cd3bb2b897306-LHR",
        (string) (len=20) "Content-Encoding: br",
        (string) (len=38) "Content-Type: text/html; charset=utf-8",
        (string) (len=35) "Date: Thu, 25 Jul 2024 14:26:48 GMT",
        (string) (len=65) "Nel: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}",
        (string) (len=43) "Referrer-Policy: no-referrer-when-downgrade",
        (string) (len=250) "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v4?s=xWilIHmSh%2BjTdxrIZkIcmmDGiyQRdcMECfGZwMRjBL48DzMsPSIhfdkyW48QwmJvWDNC578E3b8pimHVvXUHhfbSE0feO0Y7XwbjOyr5bjT6HfgDA7tqhU%2BKNYzFS7U%3D\"}],\"group\":\"cf-nel\",\"max_age\":604800}",
        (string) (len=18) "Server: cloudflare",
        (string) (len=44) "Strict-Transport-Security: max-age=31536000;",
        (string) (len=28) "Vary: Origin\nAccept-Encoding",
        (string) (len=31) "X-Content-Type-Options: nosniff",
        (string) (len=22) "X-Ratelimit-Limit: 256",
        (string) (len=26) "X-Ratelimit-Remaining: 256",
        (string) (len=29) "X-Ratelimit-Reset: 1721917620"
      },
      Requests: ([]string) (len=13) {
        (string) (len=62) "blob:https://phish.report/2511b5f3-bd29-4da7-8f5f-e944cf8962dc",
        (string) (len=63) "https://phish.report/static/android-chrome-512x512-ZT3ULTOQ.png",
        (string) (len=47) "https://phish.report/static/brands-UAUXROGY.svg",
        (string) (len=50) "https://phish.report/static/css/style-JN2LX6DM.css",
        (string) (len=56) "https://phish.report/static/fa-brands-400-POHNS6IM.woff2",
        (string) (len=57) "https://phish.report/static/fa-regular-400-BRQ3X57C.woff2",
        (string) (len=55) "https://phish.report/static/fa-solid-900-MV234PO5.woff2",
        (string) (len=54) "https://phish.report/static/favicon-32x32-N6PPRUTU.png",
        (string) (len=47) "https://phish.report/static/js/base-ONWR52KH.js",
        (string) (len=51) "https://phish.report/static/js/htmx-ext-PXBLON3M.js",
        (string) (len=45) "https://phish.report/static/logo-CVCRUOYQ.svg",
        (string) (len=36) "https://phish.report/user/js-enabled",
        (string) (len=65) "https://phish.report/user/login?redirect=//takedown.phish.report/"
      }
    },
    primary: (bool) true
  })
}
